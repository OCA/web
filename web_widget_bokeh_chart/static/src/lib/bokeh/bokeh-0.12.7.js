(function(root, factory) {
//  if(typeof exports === 'object' && typeof module === 'object')
//    module.exports = factory();
//  else if(typeof define === 'function' && define.amd)
//    define("Bokeh", [], factory);
//  else if(typeof exports === 'object')
//    exports["Bokeh"] = factory();
//  else
    root["Bokeh"] = factory();
})(this, function() {
  var define;
  return (function(modules, aliases, entry) {
    var cache = {};

    var require = function(name) {
      var id = aliases[name] != null ? aliases[name] : name;

      if (!cache[id]) {
        if (!modules[id]) {
          var err = new Error("Cannot find module '" + name + "'");
          err.code = 'MODULE_NOT_FOUND';
          throw err;
        }

        var module = cache[id] = {exports: {}};
        modules[id].call(module.exports, require, module, module.exports);
      }

      return cache[id].exports;
    }

    var main = require(entry);
    main.require = require;

    main.register_plugin = function(plugin_modules, plugin_aliases, plugin_entry) {
      for (var name in plugin_modules) {
        modules[name] = plugin_modules[name];
      }

      for (var name in plugin_aliases) {
        aliases[name] = plugin_aliases[name];
      }

      var plugin = require(plugin_entry);

      for (var name in plugin) {
        main[name] = plugin[name];
      }

      return plugin;
    }

    return main;
  })
([
/* base */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var models = require(130    /* ./models/index */);
var object_1 = require(28    /* ./core/util/object */);
exports.overrides = {};
var _all_models = object_1.clone(models);
exports.Models = function (name) {
    var model = exports.overrides[name] || _all_models[name];
    if (model == null) {
        throw new Error('Model \'' + name + '\' does not exist. This could be due to a widget\n                     or a custom model not being registered before first usage.');
    }
    return model;
};
exports.Models.register = function (name, model) {
    exports.overrides[name] = model;
};
exports.Models.unregister = function (name) {
    delete exports.overrides[name];
};
exports.Models.register_models = function (models, force, errorFn) {
    if (force === void 0) {
        force = false;
    }
    if (models == null)
        return;
    for (var name_1 in models) {
        var model = models[name_1];
        if (force || !_all_models.hasOwnProperty(name_1))
            _all_models[name_1] = model;
        else if (errorFn != null)
            errorFn(name_1);
        else
            console.warn('Model \'' + name_1 + '\' was already registered');
    }
};
exports.register_models = exports.Models.register_models;
exports.Models.registered_names = function () {
    return Object.keys(_all_models);
};
// "index" is a map from the toplevel model IDs rendered by
// embed.coffee, to the view objects for those models. It doesn't
// contain all views, only those explicitly rendered to an element
// by embed.coffee.
exports.index = {};    
},
/* client */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ClientConnection, ClientSession, Message, message_handlers;
var es6_promise_1 = require(295    /* es6-promise */);
var logging_1 = require(12    /* ./core/logging */);
var string_1 = require(35    /* ./core/util/string */);
var object_1 = require(28    /* ./core/util/object */);
var document_1 = require(45    /* ./document */);
exports.DEFAULT_SERVER_WEBSOCKET_URL = 'ws://localhost:5006/ws';
exports.DEFAULT_SESSION_ID = 'default';
Message = function () {
    function Message(header1, metadata1, content1) {
        this.header = header1;
        this.metadata = metadata1;
        this.content = content1;
        this.buffers = [];
    }
    Message.assemble = function (header_json, metadata_json, content_json) {
        var content, header, metadata;
        header = JSON.parse(header_json);
        metadata = JSON.parse(metadata_json);
        content = JSON.parse(content_json);
        return new Message(header, metadata, content);
    };
    Message.create_header = function (msgtype, options) {
        var header;
        header = {
            'msgid': string_1.uniqueId(),
            'msgtype': msgtype
        };
        return object_1.extend(header, options);
    };
    Message.create = function (msgtype, header_options, content) {
        var header;
        if (content == null) {
            content = {};
        }
        header = Message.create_header(msgtype, header_options);
        return new Message(header, {}, content);
    };
    Message.prototype.send = function (socket) {
        var content_json, header_json, metadata_json;
        header_json = JSON.stringify(this.header);
        metadata_json = JSON.stringify(this.metadata);
        content_json = JSON.stringify(this.content);
        socket.send(header_json);
        socket.send(metadata_json);
        return socket.send(content_json);
    };
    Message.prototype.complete = function () {
        if (this.header != null && this.metadata != null && this.content != null) {
            if ('num_buffers' in this.header) {
                return this.buffers.length === this.header['num_buffers'];
            } else {
                return true;
            }
        } else {
            return false;
        }
    };
    Message.prototype.add_buffer = function (buffer) {
        return this.buffers.push(buffer);
    };
    Message.prototype._header_field = function (field) {
        if (field in this.header) {
            return this.header[field];
        } else {
            return null;
        }
    };
    Message.prototype.msgid = function () {
        return this._header_field('msgid');
    };
    Message.prototype.msgtype = function () {
        return this._header_field('msgtype');
    };
    Message.prototype.sessid = function () {
        return this._header_field('sessid');
    };
    Message.prototype.reqid = function () {
        return this._header_field('reqid');
    };
    Message.prototype.problem = function () {
        if (!('msgid' in this.header)) {
            return 'No msgid in header';
        } else if (!('msgtype' in this.header)) {
            return 'No msgtype in header';
        } else {
            return null;
        }
    };
    return Message;
}();
message_handlers = {
    'PATCH-DOC': function (connection, message) {
        return connection._for_session(function (session) {
            return session._handle_patch(message);
        });
    },
    'OK': function (connection, message) {
        return logging_1.logger.trace('Unhandled OK reply to ' + message.reqid());
    },
    'ERROR': function (connection, message) {
        return logging_1.logger.error('Unhandled ERROR reply to ' + message.reqid() + ': ' + message.content['text']);
    }
};
ClientConnection = function () {
    ClientConnection._connection_count = 0;
    function ClientConnection(url1, id, args_string1, _on_have_session_hook, _on_closed_permanently_hook) {
        this.url = url1;
        this.id = id;
        this.args_string = args_string1;
        this._on_have_session_hook = _on_have_session_hook;
        this._on_closed_permanently_hook = _on_closed_permanently_hook;
        this._number = ClientConnection._connection_count;
        ClientConnection._connection_count = this._number + 1;
        if (this.url == null) {
            this.url = exports.DEFAULT_SERVER_WEBSOCKET_URL;
        }
        if (this.id == null) {
            this.id = exports.DEFAULT_SESSION_ID;
        }
        logging_1.logger.debug('Creating websocket ' + this._number + ' to \'' + this.url + '\' session \'' + this.id + '\'');
        this.socket = null;
        this.closed_permanently = false;
        this._fragments = [];
        this._partial = null;
        this._current_handler = null;
        this._pending_ack = null;
        this._pending_replies = {};
        this.session = null;
    }
    ClientConnection.prototype._for_session = function (f) {
        if (this.session !== null) {
            return f(this.session);
        }
    };
    ClientConnection.prototype.connect = function () {
        var error, ref, versioned_url;
        if (this.closed_permanently) {
            return es6_promise_1.Promise.reject(new Error('Cannot connect() a closed ClientConnection'));
        }
        if (this.socket != null) {
            return es6_promise_1.Promise.reject(new Error('Already connected'));
        }
        this._fragments = [];
        this._partial = null;
        this._pending_replies = {};
        this._current_handler = null;
        try {
            versioned_url = this.url + '?bokeh-protocol-version=1.0&bokeh-session-id=' + this.id;
            if (((ref = this.args_string) != null ? ref.length : void 0) > 0) {
                versioned_url += '&' + this.args_string;
            }
            if (window.MozWebSocket != null) {
                this.socket = new MozWebSocket(versioned_url);
            } else {
                this.socket = new WebSocket(versioned_url);
            }
            return new es6_promise_1.Promise(function (_this) {
                return function (resolve, reject) {
                    _this.socket.binaryType = 'arraybuffer';
                    _this.socket.onopen = function () {
                        return _this._on_open(resolve, reject);
                    };
                    _this.socket.onmessage = function (event) {
                        return _this._on_message(event);
                    };
                    _this.socket.onclose = function (event) {
                        return _this._on_close(event);
                    };
                    return _this.socket.onerror = function () {
                        return _this._on_error(reject);
                    };
                };
            }(this));
        } catch (error1) {
            error = error1;
            logging_1.logger.error('websocket creation failed to url: ' + this.url);
            logging_1.logger.error(' - ' + error);
            return es6_promise_1.Promise.reject(error);
        }
    };
    ClientConnection.prototype.close = function () {
        if (!this.closed_permanently) {
            logging_1.logger.debug('Permanently closing websocket connection ' + this._number);
            this.closed_permanently = true;
            if (this.socket != null) {
                this.socket.close(1000, 'close method called on ClientConnection ' + this._number);
            }
            this._for_session(function (session) {
                return session._connection_closed();
            });
            if (this._on_closed_permanently_hook != null) {
                this._on_closed_permanently_hook();
                return this._on_closed_permanently_hook = null;
            }
        }
    };
    ClientConnection.prototype._schedule_reconnect = function (milliseconds) {
        var retry;
        retry = function (_this) {
            return function () {
                if (true || _this.closed_permanently) {
                    if (!_this.closed_permanently) {
                        logging_1.logger.info('Websocket connection ' + _this._number + ' disconnected, will not attempt to reconnect');
                    }
                } else {
                    logging_1.logger.debug('Attempting to reconnect websocket ' + _this._number);
                    return _this.connect();
                }
            };
        }(this);
        return setTimeout(retry, milliseconds);
    };
    ClientConnection.prototype.send = function (message) {
        if (this.socket === null) {
            throw new Error('not connected so cannot send ' + message);
        }
        return message.send(this.socket);
    };
    ClientConnection.prototype.send_event = function (event) {
        var message;
        message = Message.create('EVENT', {}, JSON.stringify(event));
        return this.send(message);
    };
    ClientConnection.prototype.send_with_reply = function (message) {
        var promise;
        promise = new es6_promise_1.Promise(function (_this) {
            return function (resolve, reject) {
                _this._pending_replies[message.msgid()] = [
                    resolve,
                    reject
                ];
                return _this.send(message);
            };
        }(this));
        return promise.then(function (message) {
            if (message.msgtype() === 'ERROR') {
                throw new Error('Error reply ' + message.content['text']);
            } else {
                return message;
            }
        }, function (error) {
            throw error;
        });
    };
    ClientConnection.prototype._pull_doc_json = function () {
        var message, promise;
        message = Message.create('PULL-DOC-REQ', {});
        promise = this.send_with_reply(message);
        return promise.then(function (reply) {
            if (!('doc' in reply.content)) {
                throw new Error('No \'doc\' field in PULL-DOC-REPLY');
            }
            return reply.content['doc'];
        }, function (error) {
            throw error;
        });
    };
    ClientConnection.prototype._repull_session_doc = function () {
        if (this.session === null) {
            logging_1.logger.debug('Pulling session for first time');
        } else {
            logging_1.logger.debug('Repulling session');
        }
        return this._pull_doc_json().then(function (_this) {
            return function (doc_json) {
                var document, patch, patch_message;
                if (_this.session === null) {
                    if (_this.closed_permanently) {
                        return logging_1.logger.debug('Got new document after connection was already closed');
                    } else {
                        document = document_1.Document.from_json(doc_json);
                        patch = document_1.Document._compute_patch_since_json(doc_json, document);
                        if (patch.events.length > 0) {
                            logging_1.logger.debug('Sending ' + patch.events.length + ' changes from model construction back to server');
                            patch_message = Message.create('PATCH-DOC', {}, patch);
                            _this.send(patch_message);
                        }
                        _this.session = new ClientSession(_this, document, _this.id);
                        logging_1.logger.debug('Created a new session from new pulled doc');
                        if (_this._on_have_session_hook != null) {
                            _this._on_have_session_hook(_this.session);
                            return _this._on_have_session_hook = null;
                        }
                    }
                } else {
                    _this.session.document.replace_with_json(doc_json);
                    return logging_1.logger.debug('Updated existing session with new pulled doc');
                }
            };
        }(this), function (error) {
            throw error;
        })['catch'](function (error) {
            if (console.trace != null) {
                console.trace(error);
            }
            return logging_1.logger.error('Failed to repull session ' + error);
        });
    };
    ClientConnection.prototype._on_open = function (resolve, reject) {
        logging_1.logger.info('Websocket connection ' + this._number + ' is now open');
        this._pending_ack = [
            resolve,
            reject
        ];
        return this._current_handler = function (_this) {
            return function (message) {
                return _this._awaiting_ack_handler(message);
            };
        }(this);
    };
    ClientConnection.prototype._on_message = function (event) {
        return this._on_message_unchecked(event);
    };
    ClientConnection.prototype._on_message_unchecked = function (event) {
        var msg, problem;
        if (this._current_handler == null) {
            logging_1.logger.error('got a message but haven\'t set _current_handler');
        }
        if (event.data instanceof ArrayBuffer) {
            if (this._partial != null && !this._partial.complete()) {
                this._partial.add_buffer(event.data);
            } else {
                this._close_bad_protocol('Got binary from websocket but we were expecting text');
            }
        } else if (this._partial != null) {
            this._close_bad_protocol('Got text from websocket but we were expecting binary');
        } else {
            this._fragments.push(event.data);
            if (this._fragments.length === 3) {
                this._partial = Message.assemble(this._fragments[0], this._fragments[1], this._fragments[2]);
                this._fragments = [];
                problem = this._partial.problem();
                if (problem !== null) {
                    this._close_bad_protocol(problem);
                }
            }
        }
        if (this._partial != null && this._partial.complete()) {
            msg = this._partial;
            this._partial = null;
            return this._current_handler(msg);
        }
    };
    ClientConnection.prototype._on_close = function (event) {
        var pop_pending, promise_funcs;
        logging_1.logger.info('Lost websocket ' + this._number + ' connection, ' + event.code + ' (' + event.reason + ')');
        this.socket = null;
        if (this._pending_ack != null) {
            this._pending_ack[1](new Error('Lost websocket connection, ' + event.code + ' (' + event.reason + ')'));
            this._pending_ack = null;
        }
        pop_pending = function (_this) {
            return function () {
                var promise_funcs, ref, reqid;
                ref = _this._pending_replies;
                for (reqid in ref) {
                    promise_funcs = ref[reqid];
                    delete _this._pending_replies[reqid];
                    return promise_funcs;
                }
                return null;
            };
        }(this);
        promise_funcs = pop_pending();
        while (promise_funcs !== null) {
            promise_funcs[1]('Disconnected');
            promise_funcs = pop_pending();
        }
        if (!this.closed_permanently) {
            return this._schedule_reconnect(2000);
        }
    };
    ClientConnection.prototype._on_error = function (reject) {
        logging_1.logger.debug('Websocket error on socket  ' + this._number);
        return reject(new Error('Could not open websocket'));
    };
    ClientConnection.prototype._close_bad_protocol = function (detail) {
        logging_1.logger.error('Closing connection: ' + detail);
        if (this.socket != null) {
            return this.socket.close(1002, detail);
        }
    };
    ClientConnection.prototype._awaiting_ack_handler = function (message) {
        if (message.msgtype() === 'ACK') {
            this._current_handler = function (_this) {
                return function (message) {
                    return _this._steady_state_handler(message);
                };
            }(this);
            this._repull_session_doc();
            if (this._pending_ack != null) {
                this._pending_ack[0](this);
                return this._pending_ack = null;
            }
        } else {
            return this._close_bad_protocol('First message was not an ACK');
        }
    };
    ClientConnection.prototype._steady_state_handler = function (message) {
        var promise_funcs;
        if (message.reqid() in this._pending_replies) {
            promise_funcs = this._pending_replies[message.reqid()];
            delete this._pending_replies[message.reqid()];
            return promise_funcs[0](message);
        } else if (message.msgtype() in message_handlers) {
            return message_handlers[message.msgtype()](this, message);
        } else {
            return logging_1.logger.debug('Doing nothing with message ' + message.msgtype());
        }
    };
    return ClientConnection;
}();
ClientSession = function () {
    function ClientSession(_connection, document1, id) {
        this._connection = _connection;
        this.document = document1;
        this.id = id;
        this.document_listener = function (_this) {
            return function (event) {
                return _this._document_changed(event);
            };
        }(this);
        this.document.on_change(this.document_listener);
        this.event_manager = this.document.event_manager;
        this.event_manager.session = this;
    }
    ClientSession.prototype.close = function () {
        return this._connection.close();
    };
    ClientSession.prototype.send_event = function (type) {
        return this._connection.send_event(type);
    };
    ClientSession.prototype._connection_closed = function () {
        return this.document.remove_on_change(this.document_listener);
    };
    ClientSession.prototype.request_server_info = function () {
        var message, promise;
        message = Message.create('SERVER-INFO-REQ', {});
        promise = this._connection.send_with_reply(message);
        return promise.then(function (reply) {
            return reply.content;
        });
    };
    ClientSession.prototype.force_roundtrip = function () {
        return this.request_server_info().then(function (ignored) {
            return void 0;
        });
    };
    ClientSession.prototype._document_changed = function (event) {
        var patch;
        if (event.setter_id === this.id) {
            return;
        }
        if (event instanceof document_1.ModelChangedEvent && !(event.attr in event.model.serializable_attributes())) {
            return;
        }
        patch = Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));
        return this._connection.send(patch);
    };
    ClientSession.prototype._handle_patch = function (message) {
        return this.document.apply_json_patch(message.content, this.id);
    };
    return ClientSession;
}();
exports.pull_session = function (url, session_id, args_string) {
    var connection, promise, rejecter;
    rejecter = null;
    connection = null;
    promise = new es6_promise_1.Promise(function (resolve, reject) {
        connection = new ClientConnection(url, session_id, args_string, function (session) {
            var e;
            try {
                return resolve(session);
            } catch (error1) {
                e = error1;
                logging_1.logger.error('Promise handler threw an error, closing session ' + error);
                session.close();
                throw e;
            }
        }, function () {
            return reject(new Error('Connection was closed before we successfully pulled a session'));
        });
        return connection.connect().then(function (whatever) {
        }, function (error) {
            logging_1.logger.error('Failed to connect to Bokeh server ' + error);
            throw error;
        });
    });
    promise.close = function () {
        return connection.close();
    };
    return promise;
};    
},
/* core/bokeh_events */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var tslib_1 = require(357    /* tslib */);
var logging_1 = require(12    /* ./logging */);
var object_1 = require(28    /* ./util/object */);
var event_classes = {};
function register_event_class(event_name) {
    return function (event_cls) {
        event_cls.prototype.event_name = event_name;
        event_classes[event_name] = event_cls;
    };
}
exports.register_event_class = register_event_class;
function register_with_event(event_cls) {
    var models = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        models[_i - 1] = arguments[_i];
    }
    var applicable_models = event_cls.prototype.applicable_models.concat(models);
    event_cls.prototype.applicable_models = applicable_models;
}
exports.register_with_event = register_with_event;
var BokehEvent = function () {
    function BokehEvent(options) {
        if (options === void 0) {
            options = {};
        }
        this.model_id = null;
        this._options = options;
        if (options.model_id) {
            this.model_id = options.model_id;
        }
    }
    BokehEvent.prototype.set_model_id = function (id) {
        this._options.model_id = id;
        this.model_id = id;
        return this;
    };
    BokehEvent.prototype.is_applicable_to = function (obj) {
        return this.applicable_models.some(function (model) {
            return obj instanceof model;
        });
    };
    BokehEvent.event_class = function (e) {
        // Given an event with a type attribute matching the event_name,
        // return the appropriate BokehEvent class
        if (e.type) {
            return event_classes[e.type];
        } else {
            logging_1.logger.warn('BokehEvent.event_class required events with a string type attribute');
        }
    };
    BokehEvent.prototype.toJSON = function () {
        return {
            event_name: this.event_name,
            event_values: object_1.clone(this._options)
        };
    };
    BokehEvent.prototype._customize_event = function (_model) {
        return this;
    };
    return BokehEvent;
}();
exports.BokehEvent = BokehEvent;
BokehEvent.prototype.applicable_models = [];
var ButtonClick = function (_super) {
    tslib_1.__extends(ButtonClick, _super);
    function ButtonClick() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ButtonClick = tslib_1.__decorate([register_event_class('button_click')], ButtonClick);
    return ButtonClick;
}(BokehEvent);
exports.ButtonClick = ButtonClick;
// A UIEvent is an event originating on a PlotCanvas this includes
// DOM events such as keystrokes as well as hammer events and LOD events.
var UIEvent = function (_super) {
    tslib_1.__extends(UIEvent, _super);
    function UIEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return UIEvent;
}(BokehEvent);
exports.UIEvent = UIEvent;
var LODStart = function (_super) {
    tslib_1.__extends(LODStart, _super);
    function LODStart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LODStart = tslib_1.__decorate([register_event_class('lodstart')], LODStart);
    return LODStart;
}(UIEvent);
exports.LODStart = LODStart;
var LODEnd = function (_super) {
    tslib_1.__extends(LODEnd, _super);
    function LODEnd() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LODEnd = tslib_1.__decorate([register_event_class('lodend')], LODEnd);
    return LODEnd;
}(UIEvent);
exports.LODEnd = LODEnd;
var SelectionGeometry = function (_super) {
    tslib_1.__extends(SelectionGeometry, _super);
    function SelectionGeometry(options) {
        var _this = _super.call(this, options) || this;
        _this.geometry = options.geometry;
        _this.final = options.final;
        return _this;
    }
    SelectionGeometry = tslib_1.__decorate([register_event_class('selectiongeometry')], SelectionGeometry);
    return SelectionGeometry;
}(UIEvent);
exports.SelectionGeometry = SelectionGeometry;
var PointEvent = function (_super) {
    tslib_1.__extends(PointEvent, _super);
    function PointEvent(options) {
        var _this = _super.call(this, options) || this;
        _this.sx = options.sx;
        _this.sy = options.sy;
        _this.x = null;
        _this.y = null;
        return _this;
    }
    PointEvent.from_event = function (e, model_id) {
        if (model_id === void 0) {
            model_id = null;
        }
        return new this({
            sx: e.bokeh['sx'],
            sy: e.bokeh['sy'],
            model_id: model_id
        });
    };
    PointEvent.prototype._customize_event = function (plot) {
        var xscale = plot.plot_canvas.frame.xscales['default'];
        var yscale = plot.plot_canvas.frame.yscales['default'];
        this.x = xscale.invert(plot.plot_canvas.canvas.sx_to_vx(this.sx));
        this.y = yscale.invert(plot.plot_canvas.canvas.sy_to_vy(this.sy));
        this._options['x'] = this.x;
        this._options['y'] = this.y;
        return this;
    };
    return PointEvent;
}(UIEvent);
exports.PointEvent = PointEvent;
var Pan = function (_super) {
    tslib_1.__extends(Pan, _super);
    function Pan(options) {
        if (options === void 0) {
            options = {};
        }
        var _this = _super.call(this, options) || this;
        _this.delta_x = options.delta_x;
        _this.delta_y = options.delta_y;
        return _this;
    }
    Pan.from_event = function (e, model_id) {
        if (model_id === void 0) {
            model_id = null;
        }
        return new this({
            sx: e.bokeh['sx'],
            sy: e.bokeh['sy'],
            delta_x: e.deltaX,
            delta_y: e.deltaY,
            direction: e.direction,
            model_id: model_id
        });
    };
    Pan = tslib_1.__decorate([register_event_class('pan')], Pan);
    return Pan;
}(PointEvent);
exports.Pan = Pan;
var Pinch = function (_super) {
    tslib_1.__extends(Pinch, _super);
    function Pinch(options) {
        if (options === void 0) {
            options = {};
        }
        var _this = _super.call(this, options) || this;
        _this.scale = options.scale;
        return _this;
    }
    Pinch.from_event = function (e, model_id) {
        if (model_id === void 0) {
            model_id = null;
        }
        return new this({
            sx: e.bokeh['sx'],
            sy: e.bokeh['sy'],
            scale: e.scale,
            model_id: model_id
        });
    };
    Pinch = tslib_1.__decorate([register_event_class('pinch')], Pinch);
    return Pinch;
}(PointEvent);
exports.Pinch = Pinch;
var MouseWheel = function (_super) {
    tslib_1.__extends(MouseWheel, _super);
    function MouseWheel(options) {
        if (options === void 0) {
            options = {};
        }
        var _this = _super.call(this, options) || this;
        _this.delta = options.delta;
        return _this;
    }
    MouseWheel.from_event = function (e, model_id) {
        if (model_id === void 0) {
            model_id = null;
        }
        return new this({
            sx: e.bokeh['sx'],
            sy: e.bokeh['sy'],
            delta: e.bokeh['delta'],
            model_id: model_id
        });
    };
    MouseWheel = tslib_1.__decorate([register_event_class('wheel')], MouseWheel);
    return MouseWheel;
}(PointEvent);
exports.MouseWheel = MouseWheel;
var MouseMove = function (_super) {
    tslib_1.__extends(MouseMove, _super);
    function MouseMove() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MouseMove = tslib_1.__decorate([register_event_class('mousemove')], MouseMove);
    return MouseMove;
}(PointEvent);
exports.MouseMove = MouseMove;
var MouseEnter = function (_super) {
    tslib_1.__extends(MouseEnter, _super);
    function MouseEnter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MouseEnter = tslib_1.__decorate([register_event_class('mouseenter')], MouseEnter);
    return MouseEnter;
}(PointEvent);
exports.MouseEnter = MouseEnter;
var MouseLeave = function (_super) {
    tslib_1.__extends(MouseLeave, _super);
    function MouseLeave() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MouseLeave = tslib_1.__decorate([register_event_class('mouseleave')], MouseLeave);
    return MouseLeave;
}(PointEvent);
exports.MouseLeave = MouseLeave;
var Tap = function (_super) {
    tslib_1.__extends(Tap, _super);
    function Tap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tap = tslib_1.__decorate([register_event_class('tap')], Tap);
    return Tap;
}(PointEvent);
exports.Tap = Tap;
var DoubleTap = function (_super) {
    tslib_1.__extends(DoubleTap, _super);
    function DoubleTap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DoubleTap = tslib_1.__decorate([register_event_class('doubletap')], DoubleTap);
    return DoubleTap;
}(PointEvent);
exports.DoubleTap = DoubleTap;
var Press = function (_super) {
    tslib_1.__extends(Press, _super);
    function Press() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Press = tslib_1.__decorate([register_event_class('press')], Press);
    return Press;
}(PointEvent);
exports.Press = Press;
var PanStart = function (_super) {
    tslib_1.__extends(PanStart, _super);
    function PanStart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PanStart = tslib_1.__decorate([register_event_class('panstart')], PanStart);
    return PanStart;
}(PointEvent);
exports.PanStart = PanStart;
var PanEnd = function (_super) {
    tslib_1.__extends(PanEnd, _super);
    function PanEnd() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PanEnd = tslib_1.__decorate([register_event_class('panend')], PanEnd);
    return PanEnd;
}(PointEvent);
exports.PanEnd = PanEnd;
var PinchStart = function (_super) {
    tslib_1.__extends(PinchStart, _super);
    function PinchStart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PinchStart = tslib_1.__decorate([register_event_class('pinchstart')], PinchStart);
    return PinchStart;
}(PointEvent);
exports.PinchStart = PinchStart;
var PinchEnd = function (_super) {
    tslib_1.__extends(PinchEnd, _super);
    function PinchEnd() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PinchEnd = tslib_1.__decorate([register_event_class('pinchend')], PinchEnd);
    return PinchEnd;
}(PointEvent);
exports.PinchEnd = PinchEnd;    
},
/* core/build_views */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var array_1 = require(20    /* ./util/array */);
var object_1 = require(28    /* ./util/object */);
exports.build_views = function (view_storage, view_models, options, view_types) {
    var created_views, i, j, k, len, len1, model, model_id, new_models, ref, to_remove, view, view_cls, view_options;
    if (view_types == null) {
        view_types = [];
    }
    to_remove = array_1.difference(Object.keys(view_storage), function () {
        var j, len, results;
        results = [];
        for (j = 0, len = view_models.length; j < len; j++) {
            model = view_models[j];
            results.push(model.id);
        }
        return results;
    }());
    for (j = 0, len = to_remove.length; j < len; j++) {
        model_id = to_remove[j];
        view_storage[model_id].remove();
        delete view_storage[model_id];
    }
    created_views = [];
    new_models = view_models.filter(function (model) {
        return view_storage[model.id] == null;
    });
    for (i = k = 0, len1 = new_models.length; k < len1; i = ++k) {
        model = new_models[i];
        view_cls = (ref = view_types[i]) != null ? ref : model.default_view;
        view_options = object_1.extend({ model: model }, options);
        view_storage[model.id] = view = new view_cls(view_options);
        created_views.push(view);
    }
    return created_views;
};
exports.remove_views = function (view_storage) {
    var id, j, len, ref, results;
    ref = object_1.keys(view_storage);
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
        id = ref[j];
        view_storage[id].remove();
        results.push(delete view_storage[id]);
    }
    return results;
};    
},
/* core/dom */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var types_1 = require(40    /* ./util/types */);
var _createElement = function (tag) {
    return function (attrs) {
        if (attrs === void 0) {
            attrs = {};
        }
        var children = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            children[_i - 1] = arguments[_i];
        }
        var element = document.createElement(tag);
        for (var attr in attrs) {
            var value = attrs[attr];
            if (value == null || types_1.isBoolean(value) && !value)
                continue;
            if (attr === 'class' && types_1.isArray(value)) {
                for (var _a = 0, _b = value; _a < _b.length; _a++) {
                    var cls = _b[_a];
                    if (cls != null)
                        element.classList.add(cls);
                }
                continue;
            }
            if (attr === 'style' && types_1.isObject(value)) {
                for (var prop in value) {
                    element.style[prop] = value[prop];
                }
                continue;
            }
            if (attr === 'data' && types_1.isObject(value)) {
                for (var key in value) {
                    element.dataset[key] = value[key];
                }
                continue;
            }
            element.setAttribute(attr, value);
        }
        function append(child) {
            if (child instanceof HTMLElement)
                element.appendChild(child);
            else if (types_1.isString(child))
                element.appendChild(document.createTextNode(child));
            else if (child != null && child !== false)
                throw new Error('expected an HTMLElement, string, false or null, got ' + JSON.stringify(child));
        }
        for (var _c = 0, children_1 = children; _c < children_1.length; _c++) {
            var child = children_1[_c];
            if (types_1.isArray(child)) {
                for (var _d = 0, child_1 = child; _d < child_1.length; _d++) {
                    var _child = child_1[_d];
                    append(_child);
                }
            } else
                append(child);
        }
        return element;
    };
};
function createElement(tag, attrs) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    return _createElement(tag).apply(void 0, [attrs].concat(children));
}
exports.createElement = createElement;
exports.div = _createElement('div'), exports.span = _createElement('span'), exports.link = _createElement('link'), exports.style = _createElement('style'), exports.a = _createElement('a'), exports.p = _createElement('p'), exports.pre = _createElement('pre'), exports.button = _createElement('button'), exports.label = _createElement('label'), exports.input = _createElement('input'), exports.select = _createElement('select'), exports.option = _createElement('option'), exports.canvas = _createElement('canvas'), exports.ul = _createElement('ul'), exports.ol = _createElement('ol'), exports.li = _createElement('li');
exports.nbsp = document.createTextNode('\xA0');
function removeElement(element) {
    var parent = element.parentNode;
    if (parent != null) {
        parent.removeChild(element);
    }
}
exports.removeElement = removeElement;
function replaceWith(element, replacement) {
    var parent = element.parentNode;
    if (parent != null) {
        parent.replaceChild(replacement, element);
    }
}
exports.replaceWith = replaceWith;
function prepend(element) {
    var nodes = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        nodes[_i - 1] = arguments[_i];
    }
    var first = element.firstChild;
    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
        var node = nodes_1[_a];
        element.insertBefore(node, first);
    }
}
exports.prepend = prepend;
function empty(element) {
    var child;
    while (child = element.firstChild) {
        element.removeChild(child);
    }
}
exports.empty = empty;
function show(element) {
    element.style.display = '';
}
exports.show = show;
function hide(element) {
    element.style.display = 'none';
}
exports.hide = hide;
function position(element) {
    return {
        top: element.offsetTop,
        left: element.offsetLeft
    };
}
exports.position = position;
function offset(element) {
    var rect = element.getBoundingClientRect();
    return {
        top: rect.top + window.pageYOffset - document.documentElement.clientTop,
        left: rect.left + window.pageXOffset - document.documentElement.clientLeft
    };
}
exports.offset = offset;
function matches(el, selector) {
    var p = Element.prototype;
    var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector;
    return f.call(el, selector);
}
exports.matches = matches;
function parent(el, selector) {
    var node = el;
    while (node = node.parentElement) {
        if (matches(node, selector))
            return node;
    }
    return null;
}
exports.parent = parent;
var Keys;
(function (Keys) {
    Keys[Keys['Tab'] = 9] = 'Tab';
    Keys[Keys['Enter'] = 13] = 'Enter';
    Keys[Keys['Esc'] = 27] = 'Esc';
    Keys[Keys['PageUp'] = 33] = 'PageUp';
    Keys[Keys['PageDown'] = 34] = 'PageDown';
    Keys[Keys['Up'] = 38] = 'Up';
    Keys[Keys['Down'] = 40] = 'Down';
}(Keys = exports.Keys || (exports.Keys = {})));    
},
/* core/dom_view */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var view_1 = require(43    /* ./view */);
var DOM = require(4    /* ./dom */);
exports.DOMView = function (superClass) {
    extend(DOMView, superClass);
    function DOMView() {
        return DOMView.__super__.constructor.apply(this, arguments);
    }
    DOMView.prototype.tagName = 'div';
    DOMView.prototype.initialize = function (options) {
        DOMView.__super__.initialize.call(this, options);
        this._has_finished = false;
        return this.el = this._createElement();
    };
    DOMView.prototype.remove = function () {
        DOM.removeElement(this.el);
        return DOMView.__super__.remove.call(this);
    };
    DOMView.prototype.layout = function () {
    };
    DOMView.prototype.render = function () {
    };
    DOMView.prototype.renderTo = function (element, replace) {
        if (replace == null) {
            replace = false;
        }
        if (!replace) {
            element.appendChild(this.el);
        } else {
            DOM.replaceWith(element, this.el);
        }
        return this.layout();
    };
    DOMView.prototype.has_finished = function () {
        return this._has_finished;
    };
    DOMView.prototype.notify_finished = function () {
        return this.root.notify_finished();
    };
    DOMView.getters({
        _root_element: function () {
            return DOM.parent(this.el, '.bk-root');
        },
        solver: function () {
            if (this.is_root) {
                return this._solver;
            } else {
                return this.parent.solver;
            }
        },
        is_idle: function () {
            return this.has_finished();
        }
    });
    DOMView.prototype._createElement = function () {
        return DOM.createElement(this.tagName, {
            id: this.id,
            'class': this.className
        });
    };
    return DOMView;
}(view_1.View);    
},
/* core/enums */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.AngleUnits = [
    'deg',
    'rad'
];
exports.Dimension = [
    'width',
    'height'
];
exports.Dimensions = [
    'width',
    'height',
    'both'
];
exports.Direction = [
    'clock',
    'anticlock'
];
exports.FontStyle = [
    'normal',
    'italic',
    'bold'
];
exports.LatLon = [
    'lat',
    'lon'
];
exports.LineCap = [
    'butt',
    'round',
    'square'
];
exports.LineJoin = [
    'miter',
    'round',
    'bevel'
];
exports.Location = [
    'above',
    'below',
    'left',
    'right'
];
exports.LegendLocation = [
    'top_left',
    'top_center',
    'top_right',
    'center_left',
    'center',
    'center_right',
    'bottom_left',
    'bottom_center',
    'bottom_right'
];
exports.Orientation = [
    'vertical',
    'horizontal'
];
exports.OutputBackend = [
    'canvas',
    'svg',
    'webgl'
];
exports.RenderLevel = [
    'image',
    'underlay',
    'glyph',
    'annotation',
    'overlay'
];
exports.RenderMode = [
    'canvas',
    'css'
];
exports.Side = [
    'left',
    'right'
];
exports.SpatialUnits = [
    'screen',
    'data'
];
exports.StartEnd = [
    'start',
    'end'
];
exports.TextAlign = [
    'left',
    'right',
    'center'
];
exports.TextBaseline = [
    'top',
    'middle',
    'bottom',
    'alphabetic',
    'hanging',
    'ideographic'
];
exports.DistributionTypes = [
    'uniform',
    'normal'
];
exports.TransformStepModes = [
    'after',
    'before',
    'center'
];
exports.SizingMode = [
    'stretch_both',
    'scale_width',
    'scale_height',
    'scale_both',
    'fixed'
];
exports.PaddingUnits = [
    'percent',
    'absolute'
];    
},
/* core/has_props */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var logging_1 = require(12    /* ./logging */);
var signaling_1 = require(18    /* ./signaling */);
var property_mixins = require(14    /* ./property_mixins */);
var refs = require(31    /* ./util/refs */);
var p = require(13    /* ./properties */);
var string_1 = require(35    /* ./util/string */);
var array_1 = require(20    /* ./util/array */);
var object_1 = require(28    /* ./util/object */);
var types_1 = require(40    /* ./util/types */);
var eq_1 = require(26    /* ./util/eq */);
exports.HasProps = function () {
    extend1(HasProps.prototype, signaling_1.Signalable);
    HasProps.getters = function (specs) {
        var fn, name, results;
        results = [];
        for (name in specs) {
            fn = specs[name];
            results.push(Object.defineProperty(this.prototype, name, { get: fn }));
        }
        return results;
    };
    HasProps.prototype.props = {};
    HasProps.prototype.mixins = [];
    HasProps.define = function (object) {
        var name, prop, results;
        results = [];
        for (name in object) {
            prop = object[name];
            results.push(function (_this) {
                return function (name, prop) {
                    var default_value, internal, props, refined_prop, type;
                    if (_this.prototype.props[name] != null) {
                        throw new Error('attempted to redefine property \'' + _this.name + '.' + name + '\'');
                    }
                    if (_this.prototype[name] != null) {
                        throw new Error('attempted to redefine attribute \'' + _this.name + '.' + name + '\'');
                    }
                    Object.defineProperty(_this.prototype, name, {
                        get: function () {
                            var value;
                            value = this.getv(name);
                            return value;
                        },
                        set: function (value) {
                            this.setv(name, value);
                            return this;
                        }
                    }, {
                        configurable: false,
                        enumerable: true
                    });
                    type = prop[0], default_value = prop[1], internal = prop[2];
                    refined_prop = {
                        type: type,
                        default_value: default_value,
                        internal: internal != null ? internal : false
                    };
                    props = object_1.clone(_this.prototype.props);
                    props[name] = refined_prop;
                    return _this.prototype.props = props;
                };
            }(this)(name, prop));
        }
        return results;
    };
    HasProps.internal = function (object) {
        var _object, fn1, name, prop;
        _object = {};
        fn1 = function (_this) {
            return function (name, prop) {
                var default_value, type;
                type = prop[0], default_value = prop[1];
                return _object[name] = [
                    type,
                    default_value,
                    true
                ];
            };
        }(this);
        for (name in object) {
            prop = object[name];
            fn1(name, prop);
        }
        return this.define(_object);
    };
    HasProps.mixin = function () {
        var mixins, names;
        names = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.define(property_mixins.create(names));
        mixins = this.prototype.mixins.concat(names);
        return this.prototype.mixins = mixins;
    };
    HasProps.mixins = function (names) {
        return this.mixin.apply(this, names);
    };
    HasProps.override = function (name_or_object, default_value) {
        var name, object, results;
        if (types_1.isString(name_or_object)) {
            object = {};
            object[name] = default_value;
        } else {
            object = name_or_object;
        }
        results = [];
        for (name in object) {
            default_value = object[name];
            results.push(function (_this) {
                return function (name, default_value) {
                    var props, value;
                    value = _this.prototype.props[name];
                    if (value == null) {
                        throw new Error('attempted to override nonexistent \'' + _this.name + '.' + name + '\'');
                    }
                    props = object_1.clone(_this.prototype.props);
                    props[name] = object_1.extend({}, value, { default_value: default_value });
                    return _this.prototype.props = props;
                };
            }(this)(name, default_value));
        }
        return results;
    };
    HasProps.define({ id: [p.Any] });
    HasProps.prototype.toString = function () {
        return this.type + '(' + this.id + ')';
    };
    function HasProps(attributes, options) {
        var default_value, name, ref, ref1, type;
        if (attributes == null) {
            attributes = {};
        }
        if (options == null) {
            options = {};
        }
        this.document = null;
        this.destroyed = new signaling_1.Signal(this, 'destroyed');
        this.change = new signaling_1.Signal(this, 'change');
        this.transformchange = new signaling_1.Signal(this, 'transformchange');
        this.attributes = {};
        this.properties = {};
        ref = this.props;
        for (name in ref) {
            ref1 = ref[name], type = ref1.type, default_value = ref1.default_value;
            if (type == null) {
                throw new Error('undefined property type for ' + this.type + '.' + name);
            }
            this.properties[name] = new type({
                obj: this,
                attr: name,
                default_value: default_value
            });
        }
        this._set_after_defaults = {};
        if (attributes.id == null) {
            this.setv('id', string_1.uniqueId(), { silent: true });
        }
        this.setv(attributes, object_1.extend({ silent: true }, options));
        if (!options.defer_initialization) {
            this.finalize(attributes, options);
        }
    }
    HasProps.prototype.finalize = function (attributes, options) {
        var name, prop, ref;
        ref = this.properties;
        for (name in ref) {
            prop = ref[name];
            prop.update();
            if (prop.spec.transform) {
                this.connect(prop.spec.transform.change, function () {
                    return this.transformchange.emit();
                });
            }
        }
        this.initialize(attributes, options);
        return this.connect_signals();
    };
    HasProps.prototype.initialize = function (attributes, options) {
    };
    HasProps.prototype.connect_signals = function () {
    };
    HasProps.prototype.disconnect_signals = function () {
        return signaling_1.Signal.disconnectReceiver(this);
    };
    HasProps.prototype.destroy = function () {
        this.disconnect_signals();
        return this.destroyed.emit();
    };
    HasProps.prototype.clone = function () {
        return new this.constructor(this.attributes);
    };
    HasProps.prototype._setv = function (attrs, options) {
        var attr, changes, changing, current, i, j, ref, silent, val;
        silent = options.silent;
        changes = [];
        changing = this._changing;
        this._changing = true;
        current = this.attributes;
        for (attr in attrs) {
            val = attrs[attr];
            val = attrs[attr];
            if (!eq_1.isEqual(current[attr], val)) {
                changes.push(attr);
            }
            current[attr] = val;
        }
        if (!silent) {
            if (changes.length) {
                this._pending = true;
            }
            for (i = j = 0, ref = changes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.properties[changes[i]].change.emit(current[changes[i]]);
            }
        }
        if (changing) {
            return this;
        }
        if (!silent && !options.no_change) {
            while (this._pending) {
                this._pending = false;
                this.change.emit();
            }
        }
        this._pending = false;
        this._changing = false;
        return this;
    };
    HasProps.prototype.setv = function (key, value, options) {
        var attrs, old, prop_name, results, val;
        if (types_1.isObject(key) || key === null) {
            attrs = key;
            options = value;
        } else {
            attrs = {};
            attrs[key] = value;
        }
        if (options == null) {
            options = {};
        }
        for (key in attrs) {
            if (!hasProp.call(attrs, key))
                continue;
            val = attrs[key];
            prop_name = key;
            if (this.props[prop_name] == null) {
                throw new Error('property ' + this.type + '.' + prop_name + ' wasn\'t declared');
            }
            if (!(options != null && options.defaults)) {
                this._set_after_defaults[key] = true;
            }
        }
        if (!object_1.isEmpty(attrs)) {
            old = {};
            for (key in attrs) {
                value = attrs[key];
                old[key] = this.getv(key);
            }
            this._setv(attrs, options);
            if ((options != null ? options.silent : void 0) == null) {
                results = [];
                for (key in attrs) {
                    value = attrs[key];
                    results.push(this._tell_document_about_change(key, old[key], this.getv(key), options));
                }
                return results;
            }
        }
    };
    HasProps.prototype.set = function (key, value, options) {
        logging_1.logger.warn('HasProps.set(\'prop_name\', value) is deprecated, use HasProps.prop_name = value instead');
        return this.setv(key, value, options);
    };
    HasProps.prototype.get = function (prop_name) {
        logging_1.logger.warn('HasProps.get(\'prop_name\') is deprecated, use HasProps.prop_name instead');
        return this.getv(prop_name);
    };
    HasProps.prototype.getv = function (prop_name) {
        if (this.props[prop_name] == null) {
            throw new Error('property ' + this.type + '.' + prop_name + ' wasn\'t declared');
        } else {
            return this.attributes[prop_name];
        }
    };
    HasProps.prototype.ref = function () {
        return refs.create_ref(this);
    };
    HasProps.prototype.set_subtype = function (subtype) {
        return this._subtype = subtype;
    };
    HasProps.prototype.attribute_is_serializable = function (attr) {
        var prop;
        prop = this.props[attr];
        if (prop == null) {
            throw new Error(this.type + '.attribute_is_serializable(\'' + attr + '\'): ' + attr + ' wasn\'t declared');
        } else {
            return !prop.internal;
        }
    };
    HasProps.prototype.serializable_attributes = function () {
        var attrs, name, ref, value;
        attrs = {};
        ref = this.attributes;
        for (name in ref) {
            value = ref[name];
            if (this.attribute_is_serializable(name)) {
                attrs[name] = value;
            }
        }
        return attrs;
    };
    HasProps._value_to_json = function (key, value, optional_parent_object) {
        var i, j, len, ref_array, ref_obj, subkey, v;
        if (value instanceof HasProps) {
            return value.ref();
        } else if (types_1.isArray(value)) {
            ref_array = [];
            for (i = j = 0, len = value.length; j < len; i = ++j) {
                v = value[i];
                ref_array.push(HasProps._value_to_json(i, v, value));
            }
            return ref_array;
        } else if (types_1.isObject(value)) {
            ref_obj = {};
            for (subkey in value) {
                if (!hasProp.call(value, subkey))
                    continue;
                ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);
            }
            return ref_obj;
        } else {
            return value;
        }
    };
    HasProps.prototype.attributes_as_json = function (include_defaults, value_to_json) {
        var attrs, key, ref, value;
        if (include_defaults == null) {
            include_defaults = true;
        }
        if (value_to_json == null) {
            value_to_json = HasProps._value_to_json;
        }
        attrs = {};
        ref = this.serializable_attributes();
        for (key in ref) {
            if (!hasProp.call(ref, key))
                continue;
            value = ref[key];
            if (include_defaults) {
                attrs[key] = value;
            } else if (key in this._set_after_defaults) {
                attrs[key] = value;
            }
        }
        return value_to_json('attributes', attrs, this);
    };
    HasProps._json_record_references = function (doc, v, result, recurse) {
        var elem, j, k, len, model, results, results1;
        if (v == null) {
        } else if (refs.is_ref(v)) {
            if (!(v.id in result)) {
                model = doc.get_model_by_id(v.id);
                return HasProps._value_record_references(model, result, recurse);
            }
        } else if (types_1.isArray(v)) {
            results = [];
            for (j = 0, len = v.length; j < len; j++) {
                elem = v[j];
                results.push(HasProps._json_record_references(doc, elem, result, recurse));
            }
            return results;
        } else if (types_1.isObject(v)) {
            results1 = [];
            for (k in v) {
                if (!hasProp.call(v, k))
                    continue;
                elem = v[k];
                results1.push(HasProps._json_record_references(doc, elem, result, recurse));
            }
            return results1;
        }
    };
    HasProps._value_record_references = function (v, result, recurse) {
        var elem, immediate, j, k, l, len, len1, obj, results, results1, results2;
        if (v == null) {
        } else if (v instanceof HasProps) {
            if (!(v.id in result)) {
                result[v.id] = v;
                if (recurse) {
                    immediate = v._immediate_references();
                    results = [];
                    for (j = 0, len = immediate.length; j < len; j++) {
                        obj = immediate[j];
                        results.push(HasProps._value_record_references(obj, result, true));
                    }
                    return results;
                }
            }
        } else if (v.buffer instanceof ArrayBuffer) {
        } else if (types_1.isArray(v)) {
            results1 = [];
            for (l = 0, len1 = v.length; l < len1; l++) {
                elem = v[l];
                results1.push(HasProps._value_record_references(elem, result, recurse));
            }
            return results1;
        } else if (types_1.isObject(v)) {
            results2 = [];
            for (k in v) {
                if (!hasProp.call(v, k))
                    continue;
                elem = v[k];
                results2.push(HasProps._value_record_references(elem, result, recurse));
            }
            return results2;
        }
    };
    HasProps.prototype._immediate_references = function () {
        var attrs, key, result, value;
        result = {};
        attrs = this.serializable_attributes();
        for (key in attrs) {
            value = attrs[key];
            HasProps._value_record_references(value, result, false);
        }
        return object_1.values(result);
    };
    HasProps.prototype.references = function () {
        var references;
        references = {};
        HasProps._value_record_references(this, references, true);
        return object_1.values(references);
    };
    HasProps.prototype.attach_document = function (doc) {
        if (this.document !== null && this.document !== doc) {
            throw new Error('models must be owned by only a single document');
        }
        this.document = doc;
        if (this._doc_attached != null) {
            return this._doc_attached();
        }
    };
    HasProps.prototype.detach_document = function () {
        return this.document = null;
    };
    HasProps.prototype._tell_document_about_change = function (attr, old, new_, options) {
        var need_invalidate, new_id, new_ref, new_refs, old_id, old_ref, old_refs;
        if (!this.attribute_is_serializable(attr)) {
            return;
        }
        if (this.document !== null) {
            new_refs = {};
            HasProps._value_record_references(new_, new_refs, false);
            old_refs = {};
            HasProps._value_record_references(old, old_refs, false);
            need_invalidate = false;
            for (new_id in new_refs) {
                new_ref = new_refs[new_id];
                if (!(new_id in old_refs)) {
                    need_invalidate = true;
                    break;
                }
            }
            if (!need_invalidate) {
                for (old_id in old_refs) {
                    old_ref = old_refs[old_id];
                    if (!(old_id in new_refs)) {
                        need_invalidate = true;
                        break;
                    }
                }
            }
            if (need_invalidate) {
                this.document._invalidate_all_models();
            }
            return this.document._notify_change(this, attr, old, new_, options);
        }
    };
    HasProps.prototype.materialize_dataspecs = function (source) {
        var data, name, prop, ref;
        data = {};
        ref = this.properties;
        for (name in ref) {
            prop = ref[name];
            if (!prop.dataspec) {
                continue;
            }
            if ((prop.optional || false) && prop.spec.value === null && !(name in this._set_after_defaults)) {
                continue;
            }
            data['_' + name] = prop.array(source);
            if (prop.spec.field != null && prop.spec.field in source._shapes) {
                data['_' + name + '_shape'] = source._shapes[prop.spec.field];
            }
            if (prop instanceof p.Distance) {
                data['max_' + name] = array_1.max(data['_' + name]);
            }
        }
        return data;
    };
    return HasProps;
}();    
},
/* core/hittest */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var dist_to_segment_squared, nullreturner, sqr;
var array_1 = require(20    /* ./util/array */);
var object_1 = require(28    /* ./util/object */);
exports.point_in_poly = function (x, y, px, py) {
    var i, inside, j, ref, x1, x2, y1, y2;
    inside = false;
    x1 = px[px.length - 1];
    y1 = py[py.length - 1];
    for (i = j = 0, ref = px.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        x2 = px[i];
        y2 = py[i];
        if (y1 < y !== y2 < y) {
            if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {
                inside = !inside;
            }
        }
        x1 = x2;
        y1 = y2;
    }
    return inside;
};
nullreturner = function () {
    return null;
};
exports.HitTestResult = function () {
    function HitTestResult() {
        this['0d'] = {
            glyph: null,
            get_view: nullreturner,
            indices: []
        };
        this['1d'] = { indices: [] };
        this['2d'] = { indices: {} };
    }
    Object.defineProperty(HitTestResult.prototype, '_0d', {
        get: function () {
            return this['0d'];
        }
    });
    Object.defineProperty(HitTestResult.prototype, '_1d', {
        get: function () {
            return this['1d'];
        }
    });
    Object.defineProperty(HitTestResult.prototype, '_2d', {
        get: function () {
            return this['2d'];
        }
    });
    HitTestResult.prototype.is_empty = function () {
        return this._0d.indices.length === 0 && this._1d.indices.length === 0 && Object.keys(this._2d.indices).length === 0;
    };
    HitTestResult.prototype.update_through_union = function (other) {
        this['0d'].indices = array_1.union(other['0d'].indices, this['0d'].indices);
        this['0d'].glyph = other['0d'].glyph || this['0d'].glyph;
        this['1d'].indices = array_1.union(other['1d'].indices, this['1d'].indices);
        return this['2d'].indices = object_1.merge(other['2d'].indices, this['2d'].indices);
    };
    return HitTestResult;
}();
exports.create_hit_test_result = function () {
    return new exports.HitTestResult();
};
exports.create_1d_hit_test_result = function (hits) {
    var _dist, i, result;
    result = new exports.HitTestResult();
    result['1d'].indices = function () {
        var j, len, ref, ref1, results;
        ref = array_1.sortBy(hits, function (arg) {
            var _i, dist;
            _i = arg[0], dist = arg[1];
            return dist;
        });
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
            ref1 = ref[j], i = ref1[0], _dist = ref1[1];
            results.push(i);
        }
        return results;
    }();
    return result;
};
exports.validate_bbox_coords = function (arg, arg1) {
    var ref, ref1, x0, x1, y0, y1;
    x0 = arg[0], x1 = arg[1];
    y0 = arg1[0], y1 = arg1[1];
    if (x0 > x1) {
        ref = [
            x1,
            x0
        ], x0 = ref[0], x1 = ref[1];
    }
    if (y0 > y1) {
        ref1 = [
            y1,
            y0
        ], y0 = ref1[0], y1 = ref1[1];
    }
    return {
        minX: x0,
        minY: y0,
        maxX: x1,
        maxY: y1
    };
};
sqr = function (x) {
    return x * x;
};
exports.dist_2_pts = function (vx, vy, wx, wy) {
    return sqr(vx - wx) + sqr(vy - wy);
};
dist_to_segment_squared = function (p, v, w) {
    var l2, t;
    l2 = exports.dist_2_pts(v.x, v.y, w.x, w.y);
    if (l2 === 0) {
        return exports.dist_2_pts(p.x, p.y, v.x, v.y);
    }
    t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) {
        return exports.dist_2_pts(p.x, p.y, v.x, v.y);
    }
    if (t > 1) {
        return exports.dist_2_pts(p.x, p.y, w.x, w.y);
    }
    return exports.dist_2_pts(p.x, p.y, v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));
};
exports.dist_to_segment = function (p, v, w) {
    return Math.sqrt(dist_to_segment_squared(p, v, w));
};
exports.check_2_segments_intersect = function (l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {
    /* Check if 2 segments (l0 and l1) intersect. Returns a structure with
      the following attributes:
        * hit (boolean): whether the 2 segments intersect
        * x (float): x coordinate of the intersection point
        * y (float): y coordinate of the intersection point
     */
    var a, b, den, num1, num2, x, y;
    den = (l1_y1 - l1_y0) * (l0_x1 - l0_x0) - (l1_x1 - l1_x0) * (l0_y1 - l0_y0);
    if (den === 0) {
        return {
            hit: false,
            x: null,
            y: null
        };
    } else {
        a = l0_y0 - l1_y0;
        b = l0_x0 - l1_x0;
        num1 = (l1_x1 - l1_x0) * a - (l1_y1 - l1_y0) * b;
        num2 = (l0_x1 - l0_x0) * a - (l0_y1 - l0_y0) * b;
        a = num1 / den;
        b = num2 / den;
        x = l0_x0 + a * (l0_x1 - l0_x0);
        y = l0_y0 + a * (l0_y1 - l0_y0);
        return {
            hit: a > 0 && a < 1 && (b > 0 && b < 1),
            x: x,
            y: y
        };
    }
};    
},
/* core/layout/layout_canvas */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var solver_1 = require(11    /* ./solver */);
var model_1 = require(48    /* ../../model */);
exports.LayoutCanvas = function (superClass) {
    extend(LayoutCanvas, superClass);
    function LayoutCanvas() {
        return LayoutCanvas.__super__.constructor.apply(this, arguments);
    }
    LayoutCanvas.prototype.type = 'LayoutCanvas';
    LayoutCanvas.prototype.initialize = function (attrs, options) {
        LayoutCanvas.__super__.initialize.call(this, attrs, options);
        this._top = new solver_1.Variable(this.toString() + '.top');
        this._left = new solver_1.Variable(this.toString() + '.left');
        this._width = new solver_1.Variable(this.toString() + '.width');
        this._height = new solver_1.Variable(this.toString() + '.height');
        this._right = new solver_1.Variable(this.toString() + '.right');
        return this._bottom = new solver_1.Variable(this.toString() + '.bottom');
    };
    LayoutCanvas.prototype.get_editables = function () {
        return [
            this._width,
            this._height
        ];
    };
    LayoutCanvas.prototype.get_constraints = function () {
        return [
            solver_1.GE(this._top),
            solver_1.GE(this._bottom),
            solver_1.GE(this._left),
            solver_1.GE(this._right),
            solver_1.GE(this._width),
            solver_1.GE(this._height),
            solver_1.EQ(this._left, this._width, [
                -1,
                this._right
            ]),
            solver_1.EQ(this._bottom, this._height, [
                -1,
                this._top
            ])
        ];
    };
    LayoutCanvas.getters({
        layout_bbox: function () {
            return {
                top: this._top.value,
                left: this._left.value,
                width: this._width.value,
                height: this._height.value,
                right: this._right.value,
                bottom: this._bottom.value
            };
        }
    });
    LayoutCanvas.prototype.dump_layout = function () {
        return console.log(this.toString(), this.layout_bbox);
    };
    return LayoutCanvas;
}(model_1.Model);    
},
/* core/layout/side_panel */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ALPHABETIC, BOTTOM, CENTER, HANGING, LEFT, MIDDLE, RIGHT, TOP, _align_lookup, _align_lookup_negative, _align_lookup_positive, _angle_lookup, _baseline_lookup, pi2, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var solver_1 = require(11    /* ./solver */);
var layout_canvas_1 = require(9    /* ./layout_canvas */);
var p = require(13    /* core/properties */);
var logging_1 = require(12    /* core/logging */);
var types_1 = require(40    /* core/util/types */);
pi2 = Math.PI / 2;
ALPHABETIC = 'alphabetic';
TOP = 'top';
BOTTOM = 'bottom';
MIDDLE = 'middle';
HANGING = 'hanging';
LEFT = 'left';
RIGHT = 'right';
CENTER = 'center';
_angle_lookup = {
    above: {
        parallel: 0,
        normal: -pi2,
        horizontal: 0,
        vertical: -pi2
    },
    below: {
        parallel: 0,
        normal: pi2,
        horizontal: 0,
        vertical: pi2
    },
    left: {
        parallel: -pi2,
        normal: 0,
        horizontal: 0,
        vertical: -pi2
    },
    right: {
        parallel: pi2,
        normal: 0,
        horizontal: 0,
        vertical: pi2
    }
};
_baseline_lookup = {
    above: {
        justified: TOP,
        parallel: ALPHABETIC,
        normal: MIDDLE,
        horizontal: ALPHABETIC,
        vertical: MIDDLE
    },
    below: {
        justified: BOTTOM,
        parallel: HANGING,
        normal: MIDDLE,
        horizontal: HANGING,
        vertical: MIDDLE
    },
    left: {
        justified: TOP,
        parallel: ALPHABETIC,
        normal: MIDDLE,
        horizontal: MIDDLE,
        vertical: ALPHABETIC
    },
    right: {
        justified: TOP,
        parallel: ALPHABETIC,
        normal: MIDDLE,
        horizontal: MIDDLE,
        vertical: ALPHABETIC
    }
};
_align_lookup = {
    above: {
        justified: CENTER,
        parallel: CENTER,
        normal: LEFT,
        horizontal: CENTER,
        vertical: LEFT
    },
    below: {
        justified: CENTER,
        parallel: CENTER,
        normal: LEFT,
        horizontal: CENTER,
        vertical: LEFT
    },
    left: {
        justified: CENTER,
        parallel: CENTER,
        normal: RIGHT,
        horizontal: RIGHT,
        vertical: CENTER
    },
    right: {
        justified: CENTER,
        parallel: CENTER,
        normal: LEFT,
        horizontal: LEFT,
        vertical: CENTER
    }
};
_align_lookup_negative = {
    above: RIGHT,
    below: LEFT,
    left: RIGHT,
    right: LEFT
};
_align_lookup_positive = {
    above: LEFT,
    below: RIGHT,
    left: RIGHT,
    right: LEFT
};
exports.update_panel_constraints = function (view) {
    var s;
    if (view.model.props.visible != null && !view.model.visible) {
        return;
    }
    s = view.solver;
    if (view._size_constraint != null && s.has_constraint(view._size_constraint)) {
        s.remove_constraint(view._size_constraint);
    }
    view._size_constraint = solver_1.GE(view.model.panel._size, -view._get_size());
    s.add_constraint(view._size_constraint);
    if (view._full_constraint != null && s.has_constraint(view._full_constraint)) {
        s.remove_constraint(view._full_constraint);
    }
    view._full_constraint = function () {
        switch (view.model.panel.side) {
        case 'above':
        case 'below':
            return solver_1.EQ(view.model.panel._width, [
                -1,
                view.plot_model.canvas._width
            ]);
        case 'left':
        case 'right':
            return solver_1.EQ(view.model.panel._height, [
                -1,
                view.plot_model.canvas._height
            ]);
        }
    }();
    return s.add_constraint(view._full_constraint);
};
exports.SidePanel = function (superClass) {
    extend(SidePanel, superClass);
    function SidePanel() {
        return SidePanel.__super__.constructor.apply(this, arguments);
    }
    SidePanel.prototype.type = 'SidePanel';
    SidePanel.internal({
        side: [p.String],
        plot: [p.Instance]
    });
    SidePanel.prototype.initialize = function (attrs, options) {
        SidePanel.__super__.initialize.call(this, attrs, options);
        switch (this.side) {
        case 'above':
            this._dim = 0;
            this._normals = [
                0,
                -1
            ];
            return this._size = this._height;
        case 'below':
            this._dim = 0;
            this._normals = [
                0,
                1
            ];
            return this._size = this._height;
        case 'left':
            this._dim = 1;
            this._normals = [
                -1,
                0
            ];
            return this._size = this._width;
        case 'right':
            this._dim = 1;
            this._normals = [
                1,
                0
            ];
            return this._size = this._width;
        default:
            return logging_1.logger.error('unrecognized side: \'' + this.side + '\'');
        }
    };
    SidePanel.getters({
        is_horizontal: function () {
            return this.side === 'above' || this.side === 'below';
        },
        is_vertical: function () {
            return this.side === 'left' || this.side === 'right';
        }
    });
    SidePanel.prototype.apply_label_text_heuristics = function (ctx, orient) {
        var align, baseline, side;
        side = this.side;
        if (types_1.isString(orient)) {
            baseline = _baseline_lookup[side][orient];
            align = _align_lookup[side][orient];
        } else if (orient === 0) {
            baseline = _baseline_lookup[side][orient];
            align = _align_lookup[side][orient];
        } else if (orient < 0) {
            baseline = 'middle';
            align = _align_lookup_negative[side];
        } else if (orient > 0) {
            baseline = 'middle';
            align = _align_lookup_positive[side];
        }
        ctx.textBaseline = baseline;
        ctx.textAlign = align;
        return ctx;
    };
    SidePanel.prototype.get_label_angle_heuristic = function (orient) {
        var side;
        side = this.side;
        return _angle_lookup[side][orient];
    };
    return SidePanel;
}(layout_canvas_1.LayoutCanvas);    
},
/* core/layout/solver */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var kiwi_1 = require(314    /* kiwi */);
exports.Variable = kiwi_1.Variable;
exports.Expression = kiwi_1.Expression;
exports.Constraint = kiwi_1.Constraint;
exports.Operator = kiwi_1.Operator;
exports.Strength = kiwi_1.Strength;
function _constrainer(op) {
    return function () {
        var terms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            terms[_i] = arguments[_i];
        }
        return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op);
    };
}
function _weak_constrainer(op) {
    return function () {
        var terms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            terms[_i] = arguments[_i];
        }
        return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op, kiwi_1.Strength.weak);
    };
}
exports.EQ = _constrainer(kiwi_1.Operator.Eq);
exports.LE = _constrainer(kiwi_1.Operator.Le);
exports.GE = _constrainer(kiwi_1.Operator.Ge);
exports.WEAK_EQ = _weak_constrainer(kiwi_1.Operator.Eq);
exports.WEAK_LE = _weak_constrainer(kiwi_1.Operator.Le);
exports.WEAK_GE = _weak_constrainer(kiwi_1.Operator.Ge);
var Solver = function () {
    function Solver() {
        this.solver = new kiwi_1.Solver();
    }
    Solver.prototype.clear = function () {
        this.solver = new kiwi_1.Solver();
    };
    Solver.prototype.toString = function () {
        return 'Solver(num_constraints=' + this.num_constraints + ', num_editables=' + this.num_editables + ')';
    };
    Object.defineProperty(Solver.prototype, 'num_constraints', {
        get: function () {
            return this.solver.numConstraints;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Solver.prototype, 'num_editables', {
        get: function () {
            return this.solver.numEditVariables;
        },
        enumerable: true,
        configurable: true
    });
    Solver.prototype.get_constraints = function () {
        return this.solver.getConstraints();
    };
    Solver.prototype.update_variables = function () {
        this.solver.updateVariables();
    };
    Solver.prototype.has_constraint = function (constraint) {
        return this.solver.hasConstraint(constraint);
    };
    Solver.prototype.add_constraint = function (constraint) {
        this.solver.addConstraint(constraint);
    };
    Solver.prototype.remove_constraint = function (constraint) {
        this.solver.removeConstraint(constraint);
    };
    Solver.prototype.add_edit_variable = function (variable, strength) {
        this.solver.addEditVariable(variable, strength);
    };
    Solver.prototype.remove_edit_variable = function (variable) {
        this.solver.removeEditVariable(variable);
    };
    Solver.prototype.suggest_value = function (variable, value) {
        this.solver.suggestValue(variable, value);
    };
    return Solver;
}();
exports.Solver = Solver;    
},
/* core/logging */ function(require, module, exports) {
'use strict';
// This is based on https://github.com/pimterry/loglevel
Object.defineProperty(exports, '__esModule', { value: true });
var types_1 = require(40    /* ./util/types */);
var _loggers = {};
var LogLevel = function () {
    function LogLevel(name, level) {
        this.name = name;
        this.level = level;
    }
    return LogLevel;
}();
exports.LogLevel = LogLevel;
var Logger = function () {
    function Logger(name, level) {
        if (level === void 0) {
            level = Logger.INFO;
        }
        this._name = name;
        this.set_level(level);
    }
    Object.defineProperty(Logger, 'levels', {
        get: function () {
            return Object.keys(Logger.log_levels);
        },
        enumerable: true,
        configurable: true
    });
    Logger.get = function (name, level) {
        if (level === void 0) {
            level = Logger.INFO;
        }
        if (name.length > 0) {
            var logger_1 = _loggers[name];
            if (logger_1 == null)
                _loggers[name] = logger_1 = new Logger(name, level);
            return logger_1;
        } else
            throw new TypeError('Logger.get() expects a non-empty string name and an optional log-level');
    };
    Object.defineProperty(Logger.prototype, 'level', {
        get: function () {
            return this.get_level();
        },
        enumerable: true,
        configurable: true
    });
    Logger.prototype.get_level = function () {
        return this._log_level;
    };
    Logger.prototype.set_level = function (log_level) {
        if (log_level instanceof LogLevel)
            this._log_level = log_level;
        else if (types_1.isString(log_level) && Logger.log_levels[log_level] != null)
            this._log_level = Logger.log_levels[log_level];
        else
            throw new Error('Logger.set_level() expects a log-level object or a string name of a log-level');
        var logger_name = '[' + this._name + ']';
        for (var name_1 in Logger.log_levels) {
            var log_level_1 = Logger.log_levels[name_1];
            if (log_level_1.level < this._log_level.level || this._log_level.level === Logger.OFF.level)
                this[name_1] = function () {
                };
            else
                this[name_1] = _method_factory(name_1, logger_name);
        }
    };
    Logger.prototype.trace = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Logger.prototype.debug = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Logger.prototype.info = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Logger.prototype.warn = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Logger.prototype.error = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Logger.TRACE = new LogLevel('trace', 0);
    Logger.DEBUG = new LogLevel('debug', 1);
    Logger.INFO = new LogLevel('info', 2);
    Logger.WARN = new LogLevel('warn', 6);
    Logger.ERROR = new LogLevel('error', 7);
    Logger.FATAL = new LogLevel('fatal', 8);
    Logger.OFF = new LogLevel('off', 9);
    Logger.log_levels = {
        trace: Logger.TRACE,
        debug: Logger.DEBUG,
        info: Logger.INFO,
        warn: Logger.WARN,
        error: Logger.ERROR,
        fatal: Logger.FATAL,
        off: Logger.OFF
    };
    return Logger;
}();
exports.Logger = Logger;
function _method_factory(method_name, logger_name) {
    if (console[method_name] != null)
        return console[method_name].bind(console, logger_name);
    else if (console.log != null)
        return console.log.bind(console, logger_name);
    else
        return function () {
        };
}
exports.logger = Logger.get('bokeh');
function set_log_level(level) {
    if (Logger.log_levels[level] == null) {
        console.log('[bokeh] unrecognized logging level \'' + level + '\' passed to Bokeh.set_log_level(), ignoring');
        console.log('[bokeh] valid log levels are: ' + Logger.levels.join(', '));
    } else {
        console.log('[bokeh] setting log level to: \'' + level + '\'');
        exports.logger.set_level(level);
    }
}
exports.set_log_level = set_log_level;    
},
/* core/properties */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var valueToString, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var signaling_1 = require(18    /* ./signaling */);
var enums = require(6    /* ./enums */);
var svg_colors = require(36    /* ./util/svg_colors */);
var color_1 = require(24    /* ./util/color */);
var array_1 = require(20    /* ./util/array */);
var types_1 = require(40    /* ./util/types */);
valueToString = function (value) {
    try {
        return JSON.stringify(value);
    } catch (error) {
        return value.toString();
    }
};
exports.Property = function () {
    extend(Property.prototype, signaling_1.Signalable);
    Property.prototype.dataspec = false;
    function Property(arg) {
        this.obj = arg.obj, this.attr = arg.attr, this.default_value = arg.default_value;
        this._init();
        this.change = new signaling_1.Signal(this.obj, 'change');
        this.connect(this.change, function (_this) {
            return function () {
                return _this._init();
            };
        }(this));
    }
    Property.prototype.update = function () {
        return this._init();
    };
    Property.prototype.init = function () {
    };
    Property.prototype.transform = function (values) {
        return values;
    };
    Property.prototype.validate = function (value) {
    };
    Property.prototype.value = function (do_spec_transform) {
        var ret;
        if (do_spec_transform == null) {
            do_spec_transform = true;
        }
        if (this.spec.value === void 0) {
            throw new Error('attempted to retrieve property value for property without value specification');
        }
        ret = this.transform([this.spec.value])[0];
        if (this.spec.transform != null && do_spec_transform) {
            ret = this.spec.transform.compute(ret);
        }
        return ret;
    };
    Property.prototype.array = function (source) {
        var data, i, length, ret, value;
        if (!this.dataspec) {
            throw new Error('attempted to retrieve property array for non-dataspec property');
        }
        data = source.data;
        if (this.spec.field != null) {
            if (this.spec.field in data) {
                ret = this.transform(source.get_column(this.spec.field));
            } else {
                throw new Error('attempted to retrieve property array for nonexistent field \'' + this.spec.field + '\'');
            }
        } else if (this.spec.expr != null) {
            ret = this.transform(this.spec.expr._v_compute(source));
        } else {
            length = source.get_length();
            if (length == null) {
                length = 1;
            }
            value = this.value(false);
            ret = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(value);
                }
                return results;
            }();
        }
        if (this.spec.transform != null) {
            ret = this.spec.transform.v_compute(ret);
        }
        return ret;
    };
    Property.prototype._init = function () {
        var attr, attr_value, default_value, obj;
        obj = this.obj;
        if (obj == null) {
            throw new Error('missing property object');
        }
        if (obj.properties == null) {
            throw new Error('property object must be a HasProps');
        }
        attr = this.attr;
        if (attr == null) {
            throw new Error('missing property attr');
        }
        attr_value = obj.getv(attr);
        if (attr_value === void 0) {
            default_value = this.default_value;
            attr_value = function () {
                switch (false) {
                case default_value !== void 0:
                    return null;
                case !types_1.isArray(default_value):
                    return array_1.copy(default_value);
                case !types_1.isFunction(default_value):
                    return default_value(obj);
                default:
                    return default_value;
                }
            }();
            obj.setv(attr, attr_value, {
                silent: true,
                defaults: true
            });
        }
        if (types_1.isArray(attr_value)) {
            this.spec = { value: attr_value };
        } else if (types_1.isObject(attr_value) && (attr_value.value === void 0 ? 0 : 1) + (attr_value.field === void 0 ? 0 : 1) + (attr_value.expr === void 0 ? 0 : 1) === 1) {
            this.spec = attr_value;
        } else {
            this.spec = { value: attr_value };
        }
        if (this.spec.field != null && !types_1.isString(this.spec.field)) {
            throw new Error('field value for property \'' + attr + '\' is not a string');
        }
        if (this.spec.value != null) {
            this.validate(this.spec.value);
        }
        return this.init();
    };
    Property.prototype.toString = function () {
        return this.name + '(' + this.obj + '.' + this.attr + ', spec: ' + valueToString(this.spec) + ')';
    };
    return Property;
}();
exports.simple_prop = function (name, pred) {
    var Prop;
    return Prop = function (superClass) {
        extend(Prop, superClass);
        function Prop() {
            return Prop.__super__.constructor.apply(this, arguments);
        }
        Prop.prototype.name = name;
        Prop.prototype.validate = function (value) {
            if (!pred(value)) {
                throw new Error(name + ' property \'' + this.attr + '\' given invalid value: ' + valueToString(value));
            }
        };
        return Prop;
    }(exports.Property);
};
exports.Any = function (superClass) {
    extend(Any, superClass);
    function Any() {
        return Any.__super__.constructor.apply(this, arguments);
    }
    return Any;
}(exports.simple_prop('Any', function (x) {
    return true;
}));
exports.Array = function (superClass) {
    extend(Array, superClass);
    function Array() {
        return Array.__super__.constructor.apply(this, arguments);
    }
    return Array;
}(exports.simple_prop('Array', function (x) {
    return types_1.isArray(x) || x instanceof Float64Array;
}));
exports.Bool = function (superClass) {
    extend(Bool, superClass);
    function Bool() {
        return Bool.__super__.constructor.apply(this, arguments);
    }
    return Bool;
}(exports.simple_prop('Bool', types_1.isBoolean));
exports.Boolean = exports.Bool;
exports.Color = function (superClass) {
    extend(Color, superClass);
    function Color() {
        return Color.__super__.constructor.apply(this, arguments);
    }
    return Color;
}(exports.simple_prop('Color', function (x) {
    return svg_colors[x.toLowerCase()] != null || x.substring(0, 1) === '#' || color_1.valid_rgb(x);
}));
exports.Instance = function (superClass) {
    extend(Instance, superClass);
    function Instance() {
        return Instance.__super__.constructor.apply(this, arguments);
    }
    return Instance;
}(exports.simple_prop('Instance', function (x) {
    return x.properties != null;
}));
exports.Number = function (superClass) {
    extend(Number, superClass);
    function Number() {
        return Number.__super__.constructor.apply(this, arguments);
    }
    return Number;
}(exports.simple_prop('Number', function (x) {
    return types_1.isNumber(x) || types_1.isBoolean(x);
}));
exports.Int = exports.Number;
exports.Percent = function (superClass) {
    extend(Percent, superClass);
    function Percent() {
        return Percent.__super__.constructor.apply(this, arguments);
    }
    return Percent;
}(exports.simple_prop('Number', function (x) {
    return (types_1.isNumber(x) || types_1.isBoolean(x)) && (0 <= x && x <= 1);
}));
exports.String = function (superClass) {
    extend(String, superClass);
    function String() {
        return String.__super__.constructor.apply(this, arguments);
    }
    return String;
}(exports.simple_prop('String', types_1.isString));
exports.Font = function (superClass) {
    extend(Font, superClass);
    function Font() {
        return Font.__super__.constructor.apply(this, arguments);
    }
    return Font;
}(exports.String);
exports.enum_prop = function (name, enum_values) {
    var Enum;
    return Enum = function (superClass) {
        extend(Enum, superClass);
        function Enum() {
            return Enum.__super__.constructor.apply(this, arguments);
        }
        Enum.prototype.name = name;
        return Enum;
    }(exports.simple_prop(name, function (x) {
        return indexOf.call(enum_values, x) >= 0;
    }));
};
exports.Anchor = function (superClass) {
    extend(Anchor, superClass);
    function Anchor() {
        return Anchor.__super__.constructor.apply(this, arguments);
    }
    return Anchor;
}(exports.enum_prop('Anchor', enums.LegendLocation));
exports.AngleUnits = function (superClass) {
    extend(AngleUnits, superClass);
    function AngleUnits() {
        return AngleUnits.__super__.constructor.apply(this, arguments);
    }
    return AngleUnits;
}(exports.enum_prop('AngleUnits', enums.AngleUnits));
exports.Direction = function (superClass) {
    extend(Direction, superClass);
    function Direction() {
        return Direction.__super__.constructor.apply(this, arguments);
    }
    Direction.prototype.transform = function (values) {
        var i, j, ref, result;
        result = new Uint8Array(values.length);
        for (i = j = 0, ref = values.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            switch (values[i]) {
            case 'clock':
                result[i] = false;
                break;
            case 'anticlock':
                result[i] = true;
            }
        }
        return result;
    };
    return Direction;
}(exports.enum_prop('Direction', enums.Direction));
exports.Dimension = function (superClass) {
    extend(Dimension, superClass);
    function Dimension() {
        return Dimension.__super__.constructor.apply(this, arguments);
    }
    return Dimension;
}(exports.enum_prop('Dimension', enums.Dimension));
exports.Dimensions = function (superClass) {
    extend(Dimensions, superClass);
    function Dimensions() {
        return Dimensions.__super__.constructor.apply(this, arguments);
    }
    return Dimensions;
}(exports.enum_prop('Dimensions', enums.Dimensions));
exports.FontStyle = function (superClass) {
    extend(FontStyle, superClass);
    function FontStyle() {
        return FontStyle.__super__.constructor.apply(this, arguments);
    }
    return FontStyle;
}(exports.enum_prop('FontStyle', enums.FontStyle));
exports.LatLon = function (superClass) {
    extend(LatLon, superClass);
    function LatLon() {
        return LatLon.__super__.constructor.apply(this, arguments);
    }
    return LatLon;
}(exports.enum_prop('LatLon', enums.LatLon));
exports.LineCap = function (superClass) {
    extend(LineCap, superClass);
    function LineCap() {
        return LineCap.__super__.constructor.apply(this, arguments);
    }
    return LineCap;
}(exports.enum_prop('LineCap', enums.LineCap));
exports.LineJoin = function (superClass) {
    extend(LineJoin, superClass);
    function LineJoin() {
        return LineJoin.__super__.constructor.apply(this, arguments);
    }
    return LineJoin;
}(exports.enum_prop('LineJoin', enums.LineJoin));
exports.LegendLocation = function (superClass) {
    extend(LegendLocation, superClass);
    function LegendLocation() {
        return LegendLocation.__super__.constructor.apply(this, arguments);
    }
    return LegendLocation;
}(exports.enum_prop('LegendLocation', enums.LegendLocation));
exports.Location = function (superClass) {
    extend(Location, superClass);
    function Location() {
        return Location.__super__.constructor.apply(this, arguments);
    }
    return Location;
}(exports.enum_prop('Location', enums.Location));
exports.OutputBackend = function (superClass) {
    extend(OutputBackend, superClass);
    function OutputBackend() {
        return OutputBackend.__super__.constructor.apply(this, arguments);
    }
    return OutputBackend;
}(exports.enum_prop('OutputBackend', enums.OutputBackend));
exports.Orientation = function (superClass) {
    extend(Orientation, superClass);
    function Orientation() {
        return Orientation.__super__.constructor.apply(this, arguments);
    }
    return Orientation;
}(exports.enum_prop('Orientation', enums.Orientation));
exports.TextAlign = function (superClass) {
    extend(TextAlign, superClass);
    function TextAlign() {
        return TextAlign.__super__.constructor.apply(this, arguments);
    }
    return TextAlign;
}(exports.enum_prop('TextAlign', enums.TextAlign));
exports.TextBaseline = function (superClass) {
    extend(TextBaseline, superClass);
    function TextBaseline() {
        return TextBaseline.__super__.constructor.apply(this, arguments);
    }
    return TextBaseline;
}(exports.enum_prop('TextBaseline', enums.TextBaseline));
exports.RenderLevel = function (superClass) {
    extend(RenderLevel, superClass);
    function RenderLevel() {
        return RenderLevel.__super__.constructor.apply(this, arguments);
    }
    return RenderLevel;
}(exports.enum_prop('RenderLevel', enums.RenderLevel));
exports.RenderMode = function (superClass) {
    extend(RenderMode, superClass);
    function RenderMode() {
        return RenderMode.__super__.constructor.apply(this, arguments);
    }
    return RenderMode;
}(exports.enum_prop('RenderMode', enums.RenderMode));
exports.SizingMode = function (superClass) {
    extend(SizingMode, superClass);
    function SizingMode() {
        return SizingMode.__super__.constructor.apply(this, arguments);
    }
    return SizingMode;
}(exports.enum_prop('SizingMode', enums.SizingMode));
exports.SpatialUnits = function (superClass) {
    extend(SpatialUnits, superClass);
    function SpatialUnits() {
        return SpatialUnits.__super__.constructor.apply(this, arguments);
    }
    return SpatialUnits;
}(exports.enum_prop('SpatialUnits', enums.SpatialUnits));
exports.Distribution = function (superClass) {
    extend(Distribution, superClass);
    function Distribution() {
        return Distribution.__super__.constructor.apply(this, arguments);
    }
    return Distribution;
}(exports.enum_prop('Distribution', enums.DistributionTypes));
exports.TransformStepMode = function (superClass) {
    extend(TransformStepMode, superClass);
    function TransformStepMode() {
        return TransformStepMode.__super__.constructor.apply(this, arguments);
    }
    return TransformStepMode;
}(exports.enum_prop('TransformStepMode', enums.TransformStepModes));
exports.PaddingUnits = function (superClass) {
    extend(PaddingUnits, superClass);
    function PaddingUnits() {
        return PaddingUnits.__super__.constructor.apply(this, arguments);
    }
    return PaddingUnits;
}(exports.enum_prop('PaddingUnits', enums.PaddingUnits));
exports.StartEnd = function (superClass) {
    extend(StartEnd, superClass);
    function StartEnd() {
        return StartEnd.__super__.constructor.apply(this, arguments);
    }
    return StartEnd;
}(exports.enum_prop('StartEnd', enums.StartEnd));
exports.units_prop = function (name, valid_units, default_units) {
    var UnitsProp;
    return UnitsProp = function (superClass) {
        extend(UnitsProp, superClass);
        function UnitsProp() {
            return UnitsProp.__super__.constructor.apply(this, arguments);
        }
        UnitsProp.prototype.name = name;
        UnitsProp.prototype.init = function () {
            var units;
            if (this.spec.units == null) {
                this.spec.units = default_units;
            }
            this.units = this.spec.units;
            units = this.spec.units;
            if (indexOf.call(valid_units, units) < 0) {
                throw new Error(name + ' units must be one of ' + valid_units + ', given invalid value: ' + units);
            }
        };
        return UnitsProp;
    }(exports.Number);
};
exports.Angle = function (superClass) {
    extend(Angle, superClass);
    function Angle() {
        return Angle.__super__.constructor.apply(this, arguments);
    }
    Angle.prototype.transform = function (values) {
        var x;
        if (this.spec.units === 'deg') {
            values = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = values.length; j < len; j++) {
                    x = values[j];
                    results.push(x * Math.PI / 180);
                }
                return results;
            }();
        }
        values = function () {
            var j, len, results;
            results = [];
            for (j = 0, len = values.length; j < len; j++) {
                x = values[j];
                results.push(-x);
            }
            return results;
        }();
        return Angle.__super__.transform.call(this, values);
    };
    return Angle;
}(exports.units_prop('Angle', enums.AngleUnits, 'rad'));
exports.Distance = function (superClass) {
    extend(Distance, superClass);
    function Distance() {
        return Distance.__super__.constructor.apply(this, arguments);
    }
    return Distance;
}(exports.units_prop('Distance', enums.SpatialUnits, 'data'));
exports.AngleSpec = function (superClass) {
    extend(AngleSpec, superClass);
    function AngleSpec() {
        return AngleSpec.__super__.constructor.apply(this, arguments);
    }
    AngleSpec.prototype.dataspec = true;
    return AngleSpec;
}(exports.Angle);
exports.ColorSpec = function (superClass) {
    extend(ColorSpec, superClass);
    function ColorSpec() {
        return ColorSpec.__super__.constructor.apply(this, arguments);
    }
    ColorSpec.prototype.dataspec = true;
    return ColorSpec;
}(exports.Color);
exports.DirectionSpec = function (superClass) {
    extend(DirectionSpec, superClass);
    function DirectionSpec() {
        return DirectionSpec.__super__.constructor.apply(this, arguments);
    }
    DirectionSpec.prototype.dataspec = true;
    return DirectionSpec;
}(exports.Distance);
exports.DistanceSpec = function (superClass) {
    extend(DistanceSpec, superClass);
    function DistanceSpec() {
        return DistanceSpec.__super__.constructor.apply(this, arguments);
    }
    DistanceSpec.prototype.dataspec = true;
    return DistanceSpec;
}(exports.Distance);
exports.FontSizeSpec = function (superClass) {
    extend(FontSizeSpec, superClass);
    function FontSizeSpec() {
        return FontSizeSpec.__super__.constructor.apply(this, arguments);
    }
    FontSizeSpec.prototype.dataspec = true;
    return FontSizeSpec;
}(exports.String);
exports.NumberSpec = function (superClass) {
    extend(NumberSpec, superClass);
    function NumberSpec() {
        return NumberSpec.__super__.constructor.apply(this, arguments);
    }
    NumberSpec.prototype.dataspec = true;
    return NumberSpec;
}(exports.Number);
exports.StringSpec = function (superClass) {
    extend(StringSpec, superClass);
    function StringSpec() {
        return StringSpec.__super__.constructor.apply(this, arguments);
    }
    StringSpec.prototype.dataspec = true;
    return StringSpec;
}(exports.String);    
},
/* core/property_mixins */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _fill_mixin, _gen_mixin, _line_mixin, _text_mixin;
var p = require(13    /* ./properties */);
var object_1 = require(28    /* ./util/object */);
_gen_mixin = function (mixin, prefix) {
    var name, result, type;
    result = {};
    if (prefix == null) {
        prefix = '';
    }
    for (name in mixin) {
        type = mixin[name];
        result[prefix + name] = type;
    }
    return result;
};
_line_mixin = {
    line_color: [
        p.ColorSpec,
        'black'
    ],
    line_width: [
        p.NumberSpec,
        1
    ],
    line_alpha: [
        p.NumberSpec,
        1
    ],
    line_join: [
        p.LineJoin,
        'miter'
    ],
    line_cap: [
        p.LineCap,
        'butt'
    ],
    line_dash: [
        p.Array,
        []
    ],
    line_dash_offset: [
        p.Number,
        0
    ]
};
exports.line = function (prefix) {
    return _gen_mixin(_line_mixin, prefix);
};
_fill_mixin = {
    fill_color: [
        p.ColorSpec,
        'gray'
    ],
    fill_alpha: [
        p.NumberSpec,
        1
    ]
};
exports.fill = function (prefix) {
    return _gen_mixin(_fill_mixin, prefix);
};
_text_mixin = {
    text_font: [
        p.Font,
        'helvetica'
    ],
    text_font_size: [
        p.FontSizeSpec,
        '12pt'
    ],
    text_font_style: [
        p.FontStyle,
        'normal'
    ],
    text_color: [
        p.ColorSpec,
        '#444444'
    ],
    text_alpha: [
        p.NumberSpec,
        1
    ],
    text_align: [
        p.TextAlign,
        'left'
    ],
    text_baseline: [
        p.TextBaseline,
        'bottom'
    ]
};
exports.text = function (prefix) {
    return _gen_mixin(_text_mixin, prefix);
};
exports.create = function (configs) {
    var config, i, kind, len, prefix, ref, result;
    result = {};
    for (i = 0, len = configs.length; i < len; i++) {
        config = configs[i];
        ref = config.split(':'), kind = ref[0], prefix = ref[1];
        if (this[kind] == null) {
            throw new Error('Unknown property mixin kind \'' + kind + '\'');
        }
        result = object_1.extend(result, this[kind](prefix));
    }
    return result;
};    
},
/* core/selection_manager */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var has_props_1 = require(7    /* ./has_props */);
var selector_1 = require(16    /* ./selector */);
var hittest = require(8    /* ./hittest */);
var p = require(13    /* ./properties */);
exports.SelectionManager = function (superClass) {
    extend(SelectionManager, superClass);
    function SelectionManager() {
        return SelectionManager.__super__.constructor.apply(this, arguments);
    }
    SelectionManager.prototype.type = 'SelectionManager';
    SelectionManager.internal({ source: [p.Any] });
    SelectionManager.prototype.initialize = function (attrs, options) {
        SelectionManager.__super__.initialize.call(this, attrs, options);
        this.selector = new selector_1.Selector();
        return this.inspectors = {};
    };
    SelectionManager.prototype.select = function (renderer_views, geometry, final, append) {
        var did_hit, i, len, r;
        if (append == null) {
            append = false;
        }
        did_hit = false;
        for (i = 0, len = renderer_views.length; i < len; i++) {
            r = renderer_views[i];
            did_hit || (did_hit = r.hit_test(geometry, final, append));
        }
        return did_hit;
    };
    SelectionManager.prototype.inspect = function (renderer_view, geometry) {
        var did_hit;
        did_hit = false;
        did_hit || (did_hit = renderer_view.hit_test(geometry, false, false, 'inspect'));
        return did_hit;
    };
    SelectionManager.prototype.clear = function (rview) {
        this.selector.clear();
        return this.source.selected = hittest.create_hit_test_result();
    };
    SelectionManager.prototype.get_or_create_inspector = function (rmodel) {
        if (this.inspectors[rmodel.id] == null) {
            this.inspectors[rmodel.id] = new selector_1.Selector();
        }
        return this.inspectors[rmodel.id];
    };
    return SelectionManager;
}(has_props_1.HasProps);    
},
/* core/selector */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var has_props_1 = require(7    /* ./has_props */);
var hittest = require(8    /* ./hittest */);
var p = require(13    /* ./properties */);
exports.Selector = function (superClass) {
    extend(Selector, superClass);
    function Selector() {
        return Selector.__super__.constructor.apply(this, arguments);
    }
    Selector.prototype.type = 'Selector';
    Selector.prototype.update = function (indices, final, append, silent) {
        if (silent == null) {
            silent = false;
        }
        this.setv('timestamp', new Date(), { silent: silent });
        this.setv('final', final, { silent: silent });
        if (append) {
            indices.update_through_union(this.indices);
        }
        return this.setv('indices', indices, { silent: silent });
    };
    Selector.prototype.clear = function () {
        this.timestamp = new Date();
        this.final = true;
        return this.indices = hittest.create_hit_test_result();
    };
    Selector.internal({
        indices: [
            p.Any,
            function () {
                return hittest.create_hit_test_result();
            }
        ],
        final: [p.Boolean],
        timestamp: [p.Any]
    });
    return Selector;
}(has_props_1.HasProps);    
},
/* core/settings */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var Settings = function () {
    function Settings() {
        this._dev = false;
    }
    Object.defineProperty(Settings.prototype, 'dev', {
        get: function () {
            return this._dev;
        },
        set: function (dev) {
            this._dev = dev;
        },
        enumerable: true,
        configurable: true
    });
    return Settings;
}();
exports.Settings = Settings;
exports.settings = new Settings();    
},
/* core/signaling */ function(require, module, exports) {
'use strict';
// Based on https://github.com/phosphorjs/phosphor/blob/master/packages/signaling/src/index.ts
Object.defineProperty(exports, '__esModule', { value: true });
var logging_1 = require(12    /* ./logging */);
var callback_1 = require(22    /* ./util/callback */);
var array_1 = require(20    /* ./util/array */);
var Signal = function () {
    function Signal(sender, name) {
        this.sender = sender;
        this.name = name;
    }
    Signal.prototype.connect = function (slot, context) {
        if (context === void 0) {
            context = null;
        }
        if (!receiversForSender.has(this.sender)) {
            receiversForSender.set(this.sender, []);
        }
        var receivers = receiversForSender.get(this.sender);
        if (findConnection(receivers, this, slot, context) != null) {
            return false;
        }
        var receiver = context || slot;
        if (!sendersForReceiver.has(receiver)) {
            sendersForReceiver.set(receiver, []);
        }
        var senders = sendersForReceiver.get(receiver);
        var connection = {
            signal: this,
            slot: slot,
            context: context
        };
        receivers.push(connection);
        senders.push(connection);
        return true;
    };
    Signal.prototype.disconnect = function (slot, context) {
        if (context === void 0) {
            context = null;
        }
        var receivers = receiversForSender.get(this.sender);
        if (receivers == null || receivers.length === 0) {
            return false;
        }
        var connection = findConnection(receivers, this, slot, context);
        if (connection == null) {
            return false;
        }
        var receiver = context || slot;
        var senders = sendersForReceiver.get(receiver);
        connection.signal = null;
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
        return true;
    };
    Signal.prototype.emit = function (args) {
        var receivers = receiversForSender.get(this.sender) || [];
        for (var _i = 0, receivers_1 = receivers; _i < receivers_1.length; _i++) {
            var _a = receivers_1[_i], signal = _a.signal, slot = _a.slot, context = _a.context;
            if (signal === this) {
                slot.call(context, args, this.sender);
            }
        }
    };
    return Signal;
}();
exports.Signal = Signal;
(function (Signal) {
    function disconnectBetween(sender, receiver) {
        var receivers = receiversForSender.get(sender);
        if (receivers == null || receivers.length === 0)
            return;
        var senders = sendersForReceiver.get(receiver);
        if (senders == null || senders.length === 0)
            return;
        for (var _i = 0, senders_1 = senders; _i < senders_1.length; _i++) {
            var connection = senders_1[_i];
            if (connection.signal == null)
                return;
            if (connection.signal.sender === sender)
                connection.signal = null;
        }
        scheduleCleanup(receivers);
        scheduleCleanup(senders);
    }
    Signal.disconnectBetween = disconnectBetween;
    function disconnectSender(sender) {
        var receivers = receiversForSender.get(sender);
        if (receivers == null || receivers.length === 0)
            return;
        for (var _i = 0, receivers_2 = receivers; _i < receivers_2.length; _i++) {
            var connection = receivers_2[_i];
            if (connection.signal == null)
                return;
            var receiver = connection.context || connection.slot;
            connection.signal = null;
            scheduleCleanup(sendersForReceiver.get(receiver));
        }
        scheduleCleanup(receivers);
    }
    Signal.disconnectSender = disconnectSender;
    function disconnectReceiver(receiver) {
        var senders = sendersForReceiver.get(receiver);
        if (senders == null || senders.length === 0)
            return;
        for (var _i = 0, senders_2 = senders; _i < senders_2.length; _i++) {
            var connection = senders_2[_i];
            if (connection.signal == null)
                return;
            var sender = connection.signal.sender;
            connection.signal = null;
            scheduleCleanup(receiversForSender.get(sender));
        }
        scheduleCleanup(senders);
    }
    Signal.disconnectReceiver = disconnectReceiver;
    function disconnectAll(obj) {
        var receivers = receiversForSender.get(obj);
        if (receivers != null && receivers.length !== 0) {
            for (var _i = 0, receivers_3 = receivers; _i < receivers_3.length; _i++) {
                var connection = receivers_3[_i];
                connection.signal = null;
            }
            scheduleCleanup(receivers);
        }
        var senders = sendersForReceiver.get(obj);
        if (senders != null && senders.length !== 0) {
            for (var _a = 0, senders_3 = senders; _a < senders_3.length; _a++) {
                var connection = senders_3[_a];
                connection.signal = null;
            }
            scheduleCleanup(senders);
        }
    }
    Signal.disconnectAll = disconnectAll;
}(Signal = exports.Signal || (exports.Signal = {})));
exports.Signal = Signal;
var Signalable;
(function (Signalable) {
    function connect(signal, slot) {
        return signal.connect(slot, this);
    }
    Signalable.connect = connect;
    function listenTo(event, slot) {
        logging_1.logger.warn('obj.listenTo(\'event\', handler) is deprecated, use obj.connect(signal, slot)');
        var _a = event.split(':'), name = _a[0], attr = _a[1];
        var signal = attr == null ? this[name] : this.properties[attr][name];
        return signal.connect(slot, this);
    }
    Signalable.listenTo = listenTo;
    function trigger(event, args) {
        logging_1.logger.warn('obj.trigger(\'event\', args) is deprecated, use signal.emit(args)');
        var _a = event.split(':'), name = _a[0], attr = _a[1];
        var signal = attr == null ? this[name] : this.properties[attr][name];
        return signal.emit(args);
    }
    Signalable.trigger = trigger;
}(Signalable = exports.Signalable || (exports.Signalable = {})));
var receiversForSender = new WeakMap();
var sendersForReceiver = new WeakMap();
function findConnection(conns, signal, slot, context) {
    return array_1.find(conns, function (conn) {
        return conn.signal === signal && conn.slot === slot && conn.context === context;
    });
}
var dirtySet = new Set();
function scheduleCleanup(connections) {
    if (dirtySet.size === 0) {
        callback_1.defer(cleanupDirtySet);
    }
    dirtySet.add(connections);
}
function cleanupDirtySet() {
    dirtySet.forEach(function (connections) {
        array_1.removeBy(connections, function (connection) {
            return connection.signal == null;
        });
    });
    dirtySet.clear();
}    
},
/* core/ui_events */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var Hammer = require(311    /* hammerjs */);
var signaling_1 = require(18    /* ./signaling */);
var logging_1 = require(12    /* ./logging */);
var dom_1 = require(4    /* ./dom */);
var wheel_1 = require(41    /* ./util/wheel */);
var object_1 = require(28    /* ./util/object */);
var bokeh_events_1 = require(2    /* ./bokeh_events */);
exports.UIEvents = function () {
    function UIEvents(plot_view, toolbar, hit_area, plot) {
        this.plot_view = plot_view;
        this.toolbar = toolbar;
        this.hit_area = hit_area;
        this.plot = plot;
        this.tap = new signaling_1.Signal(this, 'tap');
        this.doubletap = new signaling_1.Signal(this, 'doubletap');
        this.press = new signaling_1.Signal(this, 'press');
        this.pan_start = new signaling_1.Signal(this, 'pan:start');
        this.pan = new signaling_1.Signal(this, 'pan');
        this.pan_end = new signaling_1.Signal(this, 'pan:end');
        this.pinch_start = new signaling_1.Signal(this, 'pinch:start');
        this.pinch = new signaling_1.Signal(this, 'pinch');
        this.pinch_end = new signaling_1.Signal(this, 'pinch:end');
        this.rotate_start = new signaling_1.Signal(this, 'rotate:start');
        this.rotate = new signaling_1.Signal(this, 'rotate');
        this.rotate_end = new signaling_1.Signal(this, 'rotate:end');
        this.move_enter = new signaling_1.Signal(this, 'move:enter');
        this.move = new signaling_1.Signal(this, 'move');
        this.move_exit = new signaling_1.Signal(this, 'move:exit');
        this.scroll = new signaling_1.Signal(this, 'scroll');
        this.keydown = new signaling_1.Signal(this, 'keydown');
        this.keyup = new signaling_1.Signal(this, 'keyup');
        this._configure_hammerjs();
    }
    UIEvents.prototype._configure_hammerjs = function () {
        this.hammer = new Hammer(this.hit_area);
        this.hammer.get('doubletap').recognizeWith('tap');
        this.hammer.get('tap').requireFailure('doubletap');
        this.hammer.get('doubletap').dropRequireFailure('tap');
        this.hammer.on('doubletap', function (_this) {
            return function (e) {
                return _this._doubletap(e);
            };
        }(this));
        this.hammer.on('tap', function (_this) {
            return function (e) {
                return _this._tap(e);
            };
        }(this));
        this.hammer.on('press', function (_this) {
            return function (e) {
                return _this._press(e);
            };
        }(this));
        this.hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
        this.hammer.on('panstart', function (_this) {
            return function (e) {
                return _this._pan_start(e);
            };
        }(this));
        this.hammer.on('pan', function (_this) {
            return function (e) {
                return _this._pan(e);
            };
        }(this));
        this.hammer.on('panend', function (_this) {
            return function (e) {
                return _this._pan_end(e);
            };
        }(this));
        this.hammer.get('pinch').set({ enable: true });
        this.hammer.on('pinchstart', function (_this) {
            return function (e) {
                return _this._pinch_start(e);
            };
        }(this));
        this.hammer.on('pinch', function (_this) {
            return function (e) {
                return _this._pinch(e);
            };
        }(this));
        this.hammer.on('pinchend', function (_this) {
            return function (e) {
                return _this._pinch_end(e);
            };
        }(this));
        this.hammer.get('rotate').set({ enable: true });
        this.hammer.on('rotatestart', function (_this) {
            return function (e) {
                return _this._rotate_start(e);
            };
        }(this));
        this.hammer.on('rotate', function (_this) {
            return function (e) {
                return _this._rotate(e);
            };
        }(this));
        this.hammer.on('rotateend', function (_this) {
            return function (e) {
                return _this._rotate_end(e);
            };
        }(this));
        this.hit_area.addEventListener('mousemove', function (_this) {
            return function (e) {
                return _this._mouse_move(e);
            };
        }(this));
        this.hit_area.addEventListener('mouseenter', function (_this) {
            return function (e) {
                return _this._mouse_enter(e);
            };
        }(this));
        this.hit_area.addEventListener('mouseleave', function (_this) {
            return function (e) {
                return _this._mouse_exit(e);
            };
        }(this));
        this.hit_area.addEventListener('wheel', function (_this) {
            return function (e) {
                return _this._mouse_wheel(e);
            };
        }(this));
        document.addEventListener('keydown', function (_this) {
            return function (e) {
                return _this._key_down(e);
            };
        }(this));
        return document.addEventListener('keyup', function (_this) {
            return function (e) {
                return _this._key_up(e);
            };
        }(this));
    };
    UIEvents.prototype.register_tool = function (tool_view) {
        var et, id, type, v;
        et = tool_view.model.event_type;
        id = tool_view.model.id;
        type = tool_view.model.type;
        if (et == null) {
            logging_1.logger.debug('Button tool: ' + type);
            return;
        }
        v = tool_view;
        switch (et) {
        case 'pan':
            if (v._pan_start != null) {
                v.connect(this.pan_start, function (x) {
                    if (x.id === id) {
                        return v._pan_start(x.e);
                    }
                });
            }
            if (v._pan != null) {
                v.connect(this.pan, function (x) {
                    if (x.id === id) {
                        return v._pan(x.e);
                    }
                });
            }
            if (v._pan_end != null) {
                v.connect(this.pan_end, function (x) {
                    if (x.id === id) {
                        return v._pan_end(x.e);
                    }
                });
            }
            break;
        case 'pinch':
            if (v._pinch_start != null) {
                v.connect(this.pinch_start, function (x) {
                    if (x.id === id) {
                        return v._pinch_start(x.e);
                    }
                });
            }
            if (v._pinch != null) {
                v.connect(this.pinch, function (x) {
                    if (x.id === id) {
                        return v._pinch(x.e);
                    }
                });
            }
            if (v._pinch_end != null) {
                v.connect(this.pinch_end, function (x) {
                    if (x.id === id) {
                        return v._pinch_end(x.e);
                    }
                });
            }
            break;
        case 'rotate':
            if (v._rotate_start != null) {
                v.connect(this.rotate_start, function (x) {
                    if (x.id === id) {
                        return v._rotate_start(x.e);
                    }
                });
            }
            if (v._rotate != null) {
                v.connect(this.rotate, function (x) {
                    if (x.id === id) {
                        return v._rotate(x.e);
                    }
                });
            }
            if (v._rotate_end != null) {
                v.connect(this.rotate_end, function (x) {
                    if (x.id === id) {
                        return v._rotate_end(x.e);
                    }
                });
            }
            break;
        case 'move':
            if (v._move_enter != null) {
                v.connect(this.move_enter, function (x) {
                    if (x.id === id) {
                        return v._move_enter(x.e);
                    }
                });
            }
            if (v._move != null) {
                v.connect(this.move, function (x) {
                    if (x.id === id) {
                        return v._move(x.e);
                    }
                });
            }
            if (v._move_exit != null) {
                v.connect(this.move_exit, function (x) {
                    if (x.id === id) {
                        return v._move_exit(x.e);
                    }
                });
            }
            break;
        case 'tap':
            if (v._tap != null) {
                v.connect(this.tap, function (x) {
                    if (x.id === id) {
                        return v._tap(x.e);
                    }
                });
            }
            break;
        case 'press':
            if (v._press != null) {
                v.connect(this.press, function (x) {
                    if (x.id === id) {
                        return v._press(x.e);
                    }
                });
            }
            break;
        case 'scroll':
            if (v._scroll != null) {
                v.connect(this.scroll, function (x) {
                    if (x.id === id) {
                        return v._scroll(x.e);
                    }
                });
            }
            break;
        default:
            throw new Error('unsupported event_type: ' + ev);
        }
        if (v._doubletap != null) {
            v.connect(this.doubletap, function (x) {
                return v._doubletap(x.e);
            });
        }
        if (v._keydown != null) {
            v.connect(this.keydown, function (x) {
                return v._keydown(x.e);
            });
        }
        if (v._keyup != null) {
            v.connect(this.keyup, function (x) {
                return v._keyup(x.e);
            });
        }
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            if (et === 'pinch') {
                logging_1.logger.debug('Registering scroll on touch screen');
                return v.connect(this.scroll, function (x) {
                    if (x.id === id) {
                        return v._scroll(x.e);
                    }
                });
            }
        }
    };
    UIEvents.prototype._hit_test_renderers = function (sx, sy) {
        var i, ref, ref1, view;
        ref = this.plot_view.get_renderer_views();
        for (i = ref.length - 1; i >= 0; i += -1) {
            view = ref[i];
            if (((ref1 = view.model.level) === 'annotation' || ref1 === 'overlay') && view.bbox != null) {
                if (view.bbox().contains(sx, sy)) {
                    return view;
                }
            }
        }
        return null;
    };
    UIEvents.prototype._hit_test_frame = function (sx, sy) {
        var canvas, vx, vy;
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(sx);
        vy = canvas.sy_to_vy(sy);
        return this.plot_view.frame.contains(vx, vy);
    };
    UIEvents.prototype._trigger = function (signal, e) {
        var active_gesture, active_inspectors, base, base_type, cursor, event_type, i, inspector, len, results, view;
        event_type = signal.name;
        base_type = event_type.split(':')[0];
        view = this._hit_test_renderers(e.bokeh.sx, e.bokeh.sy);
        switch (base_type) {
        case 'move':
            active_inspectors = this.toolbar.inspectors.filter(function (t) {
                return t.active;
            });
            cursor = 'default';
            if (view != null) {
                if (view.model.cursor != null) {
                    cursor = view.model.cursor();
                }
                if (!object_1.isEmpty(active_inspectors)) {
                    signal = this.move_exit;
                    event_type = signal.name;
                }
            } else if (this._hit_test_frame(e.bokeh.sx, e.bokeh.sy)) {
                if (!object_1.isEmpty(active_inspectors)) {
                    cursor = 'crosshair';
                }
            }
            this.plot_view.set_cursor(cursor);
            results = [];
            for (i = 0, len = active_inspectors.length; i < len; i++) {
                inspector = active_inspectors[i];
                results.push(this.trigger(signal, e, inspector.id));
            }
            return results;
            break;
        case 'tap':
            if (view != null) {
                if (typeof view.on_hit === 'function') {
                    view.on_hit(e.bokeh.sx, e.bokeh.sy);
                }
            }
            active_gesture = this.toolbar.gestures[base_type].active;
            if (active_gesture != null) {
                return this.trigger(signal, e, active_gesture.id);
            }
            break;
        case 'scroll':
            base = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'pinch' : 'scroll';
            active_gesture = this.toolbar.gestures[base].active;
            if (active_gesture != null) {
                e.preventDefault();
                e.stopPropagation();
                return this.trigger(signal, e, active_gesture.id);
            }
            break;
        default:
            active_gesture = this.toolbar.gestures[base_type].active;
            if (active_gesture != null) {
                return this.trigger(signal, e, active_gesture.id);
            }
        }
    };
    UIEvents.prototype.trigger = function (signal, event, id) {
        if (id == null) {
            id = null;
        }
        return signal.emit({
            id: id,
            e: event
        });
    };
    UIEvents.prototype._bokify_hammer = function (e, extras) {
        var event_cls, left, ref, top, x, y;
        if (extras == null) {
            extras = {};
        }
        if (e.pointerType === 'mouse') {
            x = e.srcEvent.pageX;
            y = e.srcEvent.pageY;
        } else {
            x = e.pointers[0].pageX;
            y = e.pointers[0].pageY;
        }
        ref = dom_1.offset(e.target), left = ref.left, top = ref.top;
        e.bokeh = {
            sx: x - left,
            sy: y - top
        };
        e.bokeh = object_1.extend(e.bokeh, extras);
        event_cls = bokeh_events_1.BokehEvent.event_class(e);
        if (event_cls != null) {
            return this.plot.trigger_event(event_cls.from_event(e));
        } else {
            return logging_1.logger.debug('Unhandled event of type ' + e.type);
        }
    };
    UIEvents.prototype._bokify_point_event = function (e, extras) {
        var event_cls, left, ref, top;
        if (extras == null) {
            extras = {};
        }
        ref = dom_1.offset(e.currentTarget), left = ref.left, top = ref.top;
        e.bokeh = {
            sx: e.pageX - left,
            sy: e.pageY - top
        };
        e.bokeh = object_1.extend(e.bokeh, extras);
        event_cls = bokeh_events_1.BokehEvent.event_class(e);
        if (event_cls != null) {
            return this.plot.trigger_event(event_cls.from_event(e));
        } else {
            return logging_1.logger.debug('Unhandled event of type ' + e.type);
        }
    };
    UIEvents.prototype._tap = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.tap, e);
    };
    UIEvents.prototype._doubletap = function (e) {
        this._bokify_hammer(e);
        return this.trigger(this.doubletap, e);
    };
    UIEvents.prototype._press = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.press, e);
    };
    UIEvents.prototype._pan_start = function (e) {
        this._bokify_hammer(e);
        e.bokeh.sx -= e.deltaX;
        e.bokeh.sy -= e.deltaY;
        return this._trigger(this.pan_start, e);
    };
    UIEvents.prototype._pan = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.pan, e);
    };
    UIEvents.prototype._pan_end = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.pan_end, e);
    };
    UIEvents.prototype._pinch_start = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.pinch_start, e);
    };
    UIEvents.prototype._pinch = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.pinch, e);
    };
    UIEvents.prototype._pinch_end = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.pinch_end, e);
    };
    UIEvents.prototype._rotate_start = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.rotate_start, e);
    };
    UIEvents.prototype._rotate = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.rotate, e);
    };
    UIEvents.prototype._rotate_end = function (e) {
        this._bokify_hammer(e);
        return this._trigger(this.rotate_end, e);
    };
    UIEvents.prototype._mouse_enter = function (e) {
        this._bokify_point_event(e);
        return this._trigger(this.move_enter, e);
    };
    UIEvents.prototype._mouse_move = function (e) {
        this._bokify_point_event(e);
        return this._trigger(this.move, e);
    };
    UIEvents.prototype._mouse_exit = function (e) {
        this._bokify_point_event(e);
        return this._trigger(this.move_exit, e);
    };
    UIEvents.prototype._mouse_wheel = function (e) {
        this._bokify_point_event(e, { delta: wheel_1.getDeltaY(e) });
        return this._trigger(this.scroll, e);
    };
    UIEvents.prototype._key_down = function (e) {
        return this.trigger(this.keydown, e);
    };
    UIEvents.prototype._key_up = function (e) {
        return this.trigger(this.keyup, e);
    };
    return UIEvents;
}();    
},
/* core/util/array */ function(require, module, exports) {
'use strict';
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
Object.defineProperty(exports, '__esModule', { value: true });
var math_1 = require(27    /* ./math */);
var slice = Array.prototype.slice;
function last(array) {
    return array[array.length - 1];
}
exports.last = last;
function copy(array) {
    return slice.call(array);
}
exports.copy = copy;
function concat(arrays) {
    return (_a = []).concat.apply(_a, arrays);
    var _a;
}
exports.concat = concat;
function contains(array, value) {
    return array.indexOf(value) !== -1;
}
exports.contains = contains;
function nth(array, index) {
    return array[index >= 0 ? index : array.length + index];
}
exports.nth = nth;
function zip(As, Bs) {
    var n = Math.min(As.length, Bs.length);
    var ABs = new Array(n);
    for (var i = 0; i < n; i++) {
        ABs[i] = [
            As[i],
            Bs[i]
        ];
    }
    return ABs;
}
exports.zip = zip;
function unzip(ABs) {
    var n = ABs.length;
    var As = new Array(n);
    var Bs = new Array(n);
    for (var i = 0; i < n; i++) {
        _a = ABs[i], As[i] = _a[0], Bs[i] = _a[1];
    }
    return [
        As,
        Bs
    ];
    var _a;
}
exports.unzip = unzip;
function range(start, stop, step) {
    if (step === void 0) {
        step = 1;
    }
    if (stop == null) {
        stop = start;
        start = 0;
    }
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for (var i = 0; i < length; i++, start += step) {
        range[i] = start;
    }
    return range;
}
exports.range = range;
function linspace(start, stop, num) {
    if (num === void 0) {
        num = 100;
    }
    var step = (stop - start) / (num - 1);
    var array = new Array(num);
    for (var i = 0; i < num; i++) {
        array[i] = start + step * i;
    }
    return array;
}
exports.linspace = linspace;
function transpose(array) {
    var rows = array.length;
    var cols = array[0].length;
    var transposed = [];
    for (var j = 0; j < cols; j++) {
        transposed[j] = [];
        for (var i = 0; i < rows; i++) {
            transposed[j][i] = array[i][j];
        }
    }
    return transposed;
}
exports.transpose = transpose;
function sum(array) {
    return array.reduce(function (a, b) {
        return a + b;
    }, 0);
}
exports.sum = sum;
function cumsum(array) {
    var result = [];
    array.reduce(function (a, b, i) {
        return result[i] = a + b;
    }, 0);
    return result;
}
exports.cumsum = cumsum;
function min(array) {
    var value;
    var result = Infinity;
    for (var i = 0, length_1 = array.length; i < length_1; i++) {
        value = array[i];
        if (value < result) {
            result = value;
        }
    }
    return result;
}
exports.min = min;
function minBy(array, key) {
    if (array.length == 0)
        throw new Error('minBy() called with an empty array');
    var result = array[0];
    var resultComputed = key(result);
    for (var i = 1, length_2 = array.length; i < length_2; i++) {
        var value = array[i];
        var computed = key(value);
        if (computed < resultComputed) {
            result = value;
            resultComputed = computed;
        }
    }
    return result;
}
exports.minBy = minBy;
function max(array) {
    var value;
    var result = -Infinity;
    for (var i = 0, length_3 = array.length; i < length_3; i++) {
        value = array[i];
        if (value > result) {
            result = value;
        }
    }
    return result;
}
exports.max = max;
function maxBy(array, key) {
    if (array.length == 0)
        throw new Error('maxBy() called with an empty array');
    var result = array[0];
    var resultComputed = key(result);
    for (var i = 1, length_4 = array.length; i < length_4; i++) {
        var value = array[i];
        var computed = key(value);
        if (computed > resultComputed) {
            result = value;
            resultComputed = computed;
        }
    }
    return result;
}
exports.maxBy = maxBy;
function argmin(array) {
    return minBy(range(array.length), function (i) {
        return array[i];
    });
}
exports.argmin = argmin;
function argmax(array) {
    return maxBy(range(array.length), function (i) {
        return array[i];
    });
}
exports.argmax = argmax;
function all(array, predicate) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        if (!predicate(item))
            return false;
    }
    return true;
}
exports.all = all;
function any(array, predicate) {
    for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
        var item = array_2[_i];
        if (predicate(item))
            return true;
    }
    return false;
}
exports.any = any;
function findIndexFactory(dir) {
    return function (array, predicate) {
        var length = array.length;
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index]))
                return index;
        }
        return -1;
    };
}
exports.findIndex = findIndexFactory(1);
exports.findLastIndex = findIndexFactory(-1);
function find(array, predicate) {
    var index = exports.findIndex(array, predicate);
    return index == -1 ? undefined : array[index];
}
exports.find = find;
function findLast(array, predicate) {
    var index = exports.findLastIndex(array, predicate);
    return index == -1 ? undefined : array[index];
}
exports.findLast = findLast;
function sortedIndex(array, value) {
    var low = 0;
    var high = array.length;
    while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (array[mid] < value)
            low = mid + 1;
        else
            high = mid;
    }
    return low;
}
exports.sortedIndex = sortedIndex;
function sortBy(array, key) {
    var tmp = array.map(function (value, index) {
        return {
            value: value,
            index: index,
            key: key(value)
        };
    });
    tmp.sort(function (left, right) {
        var a = left.key;
        var b = right.key;
        if (a !== b) {
            if (a > b || a === undefined)
                return 1;
            if (a < b || b === undefined)
                return -1;
        }
        return left.index - right.index;
    });
    return tmp.map(function (item) {
        return item.value;
    });
}
exports.sortBy = sortBy;
function uniq(array) {
    var result = [];
    for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {
        var value = array_3[_i];
        if (!contains(result, value)) {
            result.push(value);
        }
    }
    return result;
}
exports.uniq = uniq;
function uniqBy(array, key) {
    var result = [];
    var seen = [];
    for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {
        var value = array_4[_i];
        var computed = key(value);
        if (!contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
exports.uniqBy = uniqBy;
function union() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    return uniq(concat(arrays));
}
exports.union = union;
function intersection(array) {
    var arrays = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arrays[_i - 1] = arguments[_i];
    }
    var result = [];
    top:
        for (var _a = 0, array_5 = array; _a < array_5.length; _a++) {
            var item = array_5[_a];
            if (contains(result, item))
                continue;
            for (var _b = 0, arrays_1 = arrays; _b < arrays_1.length; _b++) {
                var other = arrays_1[_b];
                if (!contains(other, item))
                    continue top;
            }
            result.push(item);
        }
    return result;
}
exports.intersection = intersection;
function difference(array) {
    var arrays = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arrays[_i - 1] = arguments[_i];
    }
    var rest = concat(arrays);
    return array.filter(function (value) {
        return !contains(rest, value);
    });
}
exports.difference = difference;
function removeBy(array, key) {
    for (var i = 0; i < array.length;) {
        if (key(array[i]))
            array.splice(i, 1);
        else
            i++;
    }
}
exports.removeBy = removeBy;
// Shuffle a collection, using the modern version of the
// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
function shuffle(array) {
    var length = array.length;
    var shuffled = new Array(length);
    for (var i = 0; i < length; i++) {
        var rand = math_1.randomIn(0, i);
        if (rand !== i)
            shuffled[i] = shuffled[rand];
        shuffled[rand] = array[i];
    }
    return shuffled;
}
exports.shuffle = shuffle;
function pairwise(array, fn) {
    var n = array.length;
    var result = new Array(n - 1);
    for (var i = 0; i < n - 1; i++) {
        result[i] = fn(array[i], array[i + 1]);
    }
    return result;
}
exports.pairwise = pairwise;    
},
/* core/util/bbox */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function empty() {
    return {
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}
exports.empty = empty;
function positive_x() {
    return {
        minX: Number.MIN_VALUE,
        minY: -Infinity,
        maxX: Infinity,
        maxY: Infinity
    };
}
exports.positive_x = positive_x;
function positive_y() {
    return {
        minX: -Infinity,
        minY: Number.MIN_VALUE,
        maxX: Infinity,
        maxY: Infinity
    };
}
exports.positive_y = positive_y;
function union(a, b) {
    return {
        minX: Math.min(a.minX, b.minX),
        maxX: Math.max(a.maxX, b.maxX),
        minY: Math.min(a.minY, b.minY),
        maxY: Math.max(a.maxY, b.maxY)
    };
}
exports.union = union;
var BBox = function () {
    function BBox(bbox) {
        if (bbox == null) {
            this.x0 = Infinity;
            this.y0 = -Infinity;
            this.x1 = Infinity;
            this.y1 = -Infinity;
        } else {
            this.x0 = bbox.x0;
            this.y0 = bbox.y0;
            this.x1 = bbox.x1;
            this.y1 = bbox.y1;
        }
    }
    Object.defineProperty(BBox.prototype, 'minX', {
        get: function () {
            return this.x0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'minY', {
        get: function () {
            return this.y0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'maxX', {
        get: function () {
            return this.x1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'maxY', {
        get: function () {
            return this.y1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'pt0', {
        get: function () {
            return [
                this.x0,
                this.y0
            ];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'pt1', {
        get: function () {
            return [
                this.x1,
                this.y1
            ];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'x', {
        get: function () {
            return this.x0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'y', {
        get: function () {
            return this.x1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'width', {
        get: function () {
            return this.x1 - this.x0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, 'height', {
        get: function () {
            return this.y1 - this.y0;
        },
        enumerable: true,
        configurable: true
    });
    BBox.prototype.contains = function (x, y) {
        return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;
    };
    BBox.prototype.union = function (that) {
        return new BBox({
            x0: Math.min(this.x0, that.x0),
            y0: Math.min(this.y0, that.y0),
            x1: Math.max(this.x1, that.x1),
            y1: Math.max(this.y1, that.y1)
        });
    };
    return BBox;
}();
exports.BBox = BBox;    
},
/* core/util/callback */ function(require, module, exports) {
'use strict';
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
Object.defineProperty(exports, '__esModule', { value: true });
function delay(func, wait) {
    return setTimeout(func, wait);
}
exports.delay = delay;
var _defer = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : setImmediate;
function defer(func) {
    return _defer(func);
}
exports.defer = defer;
function throttle(func, wait, options) {
    if (options === void 0) {
        options = {};
    }
    var context, args, result;
    var timeout = null;
    var previous = 0;
    var later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    return function () {
        var now = Date.now();
        if (!previous && options.leading === false)
            previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
exports.throttle = throttle;
function once(func) {
    var done = false;
    var memo;
    return function () {
        if (!done) {
            done = true;
            memo = func();
        }
        return memo;
    };
}
exports.once = once;    
},
/* core/util/canvas */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var fixup_ellipse, fixup_image_smoothing, fixup_line_dash, fixup_line_dash_offset, fixup_measure_text;
fixup_line_dash = function (ctx) {
    if (!ctx.setLineDash) {
        ctx.setLineDash = function (dash) {
            ctx.mozDash = dash;
            return ctx.webkitLineDash = dash;
        };
    }
    if (!ctx.getLineDash) {
        return ctx.getLineDash = function () {
            return ctx.mozDash;
        };
    }
};
fixup_line_dash_offset = function (ctx) {
    ctx.setLineDashOffset = function (dash_offset) {
        ctx.lineDashOffset = dash_offset;
        ctx.mozDashOffset = dash_offset;
        return ctx.webkitLineDashOffset = dash_offset;
    };
    return ctx.getLineDashOffset = function () {
        return ctx.mozDashOffset;
    };
};
fixup_image_smoothing = function (ctx) {
    ctx.setImageSmoothingEnabled = function (value) {
        ctx.imageSmoothingEnabled = value;
        ctx.mozImageSmoothingEnabled = value;
        ctx.oImageSmoothingEnabled = value;
        return ctx.webkitImageSmoothingEnabled = value;
    };
    return ctx.getImageSmoothingEnabled = function () {
        var ref;
        return (ref = ctx.imageSmoothingEnabled) != null ? ref : true;
    };
};
fixup_measure_text = function (ctx) {
    if (ctx.measureText && ctx.html5MeasureText == null) {
        ctx.html5MeasureText = ctx.measureText;
        return ctx.measureText = function (text) {
            var textMetrics;
            textMetrics = ctx.html5MeasureText(text);
            textMetrics.ascent = ctx.html5MeasureText('m').width * 1.6;
            return textMetrics;
        };
    }
};
fixup_ellipse = function (ctx) {
    var ellipse_bezier;
    ellipse_bezier = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        var c, rx, ry;
        if (anticlockwise == null) {
            anticlockwise = false;
        }
        c = 0.551784;
        ctx.translate(x, y);
        ctx.rotate(rotation);
        rx = radiusX;
        ry = radiusY;
        if (anticlockwise) {
            rx = -radiusX;
            ry = -radiusY;
        }
        ctx.moveTo(-rx, 0);
        ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);
        ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);
        ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);
        ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);
        ctx.rotate(-rotation);
        ctx.translate(-x, -y);
    };
    if (!ctx.ellipse) {
        return ctx.ellipse = ellipse_bezier;
    }
};
exports.fixup_ctx = function (ctx) {
    fixup_line_dash(ctx);
    fixup_line_dash_offset(ctx);
    fixup_image_smoothing(ctx);
    fixup_measure_text(ctx);
    return fixup_ellipse(ctx);
};
exports.get_scale_ratio = function (ctx, hidpi, backend) {
    var backingStoreRatio, devicePixelRatio;
    if (backend === 'svg') {
        return 1;
    } else if (hidpi) {
        devicePixelRatio = window.devicePixelRatio || 1;
        backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
        return devicePixelRatio / backingStoreRatio;
    } else {
        return 1;
    }
};    
},
/* core/util/color */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _component2hex, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var svg_colors = require(36    /* ./svg_colors */);
_component2hex = function (v) {
    var h;
    h = Number(v).toString(16);
    return h = h.length === 1 ? '0' + h : h;
};
exports.color2hex = function (color) {
    var hex, hex_string, rgb, v;
    color = color + '';
    if (color.indexOf('#') === 0) {
        return color;
    } else if (svg_colors[color] != null) {
        return svg_colors[color];
    } else if (color.indexOf('rgb') === 0) {
        rgb = color.replace(/^rgba?\(|\s+|\)$/g, '').split(',');
        hex = function () {
            var j, len, ref, results;
            ref = rgb.slice(0, 3);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                v = ref[j];
                results.push(_component2hex(v));
            }
            return results;
        }().join('');
        if (rgb.length === 4) {
            hex = hex + _component2hex(Math.floor(parseFloat(rgb.slice(3)) * 255));
        }
        hex_string = '#' + hex.slice(0, 8);
        return hex_string;
    } else {
        return color;
    }
};
exports.color2rgba = function (color, alpha) {
    var hex, i, rgba;
    if (alpha == null) {
        alpha = 1;
    }
    if (!color) {
        return [
            0,
            0,
            0,
            0
        ];
    }
    hex = exports.color2hex(color);
    hex = hex.replace(/ |#/g, '');
    if (hex.length <= 4) {
        hex = hex.replace(/(.)/g, '$1$1');
    }
    hex = hex.match(/../g);
    rgba = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = hex.length; j < len; j++) {
            i = hex[j];
            results.push(parseInt(i, 16) / 255);
        }
        return results;
    }();
    while (rgba.length < 3) {
        rgba.push(0);
    }
    if (rgba.length < 4) {
        rgba.push(alpha);
    }
    return rgba.slice(0, 4);
};
exports.valid_rgb = function (value) {
    var contents, params, ref, rgb;
    switch (value.substring(0, 4)) {
    case 'rgba':
        params = {
            start: 'rgba(',
            len: 4,
            alpha: true
        };
        break;
    case 'rgb(':
        params = {
            start: 'rgb(',
            len: 3,
            alpha: false
        };
        break;
    default:
        return false;
    }
    if (new RegExp('.*?(\\.).*(,)').test(value)) {
        throw new Error('color expects integers for rgb in rgb/rgba tuple, received ' + value);
    }
    contents = value.replace(params.start, '').replace(')', '').split(',').map(parseFloat);
    if (contents.length !== params.len) {
        throw new Error('color expects rgba ' + expect_len + '-tuple, received ' + value);
    }
    if (params.alpha && !(0 <= (ref = contents[3]) && ref <= 1)) {
        throw new Error('color expects rgba 4-tuple to have alpha value between 0 and 1');
    }
    if (indexOf.call(function () {
            var j, len, ref1, results;
            ref1 = contents.slice(0, 3);
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
                rgb = ref1[j];
                results.push(0 <= rgb && rgb <= 255);
            }
            return results;
        }(), false) >= 0) {
        throw new Error('color expects rgb to have value between 0 and 255');
    }
    return true;
};    
},
/* core/util/data_structures */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var array_1 = require(20    /* ./array */);
var eq_1 = require(26    /* ./eq */);
var types_1 = require(40    /* ./types */);
var MultiDict = function () {
    function MultiDict() {
        this._dict = {};
    }
    MultiDict.prototype._existing = function (key) {
        if (key in this._dict)
            return this._dict[key];
        else
            return null;
    };
    MultiDict.prototype.add_value = function (key, value) {
        /*
        if value == null
          throw new Error("Can't put null in this dict")
        if isArray(value)
          throw new Error("Can't put arrays in this dict")
        */
        var existing = this._existing(key);
        if (existing == null) {
            this._dict[key] = value;
        } else if (types_1.isArray(existing)) {
            existing.push(value);
        } else {
            this._dict[key] = [
                existing,
                value
            ];
        }
    };
    MultiDict.prototype.remove_value = function (key, value) {
        var existing = this._existing(key);
        if (types_1.isArray(existing)) {
            var new_array = array_1.difference(existing, [value]);
            if (new_array.length > 0)
                this._dict[key] = new_array;
            else
                delete this._dict[key];
        } else if (eq_1.isEqual(existing, value)) {
            delete this._dict[key];
        }
    };
    MultiDict.prototype.get_one = function (key, duplicate_error) {
        var existing = this._existing(key);
        if (types_1.isArray(existing)) {
            if (existing.length === 1)
                return existing[0];
            else
                throw new Error(duplicate_error);
        } else
            return existing;
    };
    return MultiDict;
}();
exports.MultiDict = MultiDict;
var Set = function () {
    function Set(obj) {
        if (obj == null) {
            this.values = [];
        } else if (obj instanceof Set) {
            this.values = array_1.copy(obj.values);
        } else {
            this.values = this._compact(obj);
        }
    }
    Set.prototype._compact = function (array) {
        var newArray = [];
        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
            var item = array_2[_i];
            if (newArray.indexOf(item) === -1) {
                newArray.push(item);
            }
        }
        return newArray;
    };
    Set.prototype.push = function (item) {
        if (this.missing(item))
            this.values.push(item);
    };
    Set.prototype.remove = function (item) {
        var i = this.values.indexOf(item);
        this.values = this.values.slice(0, i).concat(this.values.slice(i + 1));
    };
    Set.prototype.length = function () {
        return this.values.length;
    };
    Set.prototype.includes = function (item) {
        return this.values.indexOf(item) != -1;
    };
    Set.prototype.missing = function (item) {
        return !this.includes(item);
    };
    Set.prototype.slice = function (from, to) {
        return this.values.slice(from, to);
    };
    Set.prototype.join = function (str) {
        return this.values.join(str);
    };
    Set.prototype.toString = function () {
        return this.join(', ');
    };
    Set.prototype.union = function (set) {
        set = new Set(set);
        return new Set(this.values.concat(set.values));
    };
    Set.prototype.intersect = function (set) {
        set = new Set(set);
        var newSet = new Set();
        for (var _i = 0, _a = set.values; _i < _a.length; _i++) {
            var item = _a[_i];
            if (this.includes(item) && set.includes(item))
                newSet.push(item);
        }
        return newSet;
    };
    Set.prototype.diff = function (set) {
        set = new Set(set);
        var newSet = new Set();
        for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
            var item = _a[_i];
            if (set.missing(item))
                newSet.push(item);
        }
        return newSet;
    };
    return Set;
}();
exports.Set = Set;    
},
/* core/util/eq */ function(require, module, exports) {
'use strict';
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
Object.defineProperty(exports, '__esModule', { value: true });
var types_1 = require(40    /* ./types */);
var toString = Object.prototype.toString;
// Internal recursive comparison function for `isEqual`.
function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
        return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null)
        return a === b;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b))
        return false;
    switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case '[object RegExp]':
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
    case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a)
            return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }
    var areArrays = className === '[object Array]';
    if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object')
            return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(types_1.isFunction(aCtor) && aCtor instanceof aCtor && types_1.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
            return false;
        }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a)
            return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length)
            return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], aStack, bStack))
                return false;
        }
    } else {
        // Deep compare objects.
        var keys = Object.keys(a);
        var key = void 0;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (Object.keys(b).length !== length)
            return false;
        while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))
                return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
    return eq(a, b);
}
exports.isEqual = isEqual;    
},
/* core/util/math */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function angle_norm(angle) {
    while (angle < 0) {
        angle += 2 * Math.PI;
    }
    while (angle > 2 * Math.PI) {
        angle -= 2 * Math.PI;
    }
    return angle;
}
exports.angle_norm = angle_norm;
function angle_dist(lhs, rhs) {
    return Math.abs(angle_norm(lhs - rhs));
}
exports.angle_dist = angle_dist;
function angle_between(mid, lhs, rhs, direction) {
    var norm_mid = angle_norm(mid);
    var d = angle_dist(lhs, rhs);
    var cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;
    if (direction == 'anticlock')
        return cond;
    else
        return !cond;
}
exports.angle_between = angle_between;
function random() {
    return Math.random();
}
exports.random = random;
function randomIn(min, max) {
    if (max == null) {
        max = min;
        min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
}
exports.randomIn = randomIn;
function atan2(start, end) {
    /*
     * Calculate the angle between a line containing start and end points (composed
     * of [x, y] arrays) and the positive x-axis.
     */
    return Math.atan2(end[1] - start[1], end[0] - start[0]);
}
exports.atan2 = atan2;
// http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)
function rnorm(mu, sigma) {
    // Generate a random normal with a mean of 0 and a sigma of 1
    var r1;
    var r2;
    while (true) {
        r1 = random();
        r2 = random();
        r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));
        if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)
            break;
    }
    var rn = r2 / r1;
    // Transform the standard normal to meet the characteristics that we want (mu, sigma)
    rn = mu + sigma * rn;
    return rn;
}
exports.rnorm = rnorm;
function clamp(val, min, max) {
    if (val > max)
        return max;
    if (val < min)
        return min;
    return val;
}
exports.clamp = clamp;    
},
/* core/util/object */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var array_1 = require(20    /* ./array */);
exports.keys = Object.keys;
function values(object) {
    var keys = Object.keys(object);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
        values[i] = object[keys[i]];
    }
    return values;
}
exports.values = values;
function extend(dest) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
        var source = sources_1[_a];
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                dest[key] = source[key];
            }
        }
    }
    return dest;
}
exports.extend = extend;
function clone(obj) {
    return extend({}, obj);
}
exports.clone = clone;
function merge(obj1, obj2) {
    /*
     * Returns an object with the array values for obj1 and obj2 unioned by key.
     */
    var result = Object.create(Object.prototype);
    var keys = array_1.concat([
        Object.keys(obj1),
        Object.keys(obj2)
    ]);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var arr1 = obj1.hasOwnProperty(key) ? obj1[key] : [];
        var arr2 = obj2.hasOwnProperty(key) ? obj2[key] : [];
        result[key] = array_1.union(arr1, arr2);
    }
    return result;
}
exports.merge = merge;
function size(obj) {
    return Object.keys(obj).length;
}
exports.size = size;
function isEmpty(obj) {
    return size(obj) === 0;
}
exports.isEmpty = isEmpty;    
},
/* core/util/proj4 */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var proj4 = require(338    /* proj4/lib/core */);
exports.proj4 = proj4;
var Proj = require(326    /* proj4/lib/Proj */);
var toPoint = require(332    /* proj4/lib/common/toPoint */);
var defs = require(342    /* proj4/lib/defs */);
var transform = require(351    /* proj4/lib/transform */);
proj4.defaultDatum = 'WGS84';
proj4.WGS84 = new Proj('WGS84');
proj4.Proj = Proj;
proj4.toPoint = toPoint;
proj4.defs = defs;
proj4.transform = transform;
exports.mercator = defs('GOOGLE');
exports.wgs84 = defs('WGS84');    
},
/* core/util/projections */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var proj4_1 = require(29    /* ./proj4 */);
function project_xy(x, y) {
    var n = Math.min(x.length, y.length);
    var merc_x_s = new Array(n);
    var merc_y_s = new Array(n);
    for (var i = 0; i < n; i++) {
        var _a = proj4_1.proj4(proj4_1.mercator, [
                x[i],
                y[i]
            ]), merc_x = _a[0], merc_y = _a[1];
        merc_x_s[i] = merc_x;
        merc_y_s[i] = merc_y;
    }
    return [
        merc_x_s,
        merc_y_s
    ];
}
exports.project_xy = project_xy;
function project_xsys(xs, ys) {
    var n = Math.min(xs.length, ys.length);
    var merc_xs_s = new Array(n);
    var merc_ys_s = new Array(n);
    for (var i = 0; i < n; i++) {
        var _a = project_xy(xs[i], ys[i]), merc_x_s = _a[0], merc_y_s = _a[1];
        merc_xs_s[i] = merc_x_s;
        merc_ys_s[i] = merc_y_s;
    }
    return [
        merc_xs_s,
        merc_ys_s
    ];
}
exports.project_xsys = project_xsys;    
},
/* core/util/refs */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var has_props_1 = require(7    /* ../has_props */);
var types_1 = require(40    /* ./types */);
// Create a Bokeh reference from a HasProps subclass
//
// @param obj [HasProps] the object to create a reference for
// @return [Object] a Bokeh reference for `obj`
// @throw Error if `obj` is not a HasProps
//
function create_ref(obj) {
    if (!(obj instanceof has_props_1.HasProps)) {
        throw new Error('can only create refs for HasProps subclasses');
    }
    var ref = {
        type: obj.type,
        id: obj.id
    };
    if (obj._subtype != null) {
        ref.subtype = obj._subtype;
    }
    return ref;
}
exports.create_ref = create_ref;
// Determine whether an object has the proper format of a Bokeh reference
//
// @param arg [Object] the object to test
// @return [bool] whether the object is a refererence
//
// @note this function does not check that the id and types are valid,
//   only that the format is correct (all required keys are present)
//
function is_ref(arg) {
    if (types_1.isObject(arg)) {
        var keys = Object.keys(arg).sort();
        if (keys.length == 2)
            return keys[0] == 'id' && keys[1] == 'type';
        if (keys.length == 3)
            return keys[0] == 'id' && keys[1] == 'subtype' && keys[2] == 'type';
    }
    return false;
}
exports.is_ref = is_ref;    
},
/* core/util/selection */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.get_indices = function (data_source) {
    var selected;
    selected = data_source.selected;
    if (selected['0d'].glyph) {
        return selected['0d'].indices;
    } else if (selected['1d'].indices.length > 0) {
        return selected['1d'].indices;
    } else if (selected['2d'].indices.length > 0) {
        return selected['2d'].indices;
    } else {
        return [];
    }
};    
},
/* core/util/serialization */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ARRAY_TYPES, DTYPES, _arrayBufferToBase64, _base64ToArrayBuffer, k, v;
var types_1 = require(40    /* ./types */);
ARRAY_TYPES = {
    float32: Float32Array,
    float64: Float64Array,
    uint8: Uint8Array,
    int8: Int8Array,
    uint16: Uint16Array,
    int16: Int16Array,
    uint32: Uint32Array,
    int32: Int32Array
};
DTYPES = {};
for (k in ARRAY_TYPES) {
    v = ARRAY_TYPES[k];
    DTYPES[v.name] = k;
}
_arrayBufferToBase64 = function (buffer) {
    var b, binary, bytes;
    bytes = new Uint8Array(buffer);
    binary = function () {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = bytes.length; j < len1; j++) {
            b = bytes[j];
            results.push(String.fromCharCode(b));
        }
        return results;
    }();
    return btoa(binary.join(''));
};
_base64ToArrayBuffer = function (base64) {
    var binary_string, bytes, i, j, len, ref;
    binary_string = atob(base64);
    len = binary_string.length;
    bytes = new Uint8Array(len);
    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
};
exports.decode_base64 = function (input) {
    var array, bytes, dtype, shape;
    bytes = _base64ToArrayBuffer(input['__ndarray__']);
    dtype = input['dtype'];
    if (dtype in ARRAY_TYPES) {
        array = new ARRAY_TYPES[dtype](bytes);
    }
    shape = input['shape'];
    return [
        array,
        shape
    ];
};
exports.encode_base64 = function (array, shape) {
    var b64, data, dtype;
    b64 = _arrayBufferToBase64(array.buffer);
    dtype = DTYPES[array.constructor.name];
    data = {
        __ndarray__: b64,
        shape: shape,
        dtype: dtype
    };
    return data;
};
exports.decode_column_data = function (data) {
    var arr, arrays, data_shapes, j, len1, new_data, ref, ref1, shape, shapes;
    new_data = {};
    data_shapes = {};
    for (k in data) {
        v = data[k];
        if (types_1.isArray(v)) {
            arrays = [];
            shapes = [];
            for (j = 0, len1 = v.length; j < len1; j++) {
                arr = v[j];
                if (types_1.isObject(arr) && '__ndarray__' in arr) {
                    ref = exports.decode_base64(arr), arr = ref[0], shape = ref[1];
                    shapes.push(shape);
                    arrays.push(arr);
                } else if (types_1.isArray(arr)) {
                    shapes.push([]);
                    arrays.push(arr);
                }
            }
            if (shapes.length > 0) {
                new_data[k] = arrays;
                data_shapes[k] = shapes;
            } else {
                new_data[k] = v;
            }
        } else if (types_1.isObject(v) && '__ndarray__' in v) {
            ref1 = exports.decode_base64(v), arr = ref1[0], shape = ref1[1];
            new_data[k] = arr;
            data_shapes[k] = shape;
        } else {
            new_data[k] = v;
            data_shapes[k] = [];
        }
    }
    return [
        new_data,
        data_shapes
    ];
};
exports.encode_column_data = function (data, shapes) {
    var i, j, new_array, new_data, ref, ref1, ref2;
    new_data = {};
    for (k in data) {
        v = data[k];
        if ((v != null ? v.buffer : void 0) instanceof ArrayBuffer) {
            v = exports.encode_base64(v, shapes != null ? shapes[k] : void 0);
        } else if (types_1.isArray(v)) {
            new_array = [];
            for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (((ref1 = v[i]) != null ? ref1.buffer : void 0) instanceof ArrayBuffer) {
                    new_array.push(exports.encode_base64(v[i], shapes != null ? (ref2 = shapes[k]) != null ? ref2[i] : void 0 : void 0));
                } else {
                    new_array.push(v[i]);
                }
            }
            v = new_array;
        }
        new_data[k] = v;
    }
    return new_data;
};    
},
/* core/util/spatial */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var tslib_1 = require(357    /* tslib */);
/// <reference types="@types/rbush" />
var rbush = require(354    /* rbush */);
var SpatialIndex = function () {
    function SpatialIndex() {
    }
    return SpatialIndex;
}();
exports.SpatialIndex = SpatialIndex;
var RBush = function (_super) {
    tslib_1.__extends(RBush, _super);
    function RBush(points) {
        var _this = _super.call(this) || this;
        _this.index = rbush();
        _this.index.load(points);
        return _this;
    }
    Object.defineProperty(RBush.prototype, 'bbox', {
        get: function () {
            var _a = this.index.toJSON(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
            return {
                minX: minX,
                minY: minY,
                maxX: maxX,
                maxY: maxY
            };
        },
        enumerable: true,
        configurable: true
    });
    RBush.prototype.search = function (rect) {
        return this.index.search(rect);
    };
    RBush.prototype.indices = function (rect) {
        var points = this.search(rect);
        var n = points.length;
        var indices = new Array(n);
        for (var j = 0; j < n; j++) {
            indices[j] = points[j].i;
        }
        return indices;
    };
    return RBush;
}(SpatialIndex);
exports.RBush = RBush;    
},
/* core/util/string */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var settings_1 = require(17    /* ../settings */);
function startsWith(str, searchString, position) {
    if (position === void 0) {
        position = 0;
    }
    return str.substr(position, searchString.length) == searchString;
}
exports.startsWith = startsWith;
function uuid4() {
    // from ipython project
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = new Array(32);
    var hexDigits = '0123456789ABCDEF';
    for (var i = 0; i < 32; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
    }
    s[12] = '4';
    // bits 12-15 of the time_hi_and_version field to 0010
    s[16] = hexDigits.substr(s[16].charCodeAt(0) & 3 | 8, 1);
    // bits 6-7 of the clock_seq_hi_and_reserved to 01
    return s.join('');
}
exports.uuid4 = uuid4;
var counter = 1000;
function uniqueId(prefix) {
    var id = settings_1.settings.dev ? 'j' + counter++ : uuid4();
    if (prefix != null)
        return prefix + '-' + id;
    else
        return id;
}
exports.uniqueId = uniqueId;
function escape(s) {
    return s.replace(/(?:[&<>"'`])/g, function (ch) {
        switch (ch) {
        case '&':
            return '&amp;';
        case '<':
            return '&lt;';
        case '>':
            return '&gt;';
        case '"':
            return '&quot;';
        case '\'':
            return '&#x27;';
        case '`':
            return '&#x60;';
        default:
            return ch;
        }
    });
}
exports.escape = escape;    
},
/* core/util/svg_colors */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.indianred = '#CD5C5C';
exports.lightcoral = '#F08080';
exports.salmon = '#FA8072';
exports.darksalmon = '#E9967A';
exports.lightsalmon = '#FFA07A';
exports.crimson = '#DC143C';
exports.red = '#FF0000';
exports.firebrick = '#B22222';
exports.darkred = '#8B0000';
exports.pink = '#FFC0CB';
exports.lightpink = '#FFB6C1';
exports.hotpink = '#FF69B4';
exports.deeppink = '#FF1493';
exports.mediumvioletred = '#C71585';
exports.palevioletred = '#DB7093';
exports.coral = '#FF7F50';
exports.tomato = '#FF6347';
exports.orangered = '#FF4500';
exports.darkorange = '#FF8C00';
exports.orange = '#FFA500';
exports.gold = '#FFD700';
exports.yellow = '#FFFF00';
exports.lightyellow = '#FFFFE0';
exports.lemonchiffon = '#FFFACD';
exports.lightgoldenrodyellow = '#FAFAD2';
exports.papayawhip = '#FFEFD5';
exports.moccasin = '#FFE4B5';
exports.peachpuff = '#FFDAB9';
exports.palegoldenrod = '#EEE8AA';
exports.khaki = '#F0E68C';
exports.darkkhaki = '#BDB76B';
exports.lavender = '#E6E6FA';
exports.thistle = '#D8BFD8';
exports.plum = '#DDA0DD';
exports.violet = '#EE82EE';
exports.orchid = '#DA70D6';
exports.fuchsia = '#FF00FF';
exports.magenta = '#FF00FF';
exports.mediumorchid = '#BA55D3';
exports.mediumpurple = '#9370DB';
exports.blueviolet = '#8A2BE2';
exports.darkviolet = '#9400D3';
exports.darkorchid = '#9932CC';
exports.darkmagenta = '#8B008B';
exports.purple = '#800080';
exports.indigo = '#4B0082';
exports.slateblue = '#6A5ACD';
exports.darkslateblue = '#483D8B';
exports.mediumslateblue = '#7B68EE';
exports.greenyellow = '#ADFF2F';
exports.chartreuse = '#7FFF00';
exports.lawngreen = '#7CFC00';
exports.lime = '#00FF00';
exports.limegreen = '#32CD32';
exports.palegreen = '#98FB98';
exports.lightgreen = '#90EE90';
exports.mediumspringgreen = '#00FA9A';
exports.springgreen = '#00FF7F';
exports.mediumseagreen = '#3CB371';
exports.seagreen = '#2E8B57';
exports.forestgreen = '#228B22';
exports.green = '#008000';
exports.darkgreen = '#006400';
exports.yellowgreen = '#9ACD32';
exports.olivedrab = '#6B8E23';
exports.olive = '#808000';
exports.darkolivegreen = '#556B2F';
exports.mediumaquamarine = '#66CDAA';
exports.darkseagreen = '#8FBC8F';
exports.lightseagreen = '#20B2AA';
exports.darkcyan = '#008B8B';
exports.teal = '#008080';
exports.aqua = '#00FFFF';
exports.cyan = '#00FFFF';
exports.lightcyan = '#E0FFFF';
exports.paleturquoise = '#AFEEEE';
exports.aquamarine = '#7FFFD4';
exports.turquoise = '#40E0D0';
exports.mediumturquoise = '#48D1CC';
exports.darkturquoise = '#00CED1';
exports.cadetblue = '#5F9EA0';
exports.steelblue = '#4682B4';
exports.lightsteelblue = '#B0C4DE';
exports.powderblue = '#B0E0E6';
exports.lightblue = '#ADD8E6';
exports.skyblue = '#87CEEB';
exports.lightskyblue = '#87CEFA';
exports.deepskyblue = '#00BFFF';
exports.dodgerblue = '#1E90FF';
exports.cornflowerblue = '#6495ED';
exports.royalblue = '#4169E1';
exports.blue = '#0000FF';
exports.mediumblue = '#0000CD';
exports.darkblue = '#00008B';
exports.navy = '#000080';
exports.midnightblue = '#191970';
exports.cornsilk = '#FFF8DC';
exports.blanchedalmond = '#FFEBCD';
exports.bisque = '#FFE4C4';
exports.navajowhite = '#FFDEAD';
exports.wheat = '#F5DEB3';
exports.burlywood = '#DEB887';
exports.tan = '#D2B48C';
exports.rosybrown = '#BC8F8F';
exports.sandybrown = '#F4A460';
exports.goldenrod = '#DAA520';
exports.darkgoldenrod = '#B8860B';
exports.peru = '#CD853F';
exports.chocolate = '#D2691E';
exports.saddlebrown = '#8B4513';
exports.sienna = '#A0522D';
exports.brown = '#A52A2A';
exports.maroon = '#800000';
exports.white = '#FFFFFF';
exports.snow = '#FFFAFA';
exports.honeydew = '#F0FFF0';
exports.mintcream = '#F5FFFA';
exports.azure = '#F0FFFF';
exports.aliceblue = '#F0F8FF';
exports.ghostwhite = '#F8F8FF';
exports.whitesmoke = '#F5F5F5';
exports.seashell = '#FFF5EE';
exports.beige = '#F5F5DC';
exports.oldlace = '#FDF5E6';
exports.floralwhite = '#FFFAF0';
exports.ivory = '#FFFFF0';
exports.antiquewhite = '#FAEBD7';
exports.linen = '#FAF0E6';
exports.lavenderblush = '#FFF0F5';
exports.mistyrose = '#FFE4E1';
exports.gainsboro = '#DCDCDC';
exports.lightgray = '#D3D3D3';
exports.lightgrey = '#D3D3D3';
exports.silver = '#C0C0C0';
exports.darkgray = '#A9A9A9';
exports.darkgrey = '#A9A9A9';
exports.gray = '#808080';
exports.grey = '#808080';
exports.dimgray = '#696969';
exports.dimgrey = '#696969';
exports.lightslategray = '#778899';
exports.lightslategrey = '#778899';
exports.slategray = '#708090';
exports.slategrey = '#708090';
exports.darkslategray = '#2F4F4F';
exports.darkslategrey = '#2F4F4F';
exports.black = '#000000';    
},
/* core/util/templating */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _format_number;
var sprintf_js_1 = require(355    /* sprintf-js */);
var Numbro = require(325    /* numbro */);
var tz = require(356    /* timezone */);
var string_1 = require(35    /* ./string */);
var types_1 = require(40    /* ./types */);
_format_number = function (number) {
    var format;
    if (types_1.isNumber(number)) {
        format = function () {
            switch (false) {
            case Math.floor(number) !== number:
                return '%d';
            case !(Math.abs(number) > 0.1 && Math.abs(number) < 1000):
                return '%0.3f';
            default:
                return '%0.3e';
            }
        }();
        return sprintf_js_1.sprintf(format, number);
    } else {
        return '' + number;
    }
};
exports.replace_placeholders = function (string, data_source, i, formatters, special_vars) {
    if (special_vars == null) {
        special_vars = {};
    }
    string = string.replace(/(^|[^\$])\$(\w+)/g, function (_this) {
        return function (match, prefix, name) {
            return prefix + '@$' + name;
        };
    }(this));
    string = string.replace(/(^|[^@])@(?:(\$?\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, function (_this) {
        return function (match, prefix, name, long_name, format) {
            var ref, replacement, value;
            name = long_name != null ? long_name : name;
            value = name[0] === '$' ? special_vars[name.substring(1)] : (ref = data_source.get_column(name)) != null ? ref[i] : void 0;
            replacement = null;
            if (value == null) {
                replacement = '???';
            } else {
                if (format === 'safe') {
                    return '' + prefix + value;
                } else if (format != null) {
                    if (formatters != null && name in formatters) {
                        if (formatters[name] === 'numeral') {
                            replacement = Numbro.format(value, format);
                        } else if (formatters[name] === 'datetime') {
                            replacement = tz(value, format);
                        } else if (formatters[name] === 'printf') {
                            replacement = sprintf_js_1.sprintf(format, value);
                        } else {
                            throw new Error('Unknown tooltip field formatter type \'' + formatters[name] + '\'');
                        }
                    } else {
                        replacement = Numbro.format(value, format);
                    }
                } else {
                    replacement = _format_number(value);
                }
            }
            return replacement = '' + prefix + string_1.escape(replacement);
        };
    }(this));
    return string;
};    
},
/* core/util/text */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var dom_1 = require(4    /* ../dom */);
var cache = {};
function get_text_height(font) {
    if (cache[font] != null)
        return cache[font];
    var text = dom_1.span({ style: { font: font } }, 'Hg');
    var block = dom_1.div({
        style: {
            display: 'inline-block',
            width: '1px',
            height: '0px'
        }
    });
    var elem = dom_1.div({}, text, block);
    document.body.appendChild(elem);
    try {
        block.style.verticalAlign = 'baseline';
        var ascent = dom_1.offset(block).top - dom_1.offset(text).top;
        block.style.verticalAlign = 'bottom';
        var height = dom_1.offset(block).top - dom_1.offset(text).top;
        var result = {
            height: height,
            ascent: ascent,
            descent: height - ascent
        };
        cache[font] = result;
        return result;
    } finally {
        document.body.removeChild(elem);
    }
}
exports.get_text_height = get_text_height;    
},
/* core/util/throttle */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _delay_animation, delay_animation;
_delay_animation = function (f) {
    return f();
};
delay_animation = (typeof window !== 'undefined' && window !== null ? window.requestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.mozRequestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.webkitRequestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.msRequestAnimationFrame : void 0) || _delay_animation;
exports.throttle = function (func, wait) {
    var args, context, later, pending, previous, ref, result, timeout;
    ref = [
        null,
        null,
        null,
        null
    ], context = ref[0], args = ref[1], timeout = ref[2], result = ref[3];
    previous = 0;
    pending = false;
    later = function () {
        previous = new Date();
        timeout = null;
        pending = false;
        return result = func.apply(context, args);
    };
    return function () {
        var now, remaining;
        now = new Date();
        remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 && !pending) {
            clearTimeout(timeout);
            pending = true;
            delay_animation(later);
        } else if (!timeout && !pending) {
            timeout = setTimeout(function () {
                return delay_animation(later);
            }, remaining);
        }
        return result;
    };
};    
},
/* core/util/types */ function(require, module, exports) {
'use strict';
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
Object.defineProperty(exports, '__esModule', { value: true });
var toString = Object.prototype.toString;
function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return toString.call(obj) === '[object Number]';
}
exports.isNumber = isNumber;
function isInteger(obj) {
    return isNumber(obj) && isFinite(obj) && Math.floor(obj) === obj;
}
exports.isInteger = isInteger;
function isString(obj) {
    return toString.call(obj) === '[object String]';
}
exports.isString = isString;
function isStrictNaN(obj) {
    return isNumber(obj) && obj !== +obj;
}
exports.isStrictNaN = isStrictNaN;
function isFunction(obj) {
    return toString.call(obj) === '[object Function]';
}
exports.isFunction = isFunction;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isObject(obj) {
    var tp = typeof obj;
    return tp === 'function' || tp === 'object' && !!obj;
}
exports.isObject = isObject;    
},
/* core/util/wheel */ function(require, module, exports) {
'use strict';
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */
Object.defineProperty(exports, '__esModule', { value: true });
function fontSize(element) {
    var value = getComputedStyle(element).fontSize;
    if (value != null)
        return parseInt(value, 10);
    return null;
}
function lineHeight(element) {
    var parent = element.offsetParent || document.body;
    return fontSize(parent) || fontSize(element) || 16;
}
function pageHeight(element) {
    return element.clientHeight;    // XXX: should be content height?
}
function getDeltaY(event) {
    var deltaY = -event.deltaY;
    if (event.target instanceof HTMLElement) {
        switch (event.deltaMode) {
        case event.DOM_DELTA_LINE:
            deltaY *= lineHeight(event.target);
            break;
        case event.DOM_DELTA_PAGE:
            deltaY *= pageHeight(event.target);
            break;
        }
    }
    return deltaY;
}
exports.getDeltaY = getDeltaY;    
},
/* core/util/zoom */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var math_1 = require(27    /* ./math */);
exports.scale_highlow = function (range, factor, center) {
    var high, low, ref, x, x0, x1;
    if (center == null) {
        center = null;
    }
    ref = [
        range.start,
        range.end
    ], low = ref[0], high = ref[1];
    x = center != null ? center : (high + low) / 2;
    x0 = low - (low - x) * factor;
    x1 = high - (high - x) * factor;
    return [
        x0,
        x1
    ];
};
exports.get_info = function (scales, arg) {
    var end, info, name, ref, scale, start, x0, x1;
    x0 = arg[0], x1 = arg[1];
    info = {};
    for (name in scales) {
        scale = scales[name];
        ref = scale.v_invert([
            x0,
            x1
        ]), start = ref[0], end = ref[1];
        info[name] = {
            start: start,
            end: end
        };
    }
    return info;
};
exports.scale_range = function (frame, factor, h_axis, v_axis, center) {
    var hfactor, ref, ref1, vfactor, vx0, vx1, vy0, vy1, xrs, yrs;
    if (h_axis == null) {
        h_axis = true;
    }
    if (v_axis == null) {
        v_axis = true;
    }
    if (center == null) {
        center = null;
    }
    'Utility function for zoom tools to calculate/create the zoom_info object\nof the form required by ``PlotCanvasView.update_range``\n\nParameters:\n  frame : CartesianFrame\n  factor : Number\n  h_axis : Boolean, optional\n    whether to zoom the horizontal axis (default = true)\n  v_axis : Boolean, optional\n    whether to zoom the horizontal axis (default = true)\n  center : object, optional\n    of form {\'x\': Number, \'y\', Number}\n\nReturns:\n  object:';
    factor = math_1.clamp(factor, -0.9, 0.9);
    hfactor = h_axis ? factor : 0;
    ref = exports.scale_highlow(frame.h_range, hfactor, center != null ? center.x : void 0), vx0 = ref[0], vx1 = ref[1];
    xrs = exports.get_info(frame.xscales, [
        vx0,
        vx1
    ]);
    vfactor = v_axis ? factor : 0;
    ref1 = exports.scale_highlow(frame.v_range, vfactor, center != null ? center.y : void 0), vy0 = ref1[0], vy1 = ref1[1];
    yrs = exports.get_info(frame.yscales, [
        vy0,
        vy1
    ]);
    return {
        xrs: xrs,
        yrs: yrs,
        factor: factor
    };
};    
},
/* core/view */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var signaling_1 = require(18    /* ./signaling */);
var string_1 = require(35    /* ./util/string */);
exports.View = function () {
    extend(View.prototype, signaling_1.Signalable);
    View.getters = function (specs) {
        var fn, name, results;
        results = [];
        for (name in specs) {
            fn = specs[name];
            results.push(Object.defineProperty(this.prototype, name, { get: fn }));
        }
        return results;
    };
    function View(options) {
        var ref;
        if (options == null) {
            options = {};
        }
        this.removed = new signaling_1.Signal(this, 'removed');
        if (options.model != null) {
            this.model = options.model;
        } else {
            throw new Error('model of a view wasn\'t configured');
        }
        this._parent = options.parent;
        this.id = (ref = options.id) != null ? ref : string_1.uniqueId();
        this.initialize(options);
    }
    View.prototype.initialize = function (options) {
    };
    View.prototype.remove = function () {
        this._parent = void 0;
        this.disconnect_signals();
        return this.removed.emit();
    };
    View.prototype.toString = function () {
        return this.model.type + 'View(' + this.id + ')';
    };
    View.getters({
        parent: function () {
            if (this._parent !== void 0) {
                return this._parent;
            } else {
                throw new Error('parent of a view wasn\'t configured');
            }
        },
        is_root: function () {
            return this.parent === null;
        },
        root: function () {
            if (this.is_root) {
                return this;
            } else {
                return this.parent.root;
            }
        }
    });
    View.prototype.connect_signals = function () {
    };
    View.prototype.disconnect_signals = function () {
        return signaling_1.Signal.disconnectReceiver(this);
    };
    return View;
}();    
},
/* core/visuals */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ContextProperties, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var mixins = require(14    /* ./property_mixins */);
var color_1 = require(24    /* ./util/color */);
ContextProperties = function () {
    function ContextProperties(obj, prefix) {
        var attr, do_spec, j, len, ref;
        if (prefix == null) {
            prefix = '';
        }
        this.obj = obj;
        this.prefix = prefix;
        this.cache = {};
        do_spec = obj.properties[prefix + this.do_attr].spec;
        this.doit = do_spec.value !== null;
        ref = this.attrs;
        for (j = 0, len = ref.length; j < len; j++) {
            attr = ref[j];
            this[attr] = obj.properties[prefix + attr];
        }
    }
    ContextProperties.prototype.warm_cache = function (source) {
        var attr, j, len, prop, ref, results;
        ref = this.attrs;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
            attr = ref[j];
            prop = this.obj.properties[this.prefix + attr];
            if (prop.spec.value !== void 0) {
                results.push(this.cache[attr] = prop.spec.value);
            } else {
                results.push(this.cache[attr + '_array'] = prop.array(source));
            }
        }
        return results;
    };
    ContextProperties.prototype.cache_select = function (attr, i) {
        var prop;
        prop = this.obj.properties[this.prefix + attr];
        if (prop.spec.value !== void 0) {
            return this.cache[attr] = prop.spec.value;
        } else {
            return this.cache[attr] = this.cache[attr + '_array'][i];
        }
    };
    return ContextProperties;
}();
exports.Line = function (superClass) {
    extend(Line, superClass);
    function Line() {
        return Line.__super__.constructor.apply(this, arguments);
    }
    Line.prototype.attrs = Object.keys(mixins.line());
    Line.prototype.do_attr = 'line_color';
    Line.prototype.set_value = function (ctx) {
        ctx.strokeStyle = this.line_color.value();
        ctx.globalAlpha = this.line_alpha.value();
        ctx.lineWidth = this.line_width.value();
        ctx.lineJoin = this.line_join.value();
        ctx.lineCap = this.line_cap.value();
        ctx.setLineDash(this.line_dash.value());
        return ctx.setLineDashOffset(this.line_dash_offset.value());
    };
    Line.prototype.set_vectorize = function (ctx, i) {
        this.cache_select('line_color', i);
        if (ctx.strokeStyle !== this.cache.line_color) {
            ctx.strokeStyle = this.cache.line_color;
        }
        this.cache_select('line_alpha', i);
        if (ctx.globalAlpha !== this.cache.line_alpha) {
            ctx.globalAlpha = this.cache.line_alpha;
        }
        this.cache_select('line_width', i);
        if (ctx.lineWidth !== this.cache.line_width) {
            ctx.lineWidth = this.cache.line_width;
        }
        this.cache_select('line_join', i);
        if (ctx.lineJoin !== this.cache.line_join) {
            ctx.lineJoin = this.cache.line_join;
        }
        this.cache_select('line_cap', i);
        if (ctx.lineCap !== this.cache.line_cap) {
            ctx.lineCap = this.cache.line_cap;
        }
        this.cache_select('line_dash', i);
        if (ctx.getLineDash() !== this.cache.line_dash) {
            ctx.setLineDash(this.cache.line_dash);
        }
        this.cache_select('line_dash_offset', i);
        if (ctx.getLineDashOffset() !== this.cache.line_dash_offset) {
            return ctx.setLineDashOffset(this.cache.line_dash_offset);
        }
    };
    Line.prototype.color_value = function () {
        var color;
        color = color_1.color2rgba(this.line_color.value(), this.line_alpha.value());
        return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
    };
    return Line;
}(ContextProperties);
exports.Fill = function (superClass) {
    extend(Fill, superClass);
    function Fill() {
        return Fill.__super__.constructor.apply(this, arguments);
    }
    Fill.prototype.attrs = Object.keys(mixins.fill());
    Fill.prototype.do_attr = 'fill_color';
    Fill.prototype.set_value = function (ctx) {
        ctx.fillStyle = this.fill_color.value();
        return ctx.globalAlpha = this.fill_alpha.value();
    };
    Fill.prototype.set_vectorize = function (ctx, i) {
        this.cache_select('fill_color', i);
        if (ctx.fillStyle !== this.cache.fill_color) {
            ctx.fillStyle = this.cache.fill_color;
        }
        this.cache_select('fill_alpha', i);
        if (ctx.globalAlpha !== this.cache.fill_alpha) {
            return ctx.globalAlpha = this.cache.fill_alpha;
        }
    };
    Fill.prototype.color_value = function () {
        var color;
        color = color_1.color2rgba(this.fill_color.value(), this.fill_alpha.value());
        return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
    };
    return Fill;
}(ContextProperties);
exports.Text = function (superClass) {
    extend(Text, superClass);
    function Text() {
        return Text.__super__.constructor.apply(this, arguments);
    }
    Text.prototype.attrs = Object.keys(mixins.text());
    Text.prototype.do_attr = 'text_color';
    Text.prototype.cache_select = function (name, i) {
        var val;
        if (name === 'font') {
            val = Text.__super__.cache_select.call(this, 'text_font_style', i) + ' ' + Text.__super__.cache_select.call(this, 'text_font_size', i) + ' ' + Text.__super__.cache_select.call(this, 'text_font', i);
            return this.cache.font = val;
        } else {
            return Text.__super__.cache_select.call(this, name, i);
        }
    };
    Text.prototype.font_value = function () {
        var font, font_size, font_style;
        font = this.text_font.value();
        font_size = this.text_font_size.value();
        font_style = this.text_font_style.value();
        return font_style + ' ' + font_size + ' ' + font;
    };
    Text.prototype.color_value = function () {
        var color;
        color = color_1.color2rgba(this.text_color.value(), this.text_alpha.value());
        return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
    };
    Text.prototype.set_value = function (ctx) {
        ctx.font = this.font_value();
        ctx.fillStyle = this.text_color.value();
        ctx.globalAlpha = this.text_alpha.value();
        ctx.textAlign = this.text_align.value();
        return ctx.textBaseline = this.text_baseline.value();
    };
    Text.prototype.set_vectorize = function (ctx, i) {
        this.cache_select('font', i);
        if (ctx.font !== this.cache.font) {
            ctx.font = this.cache.font;
        }
        this.cache_select('text_color', i);
        if (ctx.fillStyle !== this.cache.text_color) {
            ctx.fillStyle = this.cache.text_color;
        }
        this.cache_select('text_alpha', i);
        if (ctx.globalAlpha !== this.cache.text_alpha) {
            ctx.globalAlpha = this.cache.text_alpha;
        }
        this.cache_select('text_align', i);
        if (ctx.textAlign !== this.cache.text_align) {
            ctx.textAlign = this.cache.text_align;
        }
        this.cache_select('text_baseline', i);
        if (ctx.textBaseline !== this.cache.text_baseline) {
            return ctx.textBaseline = this.cache.text_baseline;
        }
    };
    return Text;
}(ContextProperties);
exports.Visuals = function () {
    function Visuals(model) {
        var cls, j, len, name, prefix, ref, ref1, ref2, spec;
        ref = model.mixins;
        for (j = 0, len = ref.length; j < len; j++) {
            spec = ref[j];
            ref1 = spec.split(':'), name = ref1[0], prefix = (ref2 = ref1[1]) != null ? ref2 : '';
            cls = function () {
                switch (name) {
                case 'line':
                    return exports.Line;
                case 'fill':
                    return exports.Fill;
                case 'text':
                    return exports.Text;
                }
            }();
            this[prefix + name] = new cls(model, prefix);
        }
    }
    Visuals.prototype.warm_cache = function (source) {
        var name, prop, ref, results;
        ref = this;
        results = [];
        for (name in ref) {
            if (!hasProp.call(ref, name))
                continue;
            prop = ref[name];
            if (prop instanceof ContextProperties) {
                results.push(prop.warm_cache(source));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    return Visuals;
}();    
},
/* document */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var EventManager, extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var base_1 = require(0    /* ./base */);
var version_1 = require(241    /* ./version */);
var logging_1 = require(12    /* ./core/logging */);
var has_props_1 = require(7    /* ./core/has_props */);
var signaling_1 = require(18    /* ./core/signaling */);
var refs_1 = require(31    /* ./core/util/refs */);
var serialization_1 = require(33    /* ./core/util/serialization */);
var data_structures_1 = require(25    /* ./core/util/data_structures */);
var array_1 = require(20    /* ./core/util/array */);
var object_1 = require(28    /* ./core/util/object */);
var eq_1 = require(26    /* ./core/util/eq */);
var types_1 = require(40    /* ./core/util/types */);
var layout_dom_1 = require(134    /* ./models/layouts/layout_dom */);
var column_data_source_1 = require(168    /* ./models/sources/column_data_source */);
EventManager = function () {
    function EventManager(document) {
        this.document = document;
        this.session = null;
        this.subscribed_models = new data_structures_1.Set();
    }
    EventManager.prototype.send_event = function (event) {
        var ref1;
        return (ref1 = this.session) != null ? ref1.send_event(event) : void 0;
    };
    EventManager.prototype.trigger = function (event) {
        var j, len, model, model_id, ref1, results;
        ref1 = this.subscribed_models.values;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
            model_id = ref1[j];
            if (event.model_id !== null && event.model_id !== model_id) {
                continue;
            }
            model = this.document._all_models[model_id];
            results.push(model != null ? model._process_event(event) : void 0);
        }
        return results;
    };
    return EventManager;
}();
exports.DocumentChangedEvent = function () {
    function DocumentChangedEvent(document) {
        this.document = document;
    }
    return DocumentChangedEvent;
}();
exports.ModelChangedEvent = function (superClass) {
    extend1(ModelChangedEvent, superClass);
    function ModelChangedEvent(document, model1, attr1, old1, new_1, setter_id1) {
        this.document = document;
        this.model = model1;
        this.attr = attr1;
        this.old = old1;
        this.new_ = new_1;
        this.setter_id = setter_id1;
        ModelChangedEvent.__super__.constructor.call(this, this.document);
    }
    ModelChangedEvent.prototype.json = function (references) {
        var id, value, value_json, value_refs;
        if (this.attr === 'id') {
            logging_1.logger.warn('\'id\' field is immutable and should never be in a ModelChangedEvent ', this);
            throw new Error('\'id\' field should never change, whatever code just set it is wrong');
        }
        value = this.new_;
        value_json = this.model.constructor._value_to_json(this.attr, value, this.model);
        value_refs = {};
        has_props_1.HasProps._value_record_references(value, value_refs, true);
        if (this.model.id in value_refs && this.model !== value) {
            delete value_refs[this.model.id];
        }
        for (id in value_refs) {
            references[id] = value_refs[id];
        }
        return {
            'kind': 'ModelChanged',
            'model': this.model.ref(),
            'attr': this.attr,
            'new': value_json
        };
    };
    return ModelChangedEvent;
}(exports.DocumentChangedEvent);
exports.TitleChangedEvent = function (superClass) {
    extend1(TitleChangedEvent, superClass);
    function TitleChangedEvent(document, title1, setter_id1) {
        this.document = document;
        this.title = title1;
        this.setter_id = setter_id1;
        TitleChangedEvent.__super__.constructor.call(this, this.document);
    }
    TitleChangedEvent.prototype.json = function (references) {
        return {
            'kind': 'TitleChanged',
            'title': this.title
        };
    };
    return TitleChangedEvent;
}(exports.DocumentChangedEvent);
exports.RootAddedEvent = function (superClass) {
    extend1(RootAddedEvent, superClass);
    function RootAddedEvent(document, model1, setter_id1) {
        this.document = document;
        this.model = model1;
        this.setter_id = setter_id1;
        RootAddedEvent.__super__.constructor.call(this, this.document);
    }
    RootAddedEvent.prototype.json = function (references) {
        has_props_1.HasProps._value_record_references(this.model, references, true);
        return {
            'kind': 'RootAdded',
            'model': this.model.ref()
        };
    };
    return RootAddedEvent;
}(exports.DocumentChangedEvent);
exports.RootRemovedEvent = function (superClass) {
    extend1(RootRemovedEvent, superClass);
    function RootRemovedEvent(document, model1, setter_id1) {
        this.document = document;
        this.model = model1;
        this.setter_id = setter_id1;
        RootRemovedEvent.__super__.constructor.call(this, this.document);
    }
    RootRemovedEvent.prototype.json = function (references) {
        return {
            'kind': 'RootRemoved',
            'model': this.model.ref()
        };
    };
    return RootRemovedEvent;
}(exports.DocumentChangedEvent);
exports.documents = [];
exports.DEFAULT_TITLE = 'Bokeh Application';
exports.Document = function () {
    function Document() {
        exports.documents.push(this);
        this._title = exports.DEFAULT_TITLE;
        this._roots = [];
        this._all_models = {};
        this._all_models_by_name = new data_structures_1.MultiDict();
        this._all_models_freeze_count = 0;
        this._callbacks = [];
        this.event_manager = new EventManager(this);
        this.idle = new signaling_1.Signal(this, 'idle');
        this._idle_roots = new WeakMap();
    }
    Object.defineProperty(Document.prototype, 'layoutables', {
        get: function () {
            var j, len, ref1, results, root;
            ref1 = this._roots;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
                root = ref1[j];
                if (root instanceof layout_dom_1.LayoutDOM) {
                    results.push(root);
                }
            }
            return results;
        }
    });
    Object.defineProperty(Document.prototype, 'is_idle', {
        get: function () {
            var j, len, ref1, root;
            ref1 = this.layoutables;
            for (j = 0, len = ref1.length; j < len; j++) {
                root = ref1[j];
                if (!this._idle_roots.has(root)) {
                    return false;
                }
            }
            return true;
        }
    });
    Document.prototype.notify_idle = function (model) {
        this._idle_roots.set(model, true);
        if (this.is_idle) {
            return this.idle.emit();
        }
    };
    Document.prototype.clear = function () {
        var results;
        this._push_all_models_freeze();
        try {
            results = [];
            while (this._roots.length > 0) {
                results.push(this.remove_root(this._roots[0]));
            }
            return results;
        } finally {
            this._pop_all_models_freeze();
        }
    };
    Document.prototype.destructively_move = function (dest_doc) {
        var j, l, len, len1, len2, n, r, ref1, roots;
        if (dest_doc === this) {
            throw new Error('Attempted to overwrite a document with itself');
        }
        dest_doc.clear();
        roots = [];
        ref1 = this._roots;
        for (j = 0, len = ref1.length; j < len; j++) {
            r = ref1[j];
            roots.push(r);
        }
        this.clear();
        for (l = 0, len1 = roots.length; l < len1; l++) {
            r = roots[l];
            if (r.document !== null) {
                throw new Error('Somehow we didn\'t detach ' + r);
            }
        }
        if (Object.keys(this._all_models).length !== 0) {
            throw new Error('@_all_models still had stuff in it: ' + this._all_models);
        }
        for (n = 0, len2 = roots.length; n < len2; n++) {
            r = roots[n];
            dest_doc.add_root(r);
        }
        return dest_doc.set_title(this._title);
    };
    Document.prototype._push_all_models_freeze = function () {
        return this._all_models_freeze_count += 1;
    };
    Document.prototype._pop_all_models_freeze = function () {
        this._all_models_freeze_count -= 1;
        if (this._all_models_freeze_count === 0) {
            return this._recompute_all_models();
        }
    };
    Document.prototype._invalidate_all_models = function () {
        logging_1.logger.debug('invalidating document models');
        if (this._all_models_freeze_count === 0) {
            return this._recompute_all_models();
        }
    };
    Document.prototype._recompute_all_models = function () {
        var a, d, j, l, len, len1, len2, len3, m, n, name, new_all_models_set, o, old_all_models_set, r, recomputed, ref1, ref2, ref3, ref4, to_attach, to_detach;
        new_all_models_set = new data_structures_1.Set();
        ref1 = this._roots;
        for (j = 0, len = ref1.length; j < len; j++) {
            r = ref1[j];
            new_all_models_set = new_all_models_set.union(r.references());
        }
        old_all_models_set = new data_structures_1.Set(object_1.values(this._all_models));
        to_detach = old_all_models_set.diff(new_all_models_set);
        to_attach = new_all_models_set.diff(old_all_models_set);
        recomputed = {};
        ref2 = new_all_models_set.values;
        for (l = 0, len1 = ref2.length; l < len1; l++) {
            m = ref2[l];
            recomputed[m.id] = m;
        }
        ref3 = to_detach.values;
        for (n = 0, len2 = ref3.length; n < len2; n++) {
            d = ref3[n];
            d.detach_document();
            name = d.name;
            if (name !== null) {
                this._all_models_by_name.remove_value(name, d);
            }
        }
        ref4 = to_attach.values;
        for (o = 0, len3 = ref4.length; o < len3; o++) {
            a = ref4[o];
            a.attach_document(this);
            name = a.name;
            if (name !== null) {
                this._all_models_by_name.add_value(name, a);
            }
        }
        return this._all_models = recomputed;
    };
    Document.prototype.roots = function () {
        return this._roots;
    };
    Document.prototype.add_root = function (model, setter_id) {
        logging_1.logger.debug('Adding root: ' + model);
        if (indexOf.call(this._roots, model) >= 0) {
            return;
        }
        this._push_all_models_freeze();
        try {
            this._roots.push(model);
        } finally {
            this._pop_all_models_freeze();
        }
        return this._trigger_on_change(new exports.RootAddedEvent(this, model, setter_id));
    };
    Document.prototype.remove_root = function (model, setter_id) {
        var i;
        i = this._roots.indexOf(model);
        if (i < 0) {
            return;
        }
        this._push_all_models_freeze();
        try {
            this._roots.splice(i, 1);
        } finally {
            this._pop_all_models_freeze();
        }
        return this._trigger_on_change(new exports.RootRemovedEvent(this, model, setter_id));
    };
    Document.prototype.title = function () {
        return this._title;
    };
    Document.prototype.set_title = function (title, setter_id) {
        if (title !== this._title) {
            this._title = title;
            return this._trigger_on_change(new exports.TitleChangedEvent(this, title, setter_id));
        }
    };
    Document.prototype.get_model_by_id = function (model_id) {
        if (model_id in this._all_models) {
            return this._all_models[model_id];
        } else {
            return null;
        }
    };
    Document.prototype.get_model_by_name = function (name) {
        return this._all_models_by_name.get_one(name, 'Multiple models are named \'' + name + '\'');
    };
    Document.prototype.on_change = function (callback) {
        if (indexOf.call(this._callbacks, callback) >= 0) {
            return;
        }
        return this._callbacks.push(callback);
    };
    Document.prototype.remove_on_change = function (callback) {
        var i;
        i = this._callbacks.indexOf(callback);
        if (i >= 0) {
            return this._callbacks.splice(i, 1);
        }
    };
    Document.prototype._trigger_on_change = function (event) {
        var cb, j, len, ref1, results;
        ref1 = this._callbacks;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
            cb = ref1[j];
            results.push(cb(event));
        }
        return results;
    };
    Document.prototype._notify_change = function (model, attr, old, new_, options) {
        if (attr === 'name') {
            this._all_models_by_name.remove_value(old, model);
            if (new_ !== null) {
                this._all_models_by_name.add_value(new_, model);
            }
        }
        return this._trigger_on_change(new exports.ModelChangedEvent(this, model, attr, old, new_, options != null ? options.setter_id : void 0));
    };
    Document._references_json = function (references, include_defaults) {
        var j, len, r, ref, references_json;
        if (include_defaults == null) {
            include_defaults = true;
        }
        references_json = [];
        for (j = 0, len = references.length; j < len; j++) {
            r = references[j];
            ref = r.ref();
            ref['attributes'] = r.attributes_as_json(include_defaults);
            delete ref['attributes']['id'];
            references_json.push(ref);
        }
        return references_json;
    };
    Document._instantiate_object = function (obj_id, obj_type, obj_attrs) {
        var full_attrs, model;
        full_attrs = object_1.extend({}, obj_attrs, { id: obj_id });
        model = base_1.Models(obj_type);
        return new model(full_attrs, {
            silent: true,
            defer_initialization: true
        });
    };
    Document._instantiate_references_json = function (references_json, existing_models) {
        var instance, j, len, obj, obj_attrs, obj_id, obj_type, references;
        references = {};
        for (j = 0, len = references_json.length; j < len; j++) {
            obj = references_json[j];
            obj_id = obj['id'];
            obj_type = obj['type'];
            obj_attrs = obj['attributes'];
            if (obj_id in existing_models) {
                instance = existing_models[obj_id];
            } else {
                instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);
                if ('subtype' in obj) {
                    instance.set_subtype(obj['subtype']);
                }
            }
            references[instance.id] = instance;
        }
        return references;
    };
    Document._resolve_refs = function (value, old_references, new_references) {
        var resolve_array, resolve_dict, resolve_ref;
        resolve_ref = function (v) {
            if (refs_1.is_ref(v)) {
                if (v['id'] in old_references) {
                    return old_references[v['id']];
                } else if (v['id'] in new_references) {
                    return new_references[v['id']];
                } else {
                    throw new Error('reference ' + JSON.stringify(v) + ' isn\'t known (not in Document?)');
                }
            } else if (types_1.isArray(v)) {
                return resolve_array(v);
            } else if (types_1.isObject(v)) {
                return resolve_dict(v);
            } else {
                return v;
            }
        };
        resolve_dict = function (dict) {
            var k, resolved, v;
            resolved = {};
            for (k in dict) {
                v = dict[k];
                resolved[k] = resolve_ref(v);
            }
            return resolved;
        };
        resolve_array = function (array) {
            var j, len, results, v;
            results = [];
            for (j = 0, len = array.length; j < len; j++) {
                v = array[j];
                results.push(resolve_ref(v));
            }
            return results;
        };
        return resolve_ref(value);
    };
    Document._initialize_references_json = function (references_json, old_references, new_references) {
        var foreach_depth_first, instance, j, len, obj, obj_attrs, obj_id, to_update, was_new;
        to_update = {};
        for (j = 0, len = references_json.length; j < len; j++) {
            obj = references_json[j];
            obj_id = obj['id'];
            obj_attrs = obj['attributes'];
            was_new = false;
            instance = obj_id in old_references ? old_references[obj_id] : (was_new = true, new_references[obj_id]);
            obj_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);
            to_update[instance.id] = [
                instance,
                obj_attrs,
                was_new
            ];
        }
        foreach_depth_first = function (items, f) {
            var already_started, foreach_value, k, results, v;
            already_started = {};
            foreach_value = function (v, f) {
                var a, attrs, e, k, l, len1, ref1, results, results1, same_as_v;
                if (v instanceof has_props_1.HasProps) {
                    if (!(v.id in already_started) && v.id in items) {
                        already_started[v.id] = true;
                        ref1 = items[v.id], same_as_v = ref1[0], attrs = ref1[1], was_new = ref1[2];
                        for (a in attrs) {
                            e = attrs[a];
                            foreach_value(e, f);
                        }
                        return f(v, attrs, was_new);
                    }
                } else if (types_1.isArray(v)) {
                    results = [];
                    for (l = 0, len1 = v.length; l < len1; l++) {
                        e = v[l];
                        results.push(foreach_value(e, f));
                    }
                    return results;
                } else if (types_1.isObject(v)) {
                    results1 = [];
                    for (k in v) {
                        e = v[k];
                        results1.push(foreach_value(e, f));
                    }
                    return results1;
                }
            };
            results = [];
            for (k in items) {
                v = items[k];
                results.push(foreach_value(v[0], f));
            }
            return results;
        };
        foreach_depth_first(to_update, function (instance, attrs, was_new) {
            if (was_new) {
                return instance.setv(attrs, { silent: true });
            }
        });
        return foreach_depth_first(to_update, function (instance, attrs, was_new) {
            if (was_new) {
                return instance.finalize(attrs);
            }
        });
    };
    Document._event_for_attribute_change = function (changed_obj, key, new_value, doc, value_refs) {
        var changed_model, event;
        changed_model = doc.get_model_by_id(changed_obj.id);
        if (!changed_model.attribute_is_serializable(key)) {
            return null;
        }
        event = {
            'kind': 'ModelChanged',
            'model': {
                id: changed_obj.id,
                type: changed_obj.type
            },
            'attr': key,
            'new': new_value
        };
        has_props_1.HasProps._json_record_references(doc, new_value, value_refs, true);
        return event;
    };
    Document._events_to_sync_objects = function (from_obj, to_obj, to_doc, value_refs) {
        var added, events, from_keys, j, key, l, len, len1, len2, n, new_value, old_value, removed, shared, to_keys;
        from_keys = Object.keys(from_obj.attributes);
        to_keys = Object.keys(to_obj.attributes);
        removed = array_1.difference(from_keys, to_keys);
        added = array_1.difference(to_keys, from_keys);
        shared = array_1.intersection(from_keys, to_keys);
        events = [];
        for (j = 0, len = removed.length; j < len; j++) {
            key = removed[j];
            logging_1.logger.warn('Server sent key ' + key + ' but we don\'t seem to have it in our JSON');
        }
        for (l = 0, len1 = added.length; l < len1; l++) {
            key = added[l];
            new_value = to_obj.attributes[key];
            events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
        }
        for (n = 0, len2 = shared.length; n < len2; n++) {
            key = shared[n];
            old_value = from_obj.attributes[key];
            new_value = to_obj.attributes[key];
            if (old_value === null && new_value === null) {
            } else if (old_value === null || new_value === null) {
                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
            } else {
                if (!eq_1.isEqual(old_value, new_value)) {
                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
                }
            }
        }
        return events.filter(function (e) {
            return e !== null;
        });
    };
    Document._compute_patch_since_json = function (from_json, to_doc) {
        var events, from_references, from_root_ids, from_roots, id, include_defaults, j, l, len, len1, model, r, ref1, ref2, ref3, refs, to_json, to_references, to_root_ids, to_roots, update_model_events, value_refs;
        to_json = to_doc.to_json(include_defaults = false);
        refs = function (json) {
            var j, len, obj, ref1, result;
            result = {};
            ref1 = json['roots']['references'];
            for (j = 0, len = ref1.length; j < len; j++) {
                obj = ref1[j];
                result[obj.id] = obj;
            }
            return result;
        };
        from_references = refs(from_json);
        from_roots = {};
        from_root_ids = [];
        ref1 = from_json['roots']['root_ids'];
        for (j = 0, len = ref1.length; j < len; j++) {
            r = ref1[j];
            from_roots[r] = from_references[r];
            from_root_ids.push(r);
        }
        to_references = refs(to_json);
        to_roots = {};
        to_root_ids = [];
        ref2 = to_json['roots']['root_ids'];
        for (l = 0, len1 = ref2.length; l < len1; l++) {
            r = ref2[l];
            to_roots[r] = to_references[r];
            to_root_ids.push(r);
        }
        from_root_ids.sort();
        to_root_ids.sort();
        if (array_1.difference(from_root_ids, to_root_ids).length > 0 || array_1.difference(to_root_ids, from_root_ids).length > 0) {
            throw new Error('Not implemented: computing add/remove of document roots');
        }
        value_refs = {};
        events = [];
        ref3 = to_doc._all_models;
        for (id in ref3) {
            model = ref3[id];
            if (id in from_references) {
                update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);
                events = events.concat(update_model_events);
            }
        }
        return {
            'events': events,
            'references': Document._references_json(object_1.values(value_refs), include_defaults = false)
        };
    };
    Document.prototype.to_json_string = function (include_defaults) {
        if (include_defaults == null) {
            include_defaults = true;
        }
        return JSON.stringify(this.to_json(include_defaults));
    };
    Document.prototype.to_json = function (include_defaults) {
        var j, len, r, ref1, root_ids, root_references;
        if (include_defaults == null) {
            include_defaults = true;
        }
        root_ids = [];
        ref1 = this._roots;
        for (j = 0, len = ref1.length; j < len; j++) {
            r = ref1[j];
            root_ids.push(r.id);
        }
        root_references = object_1.values(this._all_models);
        return {
            'title': this._title,
            'roots': {
                'root_ids': root_ids,
                'references': Document._references_json(root_references, include_defaults)
            }
        };
    };
    Document.from_json_string = function (s) {
        var json;
        if (s === null || s == null) {
            throw new Error('JSON string is ' + typeof s);
        }
        json = JSON.parse(s);
        return Document.from_json(json);
    };
    Document.from_json = function (json) {
        var doc, is_dev, j, len, py_version, r, references, references_json, root_ids, roots_json, versions_string;
        logging_1.logger.debug('Creating Document from JSON');
        if (typeof json !== 'object') {
            throw new Error('JSON object has wrong type ' + typeof json);
        }
        py_version = json['version'];
        is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;
        versions_string = 'Library versions: JS (' + version_1.version + ')  /  Python (' + py_version + ')';
        if (!is_dev && version_1.version !== py_version) {
            logging_1.logger.warn('JS/Python version mismatch');
            logging_1.logger.warn(versions_string);
        } else {
            logging_1.logger.debug(versions_string);
        }
        roots_json = json['roots'];
        root_ids = roots_json['root_ids'];
        references_json = roots_json['references'];
        references = Document._instantiate_references_json(references_json, {});
        Document._initialize_references_json(references_json, {}, references);
        doc = new Document();
        for (j = 0, len = root_ids.length; j < len; j++) {
            r = root_ids[j];
            doc.add_root(references[r]);
        }
        doc.set_title(json['title']);
        return doc;
    };
    Document.prototype.replace_with_json = function (json) {
        var replacement;
        replacement = Document.from_json(json);
        return replacement.destructively_move(this);
    };
    Document.prototype.create_json_patch_string = function (events) {
        return JSON.stringify(this.create_json_patch(events));
    };
    Document.prototype.create_json_patch = function (events) {
        var event, j, json_events, len, references, result;
        references = {};
        json_events = [];
        for (j = 0, len = events.length; j < len; j++) {
            event = events[j];
            if (event.document !== this) {
                logging_1.logger.warn('Cannot create a patch using events from a different document, event had ', event.document, ' we are ', this);
                throw new Error('Cannot create a patch using events from a different document');
            }
            json_events.push(event.json(references));
        }
        return result = {
            events: json_events,
            references: Document._references_json(object_1.values(references))
        };
    };
    Document.prototype.apply_json_patch_string = function (patch) {
        return this.apply_json_patch(JSON.parse(patch));
    };
    Document.prototype.apply_json_patch = function (patch, setter_id) {
        var attr, column_source, column_source_id, data, event_json, events_json, id, j, l, len, len1, model_id, model_type, new_references, obj1, old_references, patched_id, patched_obj, patches, ref1, references, references_json, results, rollover, root_id, root_obj, shapes, value;
        references_json = patch['references'];
        events_json = patch['events'];
        references = Document._instantiate_references_json(references_json, this._all_models);
        for (j = 0, len = events_json.length; j < len; j++) {
            event_json = events_json[j];
            if ('model' in event_json) {
                model_id = event_json['model']['id'];
                if (model_id in this._all_models) {
                    references[model_id] = this._all_models[model_id];
                } else {
                    if (!(model_id in references)) {
                        logging_1.logger.warn('Got an event for unknown model ', event_json['model']);
                        throw new Error('event model wasn\'t known');
                    }
                }
            }
        }
        old_references = {};
        new_references = {};
        for (id in references) {
            value = references[id];
            if (id in this._all_models) {
                old_references[id] = value;
            } else {
                new_references[id] = value;
            }
        }
        Document._initialize_references_json(references_json, old_references, new_references);
        results = [];
        for (l = 0, len1 = events_json.length; l < len1; l++) {
            event_json = events_json[l];
            switch (event_json.kind) {
            case 'ModelChanged':
                patched_id = event_json['model']['id'];
                if (!(patched_id in this._all_models)) {
                    throw new Error('Cannot apply patch to ' + patched_id + ' which is not in the document');
                }
                patched_obj = this._all_models[patched_id];
                attr = event_json['attr'];
                model_type = event_json['model']['type'];
                if (attr === 'data' && model_type === 'ColumnDataSource') {
                    ref1 = serialization_1.decode_column_data(event_json['new']), data = ref1[0], shapes = ref1[1];
                    results.push(patched_obj.setv({
                        _shapes: shapes,
                        data: data
                    }, { setter_id: setter_id }));
                } else {
                    value = Document._resolve_refs(event_json['new'], old_references, new_references);
                    results.push(patched_obj.setv((obj1 = {}, obj1['' + attr] = value, obj1), { setter_id: setter_id }));
                }
                break;
            case 'ColumnsStreamed':
                column_source_id = event_json['column_source']['id'];
                if (!(column_source_id in this._all_models)) {
                    throw new Error('Cannot stream to ' + column_source_id + ' which is not in the document');
                }
                column_source = this._all_models[column_source_id];
                if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {
                    throw new Error('Cannot stream to non-ColumnDataSource');
                }
                data = event_json['data'];
                rollover = event_json['rollover'];
                results.push(column_source.stream(data, rollover));
                break;
            case 'ColumnsPatched':
                column_source_id = event_json['column_source']['id'];
                if (!(column_source_id in this._all_models)) {
                    throw new Error('Cannot patch ' + column_source_id + ' which is not in the document');
                }
                column_source = this._all_models[column_source_id];
                if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {
                    throw new Error('Cannot patch non-ColumnDataSource');
                }
                patches = event_json['patches'];
                results.push(column_source.patch(patches));
                break;
            case 'RootAdded':
                root_id = event_json['model']['id'];
                root_obj = references[root_id];
                results.push(this.add_root(root_obj, setter_id));
                break;
            case 'RootRemoved':
                root_id = event_json['model']['id'];
                root_obj = references[root_id];
                results.push(this.remove_root(root_obj, setter_id));
                break;
            case 'TitleChanged':
                results.push(this.set_title(event_json['title'], setter_id));
                break;
            default:
                throw new Error('Unknown patch event ' + JSON.stringify(event_json));
            }
        }
        return results;
    };
    return Document;
}();    
},
/* embed */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _create_view, _get_session, _handle_notebook_comms, _init_comms, _render_document_to_element, _sessions, _update_comms_callback, add_document_from_session, add_model_from_session, add_model_static, fill_render_item_from_script_tag;
var base = require(0    /* ./base */);
var client_1 = require(1    /* ./client */);
var logging_1 = require(12    /* ./core/logging */);
var document_1 = require(45    /* ./document */);
var dom_1 = require(4    /* ./core/dom */);
exports.BOKEH_ROOT = 'bk-root';
_handle_notebook_comms = function (msg) {
    var data;
    logging_1.logger.debug('handling notebook comms');
    data = JSON.parse(msg.content.data);
    if ('events' in data && 'references' in data) {
        return this.apply_json_patch(data);
    } else if ('doc' in data) {
        return this.replace_with_json(data['doc']);
    } else {
        throw new Error('handling notebook comms message: ', msg);
    }
};
_update_comms_callback = function (target, doc, comm) {
    if (target === comm.target_name) {
        return comm.on_msg(_handle_notebook_comms.bind(doc));
    }
};
_init_comms = function (target, doc) {
    var comm_manager, e, id, promise, ref, update_comms;
    if (typeof Jupyter !== 'undefined' && Jupyter !== null && Jupyter.notebook.kernel != null) {
        logging_1.logger.info('Registering Jupyter comms for target ' + target);
        comm_manager = Jupyter.notebook.kernel.comm_manager;
        update_comms = function (comm) {
            return _update_comms_callback(target, doc, comm);
        };
        ref = comm_manager.comms;
        for (id in ref) {
            promise = ref[id];
            promise.then(update_comms);
        }
        try {
            return comm_manager.register_target(target, function (comm, msg) {
                logging_1.logger.info('Registering Jupyter comms for target ' + target);
                return comm.on_msg(_handle_notebook_comms.bind(doc));
            });
        } catch (error1) {
            e = error1;
            return logging_1.logger.warn('Jupyter comms failed to register. push_notebook() will not function. (exception reported: ' + e + ')');
        }
    } else {
        return console.warn('Jupyter notebooks comms not available. push_notebook() will not function');
    }
};
_create_view = function (model) {
    var view;
    view = new model.default_view({
        model: model,
        parent: null
    });
    base.index[model.id] = view;
    return view;
};
_render_document_to_element = function (element, document, use_for_title) {
    var i, len, model, ref, render_model, unrender_model, views;
    views = {};
    render_model = function (model) {
        var view;
        view = _create_view(model);
        view.renderTo(element);
        return views[model.id] = view;
    };
    unrender_model = function (model) {
        var view;
        if (model.id in views) {
            view = views[model.id];
            element.removeChild(view.el);
            delete views[model.id];
            return delete base.index[model.id];
        }
    };
    ref = document.roots();
    for (i = 0, len = ref.length; i < len; i++) {
        model = ref[i];
        render_model(model);
    }
    if (use_for_title) {
        window.document.title = document.title();
    }
    document.on_change(function (event) {
        if (event instanceof document_1.RootAddedEvent) {
            return render_model(event.model);
        } else if (event instanceof document_1.RootRemovedEvent) {
            return unrender_model(event.model);
        } else if (use_for_title && event instanceof document_1.TitleChangedEvent) {
            return window.document.title = event.title;
        }
    });
    return views;
};
add_model_static = function (element, model_id, doc) {
    var model, view;
    model = doc.get_model_by_id(model_id);
    if (model == null) {
        throw new Error('Model ' + model_id + ' was not in document ' + doc);
    }
    view = _create_view(model);
    return view.renderTo(element, true);
};
exports.add_document_static = function (element, doc, use_for_title) {
    return _render_document_to_element(element, doc, use_for_title);
};
exports.add_document_standalone = function (document, element, use_for_title) {
    if (use_for_title == null) {
        use_for_title = false;
    }
    return _render_document_to_element(element, document, use_for_title);
};
_sessions = {};
_get_session = function (websocket_url, session_id, args_string) {
    var subsessions;
    if (websocket_url == null) {
        throw new Error('Missing websocket_url');
    }
    if (!(websocket_url in _sessions)) {
        _sessions[websocket_url] = {};
    }
    subsessions = _sessions[websocket_url];
    if (!(session_id in subsessions)) {
        subsessions[session_id] = client_1.pull_session(websocket_url, session_id, args_string);
    }
    return subsessions[session_id];
};
add_document_from_session = function (element, websocket_url, session_id, use_for_title) {
    var args_string, promise;
    args_string = window.location.search.substr(1);
    promise = _get_session(websocket_url, session_id, args_string);
    return promise.then(function (session) {
        return _render_document_to_element(element, session.document, use_for_title);
    }, function (error) {
        logging_1.logger.error('Failed to load Bokeh session ' + session_id + ': ' + error);
        throw error;
    });
};
add_model_from_session = function (element, websocket_url, model_id, session_id) {
    var args_string, promise;
    args_string = window.location.search.substr(1);
    promise = _get_session(websocket_url, session_id, args_string);
    return promise.then(function (session) {
        var model, view;
        model = session.document.get_model_by_id(model_id);
        if (model == null) {
            throw new Error('Did not find model ' + model_id + ' in session');
        }
        view = _create_view(model);
        return view.renderTo(element, true);
    }, function (error) {
        logging_1.logger.error('Failed to load Bokeh session ' + session_id + ': ' + error);
        throw error;
    });
};
exports.inject_css = function (url) {
    var element;
    element = dom_1.link({
        href: url,
        rel: 'stylesheet',
        type: 'text/css'
    });
    return document.body.appendChild(element);
};
exports.inject_raw_css = function (css) {
    var element;
    element = dom_1.style({}, css);
    return document.body.appendChild(element);
};
fill_render_item_from_script_tag = function (script, item) {
    var info;
    info = script.dataset;
    if (info.bokehLogLevel != null && info.bokehLogLevel.length > 0) {
        logging_1.set_log_level(info.bokehLogLevel);
    }
    if (info.bokehDocId != null && info.bokehDocId.length > 0) {
        item['docid'] = info.bokehDocId;
    }
    if (info.bokehModelId != null && info.bokehModelId.length > 0) {
        item['modelid'] = info.bokehModelId;
    }
    if (info.bokehSessionId != null && info.bokehSessionId.length > 0) {
        item['sessionid'] = info.bokehSessionId;
    }
    return logging_1.logger.info('Will inject Bokeh script tag with params ' + JSON.stringify(item));
};
exports.embed_items = function (docs_json, render_items, app_path, absolute_url) {
    var child, container, docid, docs, elem, element_id, i, item, len, loc, promise, protocol, results, use_for_title, websocket_url;
    protocol = 'ws:';
    if (window.location.protocol === 'https:') {
        protocol = 'wss:';
    }
    if (absolute_url != null) {
        loc = new URL(absolute_url);
    } else {
        loc = window.location;
    }
    if (app_path != null) {
        if (app_path === '/') {
            app_path = '';
        }
    } else {
        app_path = loc.pathname.replace(/\/+$/, '');
    }
    websocket_url = protocol + '//' + loc.host + app_path + '/ws';
    logging_1.logger.debug('embed: computed ws url: ' + websocket_url);
    docs = {};
    for (docid in docs_json) {
        docs[docid] = document_1.Document.from_json(docs_json[docid]);
    }
    results = [];
    for (i = 0, len = render_items.length; i < len; i++) {
        item = render_items[i];
        if (item.notebook_comms_target != null) {
            _init_comms(item.notebook_comms_target, docs[docid]);
        }
        element_id = item['elementid'];
        elem = document.getElementById(element_id);
        if (elem == null) {
            throw new Error('Error rendering Bokeh model: could not find tag with id: ' + element_id);
        }
        if (!document.body.contains(elem)) {
            throw new Error('Error rendering Bokeh model: element with id \'' + element_id + '\' must be under <body>');
        }
        if (elem.tagName === 'SCRIPT') {
            fill_render_item_from_script_tag(elem, item);
            container = dom_1.div({ 'class': exports.BOKEH_ROOT });
            dom_1.replaceWith(elem, container);
            child = dom_1.div();
            container.appendChild(child);
            elem = child;
        }
        use_for_title = item.use_for_title != null && item.use_for_title;
        promise = null;
        if (item.modelid != null) {
            if (item.docid != null) {
                add_model_static(elem, item.modelid, docs[item.docid]);
            } else if (item.sessionid != null) {
                promise = add_model_from_session(elem, websocket_url, item.modelid, item.sessionid);
            } else {
                throw new Error('Error rendering Bokeh model ' + item['modelid'] + ' to element ' + element_id + ': no document ID or session ID specified');
            }
        } else {
            if (item.docid != null) {
                exports.add_document_static(elem, docs[item.docid], use_for_title);
            } else if (item.sessionid != null) {
                promise = add_document_from_session(elem, websocket_url, item.sessionid, use_for_title);
            } else {
                throw new Error('Error rendering Bokeh document to element ' + element_id + ': no document ID or session ID specified');
            }
        }
        if (promise !== null) {
            results.push(promise.then(function (value) {
                return console.log('Bokeh items were rendered successfully');
            }, function (error) {
                return console.log('Error rendering Bokeh items ', error);
            }));
        } else {
            results.push(void 0);
        }
    }
    return results;
};    
},
/* main */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
require(239    /* ./polyfill */);
var version_1 = require(241    /* ./version */);
exports.version = version_1.version;
var embed = require(46    /* ./embed */);
exports.embed = embed;
var logging_1 = require(12    /* ./core/logging */);
exports.logger = logging_1.logger;
exports.set_log_level = logging_1.set_log_level;
var settings_1 = require(17    /* ./core/settings */);
exports.settings = settings_1.settings;
var base_1 = require(0    /* ./base */);
exports.Models = base_1.Models;
exports.index = base_1.index;
var document_1 = require(45    /* ./document */);
exports.documents = document_1.documents;
var safely_1 = require(240    /* ./safely */);
exports.safely = safely_1.safely;    
},
/* model */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var has_props_1 = require(7    /* ./core/has_props */);
var p = require(13    /* ./core/properties */);
var types_1 = require(40    /* ./core/util/types */);
var object_1 = require(28    /* ./core/util/object */);
var logging_1 = require(12    /* ./core/logging */);
exports.Model = function (superClass) {
    extend(Model, superClass);
    function Model() {
        return Model.__super__.constructor.apply(this, arguments);
    }
    Model.prototype.type = 'Model';
    Model.define({
        tags: [
            p.Array,
            []
        ],
        name: [p.String],
        js_property_callbacks: [
            p.Any,
            {}
        ],
        js_event_callbacks: [
            p.Any,
            {}
        ],
        subscribed_events: [
            p.Array,
            []
        ]
    });
    Model.prototype.connect_signals = function () {
        var attr, callbacks, cb, evt, i, len, ref1, ref2, ref3;
        Model.__super__.connect_signals.call(this);
        ref1 = this.js_property_callbacks;
        for (evt in ref1) {
            callbacks = ref1[evt];
            ref2 = evt.split(':'), evt = ref2[0], attr = (ref3 = ref2[1]) != null ? ref3 : null;
            for (i = 0, len = callbacks.length; i < len; i++) {
                cb = callbacks[i];
                if (attr !== null) {
                    this.connect(this.properties[attr][evt], function () {
                        return cb.execute(this);
                    });
                } else {
                    this.connect(this[evt], function () {
                        return cb.execute(this);
                    });
                }
            }
        }
        this.connect(this.properties.js_event_callbacks.change, function () {
            return this._update_event_callbacks;
        });
        return this.connect(this.properties.subscribed_events.change, function () {
            return this._update_event_callbacks;
        });
    };
    Model.prototype._process_event = function (event) {
        var callback, i, len, ref1, ref2;
        if (event.is_applicable_to(this)) {
            event = event._customize_event(this);
            ref2 = (ref1 = this.js_event_callbacks[event.event_name]) != null ? ref1 : [];
            for (i = 0, len = ref2.length; i < len; i++) {
                callback = ref2[i];
                callback.execute(event, {});
            }
            if (this.subscribed_events.some(function (m) {
                    return m === event.event_name;
                })) {
                return this.document.event_manager.send_event(event);
            }
        }
    };
    Model.prototype.trigger_event = function (event) {
        var ref1;
        return (ref1 = this.document) != null ? ref1.event_manager.trigger(event.set_model_id(this.id)) : void 0;
    };
    Model.prototype._update_event_callbacks = function () {
        if (this.document == null) {
            logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');
            return;
        }
        return this.document.event_manager.subscribed_models.push(this.id);
    };
    Model.prototype._doc_attached = function () {
        if (!object_1.isEmpty(this.js_event_callbacks) || !object_1.isEmpty(this.subscribed_events)) {
            return this._update_event_callbacks();
        }
    };
    Model.prototype.select = function (selector) {
        if (selector.prototype instanceof Model) {
            return this.references().filter(function (ref) {
                return ref instanceof selector;
            });
        } else if (types_1.isString(selector)) {
            return this.references().filter(function (ref) {
                return ref.name === selector;
            });
        } else {
            throw new Error('invalid selector');
        }
    };
    Model.prototype.select_one = function (selector) {
        var result;
        result = this.select(selector);
        switch (result.length) {
        case 0:
            return null;
        case 1:
            return result[0];
        default:
            throw new Error('found more than one object matching given selector');
        }
    };
    return Model;
}(has_props_1.HasProps);    
},
/* models/annotations/annotation */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var side_panel_1 = require(10    /* core/layout/side_panel */);
var p = require(13    /* core/properties */);
var renderer_1 = require(160    /* ../renderers/renderer */);
exports.AnnotationView = function (superClass) {
    extend(AnnotationView, superClass);
    function AnnotationView() {
        return AnnotationView.__super__.constructor.apply(this, arguments);
    }
    AnnotationView.prototype._get_panel_offset = function () {
        var x, y;
        x = this.model.panel._left.value;
        y = this.model.panel._bottom.value;
        return {
            x: x,
            y: -y
        };
    };
    AnnotationView.prototype._get_size = function () {
        return -1;
    };
    return AnnotationView;
}(renderer_1.RendererView);
exports.Annotation = function (superClass) {
    extend(Annotation, superClass);
    function Annotation() {
        return Annotation.__super__.constructor.apply(this, arguments);
    }
    Annotation.prototype.type = 'Annotation';
    Annotation.prototype.default_view = exports.AnnotationView;
    Annotation.define({ plot: [p.Instance] });
    Annotation.override({ level: 'annotation' });
    Annotation.prototype.add_panel = function (side) {
        this.panel = new side_panel_1.SidePanel({ side: side });
        this.panel.attach_document(this.document);
        return this.level = 'overlay';
    };
    return Annotation;
}(renderer_1.Renderer);    
},
/* models/annotations/arrow */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var arrow_head_1 = require(51    /* ./arrow_head */);
var column_data_source_1 = require(168    /* ../sources/column_data_source */);
var p = require(13    /* core/properties */);
var math_1 = require(27    /* core/util/math */);
exports.ArrowView = function (superClass) {
    extend(ArrowView, superClass);
    function ArrowView() {
        return ArrowView.__super__.constructor.apply(this, arguments);
    }
    ArrowView.prototype.initialize = function (options) {
        ArrowView.__super__.initialize.call(this, options);
        if (this.model.source == null) {
            this.model.source = new column_data_source_1.ColumnDataSource();
        }
        this.canvas = this.plot_model.canvas;
        return this.set_data(this.model.source);
    };
    ArrowView.prototype.connect_signals = function () {
        ArrowView.__super__.connect_signals.call(this);
        this.connect(this.model.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
        this.connect(this.model.source.streaming, function () {
            return this.set_data(this.model.source);
        });
        this.connect(this.model.source.patching, function () {
            return this.set_data(this.model.source);
        });
        return this.connect(this.model.source.change, function () {
            return this.set_data(this.model.source);
        });
    };
    ArrowView.prototype.set_data = function (source) {
        ArrowView.__super__.set_data.call(this, source);
        this.visuals.warm_cache(source);
        return this.plot_view.request_render();
    };
    ArrowView.prototype._map_data = function () {
        var end, start, x_name, y_name;
        if (this.model.start_units === 'data') {
            start = this.plot_view.map_to_screen(this._x_start, this._y_start, x_name = this.model.x_range_name, y_name = this.model.y_range_name);
        } else {
            start = [
                this.canvas.v_vx_to_sx(this._x_start),
                this.canvas.v_vy_to_sy(this._y_start)
            ];
        }
        if (this.model.end_units === 'data') {
            end = this.plot_view.map_to_screen(this._x_end, this._y_end, x_name = this.model.x_range_name, y_name = this.model.y_range_name);
        } else {
            end = [
                this.canvas.v_vx_to_sx(this._x_end),
                this.canvas.v_vy_to_sy(this._y_end)
            ];
        }
        return [
            start,
            end
        ];
    };
    ArrowView.prototype.render = function () {
        var ctx, ref;
        if (!this.model.visible) {
            return;
        }
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        ref = this._map_data(), this.start = ref[0], this.end = ref[1];
        if (this.model.end != null) {
            this._arrow_head(ctx, 'render', this.model.end, this.start, this.end);
        }
        if (this.model.start != null) {
            this._arrow_head(ctx, 'render', this.model.start, this.end, this.start);
        }
        ctx.beginPath();
        ctx.rect(0, 0, this.canvas._width.value, this.canvas._height.value);
        if (this.model.end != null) {
            this._arrow_head(ctx, 'clip', this.model.end, this.start, this.end);
        }
        if (this.model.start != null) {
            this._arrow_head(ctx, 'clip', this.model.start, this.end, this.start);
        }
        ctx.closePath();
        ctx.clip();
        this._arrow_body(ctx);
        return ctx.restore();
    };
    ArrowView.prototype._arrow_body = function (ctx) {
        var i, j, ref, results;
        if (!this.visuals.line.doit) {
            return;
        }
        results = [];
        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.visuals.line.set_vectorize(ctx, i);
            ctx.beginPath();
            ctx.moveTo(this.start[0][i], this.start[1][i]);
            ctx.lineTo(this.end[0][i], this.end[1][i]);
            results.push(ctx.stroke());
        }
        return results;
    };
    ArrowView.prototype._arrow_head = function (ctx, action, head, start, end) {
        var angle, i, j, ref, results;
        results = [];
        for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            angle = Math.PI / 2 + math_1.atan2([
                start[0][i],
                start[1][i]
            ], [
                end[0][i],
                end[1][i]
            ]);
            ctx.save();
            ctx.translate(end[0][i], end[1][i]);
            ctx.rotate(angle);
            if (action === 'render') {
                head.render(ctx);
            } else if (action === 'clip') {
                head.clip(ctx);
            }
            results.push(ctx.restore());
        }
        return results;
    };
    return ArrowView;
}(annotation_1.AnnotationView);
exports.Arrow = function (superClass) {
    extend(Arrow, superClass);
    function Arrow() {
        return Arrow.__super__.constructor.apply(this, arguments);
    }
    Arrow.prototype.default_view = exports.ArrowView;
    Arrow.prototype.type = 'Arrow';
    Arrow.mixins(['line']);
    Arrow.define({
        x_start: [p.NumberSpec],
        y_start: [p.NumberSpec],
        start_units: [
            p.String,
            'data'
        ],
        start: [
            p.Instance,
            null
        ],
        x_end: [p.NumberSpec],
        y_end: [p.NumberSpec],
        end_units: [
            p.String,
            'data'
        ],
        end: [
            p.Instance,
            new arrow_head_1.OpenHead({})
        ],
        source: [p.Instance],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    return Arrow;
}(annotation_1.Annotation);    
},
/* models/annotations/arrow_head */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var visuals_1 = require(44    /* core/visuals */);
var p = require(13    /* core/properties */);
exports.ArrowHead = function (superClass) {
    extend(ArrowHead, superClass);
    function ArrowHead() {
        return ArrowHead.__super__.constructor.apply(this, arguments);
    }
    ArrowHead.prototype.type = 'ArrowHead';
    ArrowHead.prototype.initialize = function (options) {
        ArrowHead.__super__.initialize.call(this, options);
        return this.visuals = new visuals_1.Visuals(this);
    };
    ArrowHead.prototype.render = function (ctx, i) {
        return null;
    };
    ArrowHead.prototype.clip = function (ctx, i) {
        return null;
    };
    return ArrowHead;
}(annotation_1.Annotation);
exports.OpenHead = function (superClass) {
    extend(OpenHead, superClass);
    function OpenHead() {
        return OpenHead.__super__.constructor.apply(this, arguments);
    }
    OpenHead.prototype.type = 'OpenHead';
    OpenHead.prototype.clip = function (ctx, i) {
        this.visuals.line.set_vectorize(ctx, i);
        ctx.moveTo(0.5 * this.size, this.size);
        ctx.lineTo(0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, this.size);
        ctx.lineTo(0, 0);
        return ctx.lineTo(0.5 * this.size, this.size);
    };
    OpenHead.prototype.render = function (ctx, i) {
        if (this.visuals.line.doit) {
            this.visuals.line.set_vectorize(ctx, i);
            ctx.beginPath();
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0, 0);
            ctx.lineTo(-0.5 * this.size, this.size);
            return ctx.stroke();
        }
    };
    OpenHead.mixins(['line']);
    OpenHead.define({
        size: [
            p.Number,
            25
        ]
    });
    return OpenHead;
}(exports.ArrowHead);
exports.NormalHead = function (superClass) {
    extend(NormalHead, superClass);
    function NormalHead() {
        return NormalHead.__super__.constructor.apply(this, arguments);
    }
    NormalHead.prototype.type = 'NormalHead';
    NormalHead.prototype.clip = function (ctx, i) {
        this.visuals.line.set_vectorize(ctx, i);
        ctx.moveTo(0.5 * this.size, this.size);
        ctx.lineTo(0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, this.size);
        return ctx.lineTo(0.5 * this.size, this.size);
    };
    NormalHead.prototype.render = function (ctx, i) {
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_vectorize(ctx, i);
            this._normal(ctx, i);
            ctx.fill();
        }
        if (this.visuals.line.doit) {
            this.visuals.line.set_vectorize(ctx, i);
            this._normal(ctx, i);
            return ctx.stroke();
        }
    };
    NormalHead.prototype._normal = function (ctx, i) {
        ctx.beginPath();
        ctx.moveTo(0.5 * this.size, this.size);
        ctx.lineTo(0, 0);
        ctx.lineTo(-0.5 * this.size, this.size);
        return ctx.closePath();
    };
    NormalHead.mixins([
        'line',
        'fill'
    ]);
    NormalHead.define({
        size: [
            p.Number,
            25
        ]
    });
    NormalHead.override({ fill_color: 'black' });
    return NormalHead;
}(exports.ArrowHead);
exports.VeeHead = function (superClass) {
    extend(VeeHead, superClass);
    function VeeHead() {
        return VeeHead.__super__.constructor.apply(this, arguments);
    }
    VeeHead.prototype.type = 'VeeHead';
    VeeHead.prototype.clip = function (ctx, i) {
        this.visuals.line.set_vectorize(ctx, i);
        ctx.moveTo(0.5 * this.size, this.size);
        ctx.lineTo(0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, -2);
        ctx.lineTo(-0.5 * this.size, this.size);
        ctx.lineTo(0, 0.5 * this.size);
        return ctx.lineTo(0.5 * this.size, this.size);
    };
    VeeHead.prototype.render = function (ctx, i) {
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_vectorize(ctx, i);
            this._vee(ctx, i);
            ctx.fill();
        }
        if (this.visuals.line.doit) {
            this.visuals.line.set_vectorize(ctx, i);
            this._vee(ctx, i);
            return ctx.stroke();
        }
    };
    VeeHead.prototype._vee = function (ctx, i) {
        ctx.beginPath();
        ctx.moveTo(0.5 * this.size, this.size);
        ctx.lineTo(0, 0);
        ctx.lineTo(-0.5 * this.size, this.size);
        ctx.lineTo(0, 0.5 * this.size);
        return ctx.closePath();
    };
    VeeHead.mixins([
        'line',
        'fill'
    ]);
    VeeHead.define({
        size: [
            p.Number,
            25
        ]
    });
    VeeHead.override({ fill_color: 'black' });
    return VeeHead;
}(exports.ArrowHead);
exports.TeeHead = function (superClass) {
    extend(TeeHead, superClass);
    function TeeHead() {
        return TeeHead.__super__.constructor.apply(this, arguments);
    }
    TeeHead.prototype.type = 'TeeHead';
    TeeHead.prototype.render = function (ctx, i) {
        if (this.visuals.line.doit) {
            this.visuals.line.set_vectorize(ctx, i);
            ctx.beginPath();
            ctx.moveTo(0.5 * this.size, 0);
            ctx.lineTo(-0.5 * this.size, 0);
            return ctx.stroke();
        }
    };
    TeeHead.mixins(['line']);
    TeeHead.define({
        size: [
            p.Number,
            25
        ]
    });
    return TeeHead;
}(exports.ArrowHead);    
},
/* models/annotations/band */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var column_data_source_1 = require(168    /* ../sources/column_data_source */);
var p = require(13    /* core/properties */);
exports.BandView = function (superClass) {
    extend(BandView, superClass);
    function BandView() {
        return BandView.__super__.constructor.apply(this, arguments);
    }
    BandView.prototype.initialize = function (options) {
        BandView.__super__.initialize.call(this, options);
        return this.set_data(this.model.source);
    };
    BandView.prototype.connect_signals = function () {
        BandView.__super__.connect_signals.call(this);
        this.connect(this.model.source.streaming, function () {
            return this.set_data(this.model.source);
        });
        this.connect(this.model.source.patching, function () {
            return this.set_data(this.model.source);
        });
        return this.connect(this.model.source.change, function () {
            return this.set_data(this.model.source);
        });
    };
    BandView.prototype.set_data = function (source) {
        BandView.__super__.set_data.call(this, source);
        this.visuals.warm_cache(source);
        return this.plot_view.request_render();
    };
    BandView.prototype._map_data = function () {
        var _base_vx, _lower, _lower_vx, _upper, _upper_vx, base_scale, i, j, limit_scale, ref, x_scale, y_scale;
        x_scale = this.plot_view.frame.xscales[this.model.x_range_name];
        y_scale = this.plot_view.frame.yscales[this.model.y_range_name];
        limit_scale = this.model.dimension === 'height' ? y_scale : x_scale;
        base_scale = this.model.dimension === 'height' ? x_scale : y_scale;
        if (this.model.lower.units === 'data') {
            _lower_vx = limit_scale.v_compute(this._lower);
        } else {
            _lower_vx = this._lower;
        }
        if (this.model.upper.units === 'data') {
            _upper_vx = limit_scale.v_compute(this._upper);
        } else {
            _upper_vx = this._upper;
        }
        if (this.model.base.units === 'data') {
            _base_vx = base_scale.v_compute(this._base);
        } else {
            _base_vx = this._base;
        }
        ref = this.model._normals(), i = ref[0], j = ref[1];
        _lower = [
            _lower_vx,
            _base_vx
        ];
        _upper = [
            _upper_vx,
            _base_vx
        ];
        this._lower_sx = this.plot_model.canvas.v_vx_to_sx(_lower[i]);
        this._lower_sy = this.plot_model.canvas.v_vy_to_sy(_lower[j]);
        this._upper_sx = this.plot_model.canvas.v_vx_to_sx(_upper[i]);
        return this._upper_sy = this.plot_model.canvas.v_vy_to_sy(_upper[j]);
    };
    BandView.prototype.render = function () {
        var ctx, i, k, l, m, n, ref, ref1, ref2, ref3;
        if (!this.model.visible) {
            return;
        }
        this._map_data();
        ctx = this.plot_view.canvas_view.ctx;
        ctx.beginPath();
        ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
        for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);
        }
        for (i = l = ref1 = this._upper_sx.length - 1; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {
            ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
        }
        ctx.closePath();
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_value(ctx);
            ctx.fill();
        }
        ctx.beginPath();
        ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
        for (i = m = 0, ref2 = this._lower_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
            ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);
        }
        if (this.visuals.line.doit) {
            this.visuals.line.set_value(ctx);
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);
        for (i = n = 0, ref3 = this._upper_sx.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
            ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
        }
        if (this.visuals.line.doit) {
            this.visuals.line.set_value(ctx);
            return ctx.stroke();
        }
    };
    return BandView;
}(annotation_1.AnnotationView);
exports.Band = function (superClass) {
    extend(Band, superClass);
    function Band() {
        return Band.__super__.constructor.apply(this, arguments);
    }
    Band.prototype.default_view = exports.BandView;
    Band.prototype.type = 'Band';
    Band.mixins([
        'line',
        'fill'
    ]);
    Band.define({
        lower: [p.DistanceSpec],
        upper: [p.DistanceSpec],
        base: [p.DistanceSpec],
        dimension: [
            p.Dimension,
            'height'
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Band.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });
    Band.prototype._normals = function () {
        var i, j, ref, ref1;
        if (this.dimension === 'height') {
            ref = [
                1,
                0
            ], i = ref[0], j = ref[1];
        } else {
            ref1 = [
                0,
                1
            ], i = ref1[0], j = ref1[1];
        }
        return [
            i,
            j
        ];
    };
    return Band;
}(annotation_1.Annotation);    
},
/* models/annotations/box_annotation */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var signaling_1 = require(18    /* core/signaling */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.BoxAnnotationView = function (superClass) {
    extend(BoxAnnotationView, superClass);
    function BoxAnnotationView() {
        return BoxAnnotationView.__super__.constructor.apply(this, arguments);
    }
    BoxAnnotationView.prototype.initialize = function (options) {
        BoxAnnotationView.__super__.initialize.call(this, options);
        this.plot_view.canvas_overlays.appendChild(this.el);
        this.el.classList.add('bk-shading');
        return dom_1.hide(this.el);
    };
    BoxAnnotationView.prototype.connect_signals = function () {
        BoxAnnotationView.__super__.connect_signals.call(this);
        if (this.model.render_mode === 'css') {
            this.connect(this.model.change, function () {
                return this.render();
            });
            return this.connect(this.model.data_update, function () {
                return this.render();
            });
        } else {
            this.connect(this.model.change, function (_this) {
                return function () {
                    return _this.plot_view.request_render();
                };
            }(this));
            return this.connect(this.model.data_update, function (_this) {
                return function () {
                    return _this.plot_view.request_render();
                };
            }(this));
        }
    };
    BoxAnnotationView.prototype.render = function () {
        var canvas, frame, sbottom, sleft, sright, stop, xscale, yscale;
        if (!this.model.visible && this.model.render_mode === 'css') {
            dom_1.hide(this.el);
        }
        if (!this.model.visible) {
            return;
        }
        if (this.model.left == null && this.model.right == null && this.model.top == null && this.model.bottom == null) {
            dom_1.hide(this.el);
            return null;
        }
        frame = this.plot_model.frame;
        canvas = this.plot_model.canvas;
        xscale = this.plot_view.frame.xscales[this.model.x_range_name];
        yscale = this.plot_view.frame.yscales[this.model.y_range_name];
        sleft = canvas.vx_to_sx(this._calc_dim(this.model.left, this.model.left_units, xscale, frame.h_range.start));
        sright = canvas.vx_to_sx(this._calc_dim(this.model.right, this.model.right_units, xscale, frame.h_range.end));
        sbottom = canvas.vy_to_sy(this._calc_dim(this.model.bottom, this.model.bottom_units, yscale, frame.v_range.start));
        stop = canvas.vy_to_sy(this._calc_dim(this.model.top, this.model.top_units, yscale, frame.v_range.end));
        if (this.model.render_mode === 'css') {
            return this._css_box(sleft, sright, sbottom, stop);
        } else {
            return this._canvas_box(sleft, sright, sbottom, stop);
        }
    };
    BoxAnnotationView.prototype._css_box = function (sleft, sright, sbottom, stop) {
        var ld, sh, sw;
        sw = Math.abs(sright - sleft);
        sh = Math.abs(sbottom - stop);
        this.el.style.left = sleft + 'px';
        this.el.style.width = sw + 'px';
        this.el.style.top = stop + 'px';
        this.el.style.height = sh + 'px';
        this.el.style.borderWidth = this.model.line_width.value + 'px';
        this.el.style.borderColor = this.model.line_color.value;
        this.el.style.backgroundColor = this.model.fill_color.value;
        this.el.style.opacity = this.model.fill_alpha.value;
        ld = this.model.line_dash;
        if (types_1.isArray(ld)) {
            ld = ld.length < 2 ? 'solid' : 'dashed';
        }
        if (types_1.isString(ld)) {
            this.el.style.borderStyle = ld;
        }
        return dom_1.show(this.el);
    };
    BoxAnnotationView.prototype._canvas_box = function (sleft, sright, sbottom, stop) {
        var ctx;
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        ctx.beginPath();
        ctx.rect(sleft, stop, sright - sleft, sbottom - stop);
        this.visuals.fill.set_value(ctx);
        ctx.fill();
        this.visuals.line.set_value(ctx);
        ctx.stroke();
        return ctx.restore();
    };
    BoxAnnotationView.prototype._calc_dim = function (dim, dim_units, scale, frame_extrema) {
        var vdim;
        if (dim != null) {
            if (dim_units === 'data') {
                vdim = scale.compute(dim);
            } else {
                vdim = dim;
            }
        } else {
            vdim = frame_extrema;
        }
        return vdim;
    };
    return BoxAnnotationView;
}(annotation_1.AnnotationView);
exports.BoxAnnotation = function (superClass) {
    extend(BoxAnnotation, superClass);
    function BoxAnnotation() {
        return BoxAnnotation.__super__.constructor.apply(this, arguments);
    }
    BoxAnnotation.prototype.default_view = exports.BoxAnnotationView;
    BoxAnnotation.prototype.type = 'BoxAnnotation';
    BoxAnnotation.mixins([
        'line',
        'fill'
    ]);
    BoxAnnotation.define({
        render_mode: [
            p.RenderMode,
            'canvas'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        top: [
            p.Number,
            null
        ],
        top_units: [
            p.SpatialUnits,
            'data'
        ],
        bottom: [
            p.Number,
            null
        ],
        bottom_units: [
            p.SpatialUnits,
            'data'
        ],
        left: [
            p.Number,
            null
        ],
        left_units: [
            p.SpatialUnits,
            'data'
        ],
        right: [
            p.Number,
            null
        ],
        right_units: [
            p.SpatialUnits,
            'data'
        ]
    });
    BoxAnnotation.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });
    BoxAnnotation.prototype.initialize = function (attrs, options) {
        BoxAnnotation.__super__.initialize.call(this, attrs, options);
        return this.data_update = new signaling_1.Signal(this, 'data_update');
    };
    BoxAnnotation.prototype.update = function (arg) {
        var bottom, left, right, top;
        left = arg.left, right = arg.right, top = arg.top, bottom = arg.bottom;
        this.setv({
            left: left,
            right: right,
            top: top,
            bottom: bottom
        }, { silent: true });
        return this.data_update.emit();
    };
    return BoxAnnotation;
}(annotation_1.Annotation);    
},
/* models/annotations/color_bar */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var LONG_DIM_MAX_SCALAR, LONG_DIM_MIN_SCALAR, SHORT_DIM, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var basic_ticker_1 = require(175    /* ../tickers/basic_ticker */);
var basic_tick_formatter_1 = require(88    /* ../formatters/basic_tick_formatter */);
var linear_color_mapper_1 = require(141    /* ../mappers/linear_color_mapper */);
var linear_scale_1 = require(163    /* ../scales/linear_scale */);
var log_scale_1 = require(164    /* ../scales/log_scale */);
var range1d_1 = require(155    /* ../ranges/range1d */);
var p = require(13    /* core/properties */);
var text_util = require(38    /* core/util/text */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
var types_1 = require(40    /* core/util/types */);
SHORT_DIM = 25;
LONG_DIM_MIN_SCALAR = 0.3;
LONG_DIM_MAX_SCALAR = 0.8;
exports.ColorBarView = function (superClass) {
    extend(ColorBarView, superClass);
    function ColorBarView() {
        return ColorBarView.__super__.constructor.apply(this, arguments);
    }
    ColorBarView.prototype.initialize = function (options) {
        ColorBarView.__super__.initialize.call(this, options);
        return this._set_canvas_image();
    };
    ColorBarView.prototype.connect_signals = function () {
        ColorBarView.__super__.connect_signals.call(this);
        this.connect(this.model.properties.visible.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
        this.connect(this.model.ticker.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
        this.connect(this.model.formatter.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
        if (this.model.color_mapper != null) {
            return this.connect(this.model.color_mapper.change, function () {
                this._set_canvas_image();
                return this.plot_view.request_render();
            });
        }
    };
    ColorBarView.prototype._get_panel_offset = function () {
        var x, y;
        x = this.model.panel._left.value;
        y = this.model.panel._top.value;
        return {
            x: x,
            y: -y
        };
    };
    ColorBarView.prototype._get_size = function () {
        var bbox, side;
        if (this.model.color_mapper == null) {
            return;
        }
        bbox = this.compute_legend_dimensions();
        side = this.model.panel.side;
        if (side === 'above' || side === 'below') {
            return bbox.height;
        }
        if (side === 'left' || side === 'right') {
            return bbox.width;
        }
    };
    ColorBarView.prototype._set_canvas_image = function () {
        var buf, buf8, canvas, cmap, h, image_ctx, image_data, k, palette, ref, ref1, ref2, ref3, results, w;
        if (this.model.color_mapper == null) {
            return;
        }
        palette = this.model.color_mapper.palette;
        if (this.model.orientation === 'vertical') {
            palette = palette.slice(0).reverse();
        }
        switch (this.model.orientation) {
        case 'vertical':
            ref = [
                1,
                palette.length
            ], w = ref[0], h = ref[1];
            break;
        case 'horizontal':
            ref1 = [
                palette.length,
                1
            ], w = ref1[0], h = ref1[1];
        }
        canvas = document.createElement('canvas');
        ref2 = [
            w,
            h
        ], canvas.width = ref2[0], canvas.height = ref2[1];
        image_ctx = canvas.getContext('2d');
        image_data = image_ctx.getImageData(0, 0, w, h);
        cmap = new linear_color_mapper_1.LinearColorMapper({ palette: palette });
        buf = cmap.v_map_screen(function () {
            results = [];
            for (var k = 0, ref3 = palette.length; 0 <= ref3 ? k < ref3 : k > ref3; 0 <= ref3 ? k++ : k--) {
                results.push(k);
            }
            return results;
        }.apply(this));
        buf8 = new Uint8Array(buf);
        image_data.data.set(buf8);
        image_ctx.putImageData(image_data, 0, 0);
        return this.image = canvas;
    };
    ColorBarView.prototype.compute_legend_dimensions = function () {
        var image_dimensions, image_height, image_width, label_extent, legend_height, legend_width, padding, ref, tick_extent, title_extent;
        image_dimensions = this.model._computed_image_dimensions();
        ref = [
            image_dimensions.height,
            image_dimensions.width
        ], image_height = ref[0], image_width = ref[1];
        label_extent = this._get_label_extent();
        title_extent = this.model._title_extent();
        tick_extent = this.model._tick_extent();
        padding = this.model.padding;
        switch (this.model.orientation) {
        case 'vertical':
            legend_height = image_height + title_extent + padding * 2;
            legend_width = image_width + tick_extent + label_extent + padding * 2;
            break;
        case 'horizontal':
            legend_height = image_height + title_extent + tick_extent + label_extent + padding * 2;
            legend_width = image_width + padding * 2;
        }
        return {
            height: legend_height,
            width: legend_width
        };
    };
    ColorBarView.prototype.compute_legend_location = function () {
        var h_range, legend_dimensions, legend_height, legend_margin, legend_width, location, ref, sx, sy, v_range, x, y;
        legend_dimensions = this.compute_legend_dimensions();
        ref = [
            legend_dimensions.height,
            legend_dimensions.width
        ], legend_height = ref[0], legend_width = ref[1];
        legend_margin = this.model.margin;
        location = this.model.location;
        h_range = this.plot_view.frame.h_range;
        v_range = this.plot_view.frame.v_range;
        if (types_1.isString(location)) {
            switch (location) {
            case 'top_left':
                x = h_range.start + legend_margin;
                y = v_range.end - legend_margin;
                break;
            case 'top_center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = v_range.end - legend_margin;
                break;
            case 'top_right':
                x = h_range.end - legend_margin - legend_width;
                y = v_range.end - legend_margin;
                break;
            case 'center_right':
                x = h_range.end - legend_margin - legend_width;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
                break;
            case 'bottom_right':
                x = h_range.end - legend_margin - legend_width;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'bottom_center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'bottom_left':
                x = h_range.start + legend_margin;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'center_left':
                x = h_range.start + legend_margin;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
                break;
            case 'center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
            }
        } else if (types_1.isArray(location) && location.length === 2) {
            x = location[0], y = location[1];
        }
        sx = this.plot_view.canvas.vx_to_sx(x);
        sy = this.plot_view.canvas.vy_to_sy(y);
        return {
            sx: sx,
            sy: sy
        };
    };
    ColorBarView.prototype.render = function () {
        var ctx, frame_offset, image_offset, location, panel_offset, tick_info;
        if (!this.model.visible || this.model.color_mapper == null) {
            return;
        }
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        if (this.model.panel != null) {
            panel_offset = this._get_panel_offset();
            ctx.translate(panel_offset.x, panel_offset.y);
            frame_offset = this._get_frame_offset();
            ctx.translate(frame_offset.x, frame_offset.y);
        }
        location = this.compute_legend_location();
        ctx.translate(location.sx, location.sy);
        this._draw_bbox(ctx);
        image_offset = this._get_image_offset();
        ctx.translate(image_offset.x, image_offset.y);
        this._draw_image(ctx);
        if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) {
            tick_info = this.model.tick_info();
            this._draw_major_ticks(ctx, tick_info);
            this._draw_minor_ticks(ctx, tick_info);
            this._draw_major_labels(ctx, tick_info);
        }
        if (this.model.title) {
            this._draw_title(ctx);
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_bbox = function (ctx) {
        var bbox;
        bbox = this.compute_legend_dimensions();
        ctx.save();
        if (this.visuals.background_fill.doit) {
            this.visuals.background_fill.set_value(ctx);
            ctx.fillRect(0, 0, bbox.width, bbox.height);
        }
        if (this.visuals.border_line.doit) {
            this.visuals.border_line.set_value(ctx);
            ctx.strokeRect(0, 0, bbox.width, bbox.height);
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_image = function (ctx) {
        var image;
        image = this.model._computed_image_dimensions();
        ctx.save();
        ctx.setImageSmoothingEnabled(false);
        ctx.globalAlpha = this.model.scale_alpha;
        ctx.drawImage(this.image, 0, 0, image.width, image.height);
        if (this.visuals.bar_line.doit) {
            this.visuals.bar_line.set_value(ctx);
            ctx.strokeRect(0, 0, image.width, image.height);
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_major_ticks = function (ctx, tick_info) {
        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;
        if (!this.visuals.major_tick_line.doit) {
            return;
        }
        ref = this.model._normals(), nx = ref[0], ny = ref[1];
        image = this.model._computed_image_dimensions();
        ref1 = [
            image.width * nx,
            image.height * ny
        ], x_offset = ref1[0], y_offset = ref1[1];
        ref2 = tick_info.coords.major, sx = ref2[0], sy = ref2[1];
        tin = this.model.major_tick_in;
        tout = this.model.major_tick_out;
        ctx.save();
        ctx.translate(x_offset, y_offset);
        this.visuals.major_tick_line.set_value(ctx);
        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
            ctx.beginPath();
            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));
            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));
            ctx.stroke();
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_minor_ticks = function (ctx, tick_info) {
        var i, image, k, nx, ny, ref, ref1, ref2, ref3, sx, sy, tin, tout, x_offset, y_offset;
        if (!this.visuals.minor_tick_line.doit) {
            return;
        }
        ref = this.model._normals(), nx = ref[0], ny = ref[1];
        image = this.model._computed_image_dimensions();
        ref1 = [
            image.width * nx,
            image.height * ny
        ], x_offset = ref1[0], y_offset = ref1[1];
        ref2 = tick_info.coords.minor, sx = ref2[0], sy = ref2[1];
        tin = this.model.minor_tick_in;
        tout = this.model.minor_tick_out;
        ctx.save();
        ctx.translate(x_offset, y_offset);
        this.visuals.minor_tick_line.set_value(ctx);
        for (i = k = 0, ref3 = sx.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
            ctx.beginPath();
            ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));
            ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));
            ctx.stroke();
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_major_labels = function (ctx, tick_info) {
        var formatted_labels, i, image, k, nx, ny, ref, ref1, ref2, ref3, ref4, standoff, sx, sy, x_offset, x_standoff, y_offset, y_standoff;
        if (!this.visuals.major_label_text.doit) {
            return;
        }
        ref = this.model._normals(), nx = ref[0], ny = ref[1];
        image = this.model._computed_image_dimensions();
        ref1 = [
            image.width * nx,
            image.height * ny
        ], x_offset = ref1[0], y_offset = ref1[1];
        standoff = this.model.label_standoff + this.model._tick_extent();
        ref2 = [
            standoff * nx,
            standoff * ny
        ], x_standoff = ref2[0], y_standoff = ref2[1];
        ref3 = tick_info.coords.major, sx = ref3[0], sy = ref3[1];
        formatted_labels = tick_info.labels.major;
        this.visuals.major_label_text.set_value(ctx);
        ctx.save();
        ctx.translate(x_offset + x_standoff, y_offset + y_standoff);
        for (i = k = 0, ref4 = sx.length; 0 <= ref4 ? k < ref4 : k > ref4; i = 0 <= ref4 ? ++k : --k) {
            ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));
        }
        return ctx.restore();
    };
    ColorBarView.prototype._draw_title = function (ctx) {
        if (!this.visuals.title_text.doit) {
            return;
        }
        ctx.save();
        this.visuals.title_text.set_value(ctx);
        ctx.fillText(this.model.title, 0, -this.model.title_standoff);
        return ctx.restore();
    };
    ColorBarView.prototype._get_label_extent = function () {
        var ctx, label, label_extent, major_labels;
        major_labels = this.model.tick_info().labels.major;
        if (this.model.color_mapper.low != null && this.model.color_mapper.high != null && !object_1.isEmpty(major_labels)) {
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            this.visuals.major_label_text.set_value(ctx);
            switch (this.model.orientation) {
            case 'vertical':
                label_extent = array_1.max(function () {
                    var k, len, results;
                    results = [];
                    for (k = 0, len = major_labels.length; k < len; k++) {
                        label = major_labels[k];
                        results.push(ctx.measureText(label.toString()).width);
                    }
                    return results;
                }());
                break;
            case 'horizontal':
                label_extent = text_util.get_text_height(this.visuals.major_label_text.font_value()).height;
            }
            label_extent += this.model.label_standoff;
            ctx.restore();
        } else {
            label_extent = 0;
        }
        return label_extent;
    };
    ColorBarView.prototype._get_frame_offset = function () {
        var frame, panel, ref, xoff, yoff;
        ref = [
            0,
            0
        ], xoff = ref[0], yoff = ref[1];
        panel = this.model.panel;
        frame = this.plot_view.frame;
        switch (panel.side) {
        case 'left':
        case 'right':
            yoff = Math.abs(panel._top.value - frame._top.value);
            break;
        case 'above':
        case 'below':
            xoff = Math.abs(frame._left.value);
        }
        return {
            x: xoff,
            y: yoff
        };
    };
    ColorBarView.prototype._get_image_offset = function () {
        var x, y;
        x = this.model.padding;
        y = this.model.padding + this.model._title_extent();
        return {
            x: x,
            y: y
        };
    };
    return ColorBarView;
}(annotation_1.AnnotationView);
exports.ColorBar = function (superClass) {
    extend(ColorBar, superClass);
    function ColorBar() {
        return ColorBar.__super__.constructor.apply(this, arguments);
    }
    ColorBar.prototype.default_view = exports.ColorBarView;
    ColorBar.prototype.type = 'ColorBar';
    ColorBar.mixins([
        'text:major_label_',
        'text:title_',
        'line:major_tick_',
        'line:minor_tick_',
        'line:border_',
        'line:bar_',
        'fill:background_'
    ]);
    ColorBar.define({
        location: [
            p.Any,
            'top_right'
        ],
        orientation: [
            p.Orientation,
            'vertical'
        ],
        title: [p.String],
        title_standoff: [
            p.Number,
            2
        ],
        height: [
            p.Any,
            'auto'
        ],
        width: [
            p.Any,
            'auto'
        ],
        scale_alpha: [
            p.Number,
            1
        ],
        ticker: [
            p.Instance,
            function () {
                return new basic_ticker_1.BasicTicker();
            }
        ],
        formatter: [
            p.Instance,
            function () {
                return new basic_tick_formatter_1.BasicTickFormatter();
            }
        ],
        major_label_overrides: [
            p.Any,
            {}
        ],
        color_mapper: [p.Instance],
        label_standoff: [
            p.Number,
            5
        ],
        margin: [
            p.Number,
            30
        ],
        padding: [
            p.Number,
            10
        ],
        major_tick_in: [
            p.Number,
            5
        ],
        major_tick_out: [
            p.Number,
            0
        ],
        minor_tick_in: [
            p.Number,
            0
        ],
        minor_tick_out: [
            p.Number,
            0
        ]
    });
    ColorBar.override({
        background_fill_color: '#ffffff',
        background_fill_alpha: 0.95,
        bar_line_color: null,
        border_line_color: null,
        major_label_text_align: 'center',
        major_label_text_baseline: 'middle',
        major_label_text_font_size: '8pt',
        major_tick_line_color: '#ffffff',
        minor_tick_line_color: null,
        title_text_font_size: '10pt',
        title_text_font_style: 'italic'
    });
    ColorBar.prototype.initialize = function (attrs, options) {
        return ColorBar.__super__.initialize.call(this, attrs, options);
    };
    ColorBar.prototype._normals = function () {
        var i, j, ref, ref1;
        if (this.orientation === 'vertical') {
            ref = [
                1,
                0
            ], i = ref[0], j = ref[1];
        } else {
            ref1 = [
                0,
                1
            ], i = ref1[0], j = ref1[1];
        }
        return [
            i,
            j
        ];
    };
    ColorBar.prototype._title_extent = function () {
        var font_value, title_extent;
        font_value = this.title_text_font + ' ' + this.title_text_font_size + ' ' + this.title_text_font_style;
        title_extent = this.title ? text_util.get_text_height(font_value).height + this.title_standoff : 0;
        return title_extent;
    };
    ColorBar.prototype._tick_extent = function () {
        var tick_extent;
        if (this.color_mapper.low != null && this.color_mapper.high != null) {
            tick_extent = array_1.max([
                this.major_tick_out,
                this.minor_tick_out
            ]);
        } else {
            tick_extent = 0;
        }
        return tick_extent;
    };
    ColorBar.prototype._computed_image_dimensions = function () {
        /*
        Heuristics to determine ColorBar image dimensions if set to "auto"
        
        Note: Returns the height/width values for the ColorBar's scale image, not
        the dimensions of the entire ColorBar.
        
        If the short dimension (the width of a vertical bar or height of a
        horizontal bar) is set to "auto", the resulting dimension will be set to
        25 px.
        
        For a ColorBar in a side panel with the long dimension (the height of a
        vertical bar or width of a horizontal bar) set to "auto", the
        resulting dimension will be as long as the adjacent frame edge, so that the
        bar "fits" to the plot.
        
        For a ColorBar in the plot frame with the long dimension set to "auto", the
        resulting dimension will be the greater of:
          * The length of the color palette * 25px
          * The parallel frame dimension * 0.30
            (i.e the frame height for a vertical ColorBar)
        But not greater than:
          * The parallel frame dimension * 0.80
         */
        var frame_height, frame_width, height, title_extent, width;
        frame_height = this.plot.plot_canvas.frame._height.value;
        frame_width = this.plot.plot_canvas.frame._width.value;
        title_extent = this._title_extent();
        switch (this.orientation) {
        case 'vertical':
            if (this.height === 'auto') {
                if (this.panel != null) {
                    height = frame_height - 2 * this.padding - title_extent;
                } else {
                    height = array_1.max([
                        this.color_mapper.palette.length * SHORT_DIM,
                        frame_height * LONG_DIM_MIN_SCALAR
                    ]);
                    height = array_1.min([
                        height,
                        frame_height * LONG_DIM_MAX_SCALAR - 2 * this.padding - title_extent
                    ]);
                }
            } else {
                height = this.height;
            }
            width = this.width === 'auto' ? SHORT_DIM : this.width;
            break;
        case 'horizontal':
            height = this.height === 'auto' ? SHORT_DIM : this.height;
            if (this.width === 'auto') {
                if (this.panel != null) {
                    width = frame_width - 2 * this.padding;
                } else {
                    width = array_1.max([
                        this.color_mapper.palette.length * SHORT_DIM,
                        frame_width * LONG_DIM_MIN_SCALAR
                    ]);
                    width = array_1.min([
                        width,
                        frame_width * LONG_DIM_MAX_SCALAR - 2 * this.padding
                    ]);
                }
            } else {
                width = this.width;
            }
        }
        return {
            'height': height,
            'width': width
        };
    };
    ColorBar.prototype._tick_coordinate_scale = function (scale_length) {
        /*
        Creates and returns a scale instance that maps the `color_mapper` range
        (low to high) to a screen space range equal to the length of the ColorBar's
        scale image. The scale is used to calculate the tick coordinates in screen
        coordinates for plotting purposes.
        
        Note: the type of color_mapper has to match the type of scale (i.e.
        a LinearColorMapper will require a corresponding LinearScale instance).
         */
        var ranges, scale;
        ranges = {
            'source_range': new range1d_1.Range1d({
                start: this.color_mapper.low,
                end: this.color_mapper.high
            }),
            'target_range': new range1d_1.Range1d({
                start: 0,
                end: scale_length
            })
        };
        switch (this.color_mapper.type) {
        case 'LinearColorMapper':
            scale = new linear_scale_1.LinearScale(ranges);
            break;
        case 'LogColorMapper':
            scale = new log_scale_1.LogScale(ranges);
        }
        return scale;
    };
    ColorBar.prototype._format_major_labels = function (initial_labels, major_ticks) {
        var formatted_labels, i, k, labels, ref;
        labels = initial_labels;
        formatted_labels = this.formatter.doFormat(labels, null);
        for (i = k = 0, ref = major_ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (major_ticks[i] in this.major_label_overrides) {
                formatted_labels[i] = this.major_label_overrides[major_ticks[i]];
            }
        }
        return formatted_labels;
    };
    ColorBar.prototype.tick_info = function () {
        var coord, coords, end, i, ii, image_dimensions, j, k, l, labels, major_coords, majors, minor_coords, minors, ref, ref1, ref2, ref3, scale, scale_length, start, ticks;
        image_dimensions = this._computed_image_dimensions();
        switch (this.orientation) {
        case 'vertical':
            scale_length = image_dimensions.height;
            break;
        case 'horizontal':
            scale_length = image_dimensions.width;
        }
        scale = this._tick_coordinate_scale(scale_length);
        ref = this._normals(), i = ref[0], j = ref[1];
        ref1 = [
            this.color_mapper.low,
            this.color_mapper.high
        ], start = ref1[0], end = ref1[1];
        ticks = this.ticker.get_ticks(start, end, null, null, this.ticker.desired_num_ticks);
        coords = {
            major: [
                [],
                []
            ],
            minor: [
                [],
                []
            ]
        };
        majors = ticks.major;
        minors = ticks.minor;
        major_coords = coords.major;
        minor_coords = coords.minor;
        for (ii = k = 0, ref2 = majors.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {
            if (majors[ii] < start || majors[ii] > end) {
                continue;
            }
            major_coords[i].push(majors[ii]);
            major_coords[j].push(0);
        }
        for (ii = l = 0, ref3 = minors.length; 0 <= ref3 ? l < ref3 : l > ref3; ii = 0 <= ref3 ? ++l : --l) {
            if (minors[ii] < start || minors[ii] > end) {
                continue;
            }
            minor_coords[i].push(minors[ii]);
            minor_coords[j].push(0);
        }
        labels = { major: this._format_major_labels(major_coords[i].slice(0), majors) };
        major_coords[i] = scale.v_compute(major_coords[i]);
        minor_coords[i] = scale.v_compute(minor_coords[i]);
        if (this.orientation === 'vertical') {
            major_coords[i] = new Float64Array(function () {
                var len, m, ref4, results;
                ref4 = major_coords[i];
                results = [];
                for (m = 0, len = ref4.length; m < len; m++) {
                    coord = ref4[m];
                    results.push(scale_length - coord);
                }
                return results;
            }());
            minor_coords[i] = new Float64Array(function () {
                var len, m, ref4, results;
                ref4 = minor_coords[i];
                results = [];
                for (m = 0, len = ref4.length; m < len; m++) {
                    coord = ref4[m];
                    results.push(scale_length - coord);
                }
                return results;
            }());
        }
        return {
            'ticks': ticks,
            'coords': coords,
            'labels': labels
        };
    };
    return ColorBar;
}(annotation_1.Annotation);    
},
/* models/annotations/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var annotation_1 = require(49    /* ./annotation */);
exports.Annotation = annotation_1.Annotation;
var arrow_1 = require(50    /* ./arrow */);
exports.Arrow = arrow_1.Arrow;
var arrow_head_1 = require(51    /* ./arrow_head */);
exports.ArrowHead = arrow_head_1.ArrowHead;
var arrow_head_2 = require(51    /* ./arrow_head */);
exports.OpenHead = arrow_head_2.OpenHead;
var arrow_head_3 = require(51    /* ./arrow_head */);
exports.NormalHead = arrow_head_3.NormalHead;
var arrow_head_4 = require(51    /* ./arrow_head */);
exports.TeeHead = arrow_head_4.TeeHead;
var arrow_head_5 = require(51    /* ./arrow_head */);
exports.VeeHead = arrow_head_5.VeeHead;
var band_1 = require(52    /* ./band */);
exports.Band = band_1.Band;
var box_annotation_1 = require(53    /* ./box_annotation */);
exports.BoxAnnotation = box_annotation_1.BoxAnnotation;
var color_bar_1 = require(54    /* ./color_bar */);
exports.ColorBar = color_bar_1.ColorBar;
var label_1 = require(56    /* ./label */);
exports.Label = label_1.Label;
var label_set_1 = require(57    /* ./label_set */);
exports.LabelSet = label_set_1.LabelSet;
var legend_1 = require(58    /* ./legend */);
exports.Legend = legend_1.Legend;
var legend_item_1 = require(59    /* ./legend_item */);
exports.LegendItem = legend_item_1.LegendItem;
var poly_annotation_1 = require(60    /* ./poly_annotation */);
exports.PolyAnnotation = poly_annotation_1.PolyAnnotation;
var span_1 = require(61    /* ./span */);
exports.Span = span_1.Span;
var text_annotation_1 = require(62    /* ./text_annotation */);
exports.TextAnnotation = text_annotation_1.TextAnnotation;
var title_1 = require(63    /* ./title */);
exports.Title = title_1.Title;
var tooltip_1 = require(64    /* ./tooltip */);
exports.Tooltip = tooltip_1.Tooltip;
var whisker_1 = require(65    /* ./whisker */);
exports.Whisker = whisker_1.Whisker;    
},
/* models/annotations/label */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var text_annotation_1 = require(62    /* ./text_annotation */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
exports.LabelView = function (superClass) {
    extend(LabelView, superClass);
    function LabelView() {
        return LabelView.__super__.constructor.apply(this, arguments);
    }
    LabelView.prototype.initialize = function (options) {
        LabelView.__super__.initialize.call(this, options);
        this.canvas = this.plot_model.canvas;
        return this.visuals.warm_cache(null);
    };
    LabelView.prototype._get_size = function () {
        var ctx, height, width;
        ctx = this.plot_view.canvas_view.ctx;
        this.visuals.text.set_value(ctx);
        if (this.model.panel.is_horizontal) {
            height = ctx.measureText(this.model.text).ascent;
            return height;
        } else {
            width = ctx.measureText(this.model.text).width;
            return width;
        }
    };
    LabelView.prototype.render = function () {
        var angle, ctx, panel, ref, sx, sy, vx, vy, xscale, yscale;
        if (!this.model.visible && this.model.render_mode === 'css') {
            dom_1.hide(this.el);
        }
        if (!this.model.visible) {
            return;
        }
        xscale = this.plot_view.frame.xscales[this.model.x_range_name];
        yscale = this.plot_view.frame.yscales[this.model.y_range_name];
        ctx = this.plot_view.canvas_view.ctx;
        switch (this.model.angle_units) {
        case 'rad':
            angle = -1 * this.model.angle;
            break;
        case 'deg':
            angle = -1 * this.model.angle * Math.PI / 180;
        }
        panel = (ref = this.model.panel) != null ? ref : this.plot_view.frame;
        if (this.model.x_units === 'data') {
            vx = xscale.compute(this.model.x);
        } else {
            vx = this.model.x + panel._left.value;
        }
        if (this.model.y_units === 'data') {
            vy = yscale.compute(this.model.y);
        } else {
            vy = this.model.y + panel._bottom.value;
        }
        sx = this.canvas.vx_to_sx(vx);
        sy = this.canvas.vy_to_sy(vy);
        if (this.model.render_mode === 'canvas') {
            return this._canvas_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);
        } else {
            return this._css_text(ctx, this.model.text, sx + this.model.x_offset, sy - this.model.y_offset, angle);
        }
    };
    return LabelView;
}(text_annotation_1.TextAnnotationView);
exports.Label = function (superClass) {
    extend(Label, superClass);
    function Label() {
        return Label.__super__.constructor.apply(this, arguments);
    }
    Label.prototype.default_view = exports.LabelView;
    Label.prototype.type = 'Label';
    Label.mixins([
        'text',
        'line:border_',
        'fill:background_'
    ]);
    Label.define({
        x: [p.Number],
        x_units: [
            p.SpatialUnits,
            'data'
        ],
        y: [p.Number],
        y_units: [
            p.SpatialUnits,
            'data'
        ],
        text: [p.String],
        angle: [
            p.Angle,
            0
        ],
        angle_units: [
            p.AngleUnits,
            'rad'
        ],
        x_offset: [
            p.Number,
            0
        ],
        y_offset: [
            p.Number,
            0
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    Label.override({
        background_fill_color: null,
        border_line_color: null
    });
    return Label;
}(text_annotation_1.TextAnnotation);    
},
/* models/annotations/label_set */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var text_annotation_1 = require(62    /* ./text_annotation */);
var column_data_source_1 = require(168    /* ../sources/column_data_source */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.LabelSetView = function (superClass) {
    extend(LabelSetView, superClass);
    function LabelSetView() {
        return LabelSetView.__super__.constructor.apply(this, arguments);
    }
    LabelSetView.prototype.initialize = function (options) {
        var i, j, ref, results;
        LabelSetView.__super__.initialize.call(this, options);
        this.set_data(this.model.source);
        if (this.model.render_mode === 'css') {
            results = [];
            for (i = j = 0, ref = this._text.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.title_div = dom_1.div({
                    'class': 'bk-annotation-child',
                    style: { display: 'none' }
                });
                results.push(this.el.appendChild(this.title_div));
            }
            return results;
        }
    };
    LabelSetView.prototype.connect_signals = function () {
        LabelSetView.__super__.connect_signals.call(this);
        if (this.model.render_mode === 'css') {
            this.connect(this.model.change, function () {
                this.set_data(this.model.source);
                return this.render();
            });
            this.connect(this.model.source.streaming, function () {
                this.set_data(this.model.source);
                return this.render();
            });
            this.connect(this.model.source.patching, function () {
                this.set_data(this.model.source);
                return this.render();
            });
            return this.connect(this.model.source.change, function () {
                this.set_data(this.model.source);
                return this.render();
            });
        } else {
            this.connect(this.model.change, function () {
                this.set_data(this.model.source);
                return this.plot_view.request_render();
            });
            this.connect(this.model.source.streaming, function () {
                this.set_data(this.model.source);
                return this.plot_view.request_render();
            });
            this.connect(this.model.source.patching, function () {
                this.set_data(this.model.source);
                return this.plot_view.request_render();
            });
            return this.connect(this.model.source.change, function () {
                this.set_data(this.model.source);
                return this.plot_view.request_render();
            });
        }
    };
    LabelSetView.prototype.set_data = function (source) {
        LabelSetView.__super__.set_data.call(this, source);
        return this.visuals.warm_cache(source);
    };
    LabelSetView.prototype._map_data = function () {
        var sx, sy, vx, vy, xscale, yscale;
        xscale = this.plot_view.frame.xscales[this.model.x_range_name];
        yscale = this.plot_view.frame.yscales[this.model.y_range_name];
        if (this.model.x_units === 'data') {
            vx = xscale.v_compute(this._x);
        } else {
            vx = this._x.slice(0);
        }
        sx = this.canvas.v_vx_to_sx(vx);
        if (this.model.y_units === 'data') {
            vy = yscale.v_compute(this._y);
        } else {
            vy = this._y.slice(0);
        }
        sy = this.canvas.v_vy_to_sy(vy);
        return [
            sx,
            sy
        ];
    };
    LabelSetView.prototype.render = function () {
        var ctx, i, j, k, ref, ref1, ref2, results, results1, sx, sy;
        if (!this.model.visible && this.model.render_mode === 'css') {
            dom_1.hide(this.el);
        }
        if (!this.model.visible) {
            return;
        }
        ctx = this.plot_view.canvas_view.ctx;
        ref = this._map_data(), sx = ref[0], sy = ref[1];
        if (this.model.render_mode === 'canvas') {
            results = [];
            for (i = j = 0, ref1 = this._text.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                results.push(this._v_canvas_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));
            }
            return results;
        } else {
            results1 = [];
            for (i = k = 0, ref2 = this._text.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
                results1.push(this._v_css_text(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));
            }
            return results1;
        }
    };
    LabelSetView.prototype._get_size = function () {
        var ctx, height, side, width;
        ctx = this.plot_view.canvas_view.ctx;
        this.visuals.text.set_value(ctx);
        side = this.model.panel.side;
        if (side === 'above' || side === 'below') {
            height = ctx.measureText(this._text[0]).ascent;
            return height;
        }
        if (side === 'left' || side === 'right') {
            width = ctx.measureText(this._text[0]).width;
            return width;
        }
    };
    LabelSetView.prototype._v_canvas_text = function (ctx, i, text, sx, sy, angle) {
        var bbox_dims;
        this.visuals.text.set_vectorize(ctx, i);
        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
        ctx.save();
        ctx.beginPath();
        ctx.translate(sx, sy);
        ctx.rotate(angle);
        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);
        if (this.visuals.background_fill.doit) {
            this.visuals.background_fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (this.visuals.border_line.doit) {
            this.visuals.border_line.set_vectorize(ctx, i);
            ctx.stroke();
        }
        if (this.visuals.text.doit) {
            this.visuals.text.set_vectorize(ctx, i);
            ctx.fillText(text, 0, 0);
        }
        return ctx.restore();
    };
    LabelSetView.prototype._v_css_text = function (ctx, i, text, sx, sy, angle) {
        var bbox_dims, el, ld, line_dash;
        el = this.el.childNodes[i];
        el.textContent = text;
        this.visuals.text.set_vectorize(ctx, i);
        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
        ld = this.visuals.border_line.line_dash.value();
        if (types_1.isArray(ld)) {
            line_dash = ld.length < 2 ? 'solid' : 'dashed';
        }
        if (types_1.isString(ld)) {
            line_dash = ld;
        }
        this.visuals.border_line.set_vectorize(ctx, i);
        this.visuals.background_fill.set_vectorize(ctx, i);
        el.style.position = 'absolute';
        el.style.left = sx + bbox_dims[0] + 'px';
        el.style.top = sy + bbox_dims[1] + 'px';
        el.style.color = '' + this.visuals.text.text_color.value();
        el.style.opacity = '' + this.visuals.text.text_alpha.value();
        el.style.font = '' + this.visuals.text.font_value();
        el.style.lineHeight = 'normal';
        if (angle) {
            el.style.transform = 'rotate(' + angle + 'rad)';
        }
        if (this.visuals.background_fill.doit) {
            el.style.backgroundColor = '' + this.visuals.background_fill.color_value();
        }
        if (this.visuals.border_line.doit) {
            el.style.borderStyle = '' + line_dash;
            el.style.borderWidth = this.visuals.border_line.line_width.value() + 'px';
            el.style.borderColor = '' + this.visuals.border_line.color_value();
        }
        return dom_1.show(el);
    };
    return LabelSetView;
}(text_annotation_1.TextAnnotationView);
exports.LabelSet = function (superClass) {
    extend(LabelSet, superClass);
    function LabelSet() {
        return LabelSet.__super__.constructor.apply(this, arguments);
    }
    LabelSet.prototype.default_view = exports.LabelSetView;
    LabelSet.prototype.type = 'Label';
    LabelSet.mixins([
        'text',
        'line:border_',
        'fill:background_'
    ]);
    LabelSet.define({
        x: [p.NumberSpec],
        y: [p.NumberSpec],
        x_units: [
            p.SpatialUnits,
            'data'
        ],
        y_units: [
            p.SpatialUnits,
            'data'
        ],
        text: [
            p.StringSpec,
            { field: 'text' }
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        x_offset: [
            p.NumberSpec,
            { value: 0 }
        ],
        y_offset: [
            p.NumberSpec,
            { value: 0 }
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    LabelSet.override({
        background_fill_color: null,
        border_line_color: null
    });
    return LabelSet;
}(text_annotation_1.TextAnnotation);    
},
/* models/annotations/legend */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var p = require(13    /* core/properties */);
var text_1 = require(38    /* core/util/text */);
var bbox_1 = require(21    /* core/util/bbox */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
var types_1 = require(40    /* core/util/types */);
exports.LegendView = function (superClass) {
    extend(LegendView, superClass);
    function LegendView() {
        return LegendView.__super__.constructor.apply(this, arguments);
    }
    LegendView.prototype.initialize = function (options) {
        return LegendView.__super__.initialize.call(this, options);
    };
    LegendView.prototype.connect_signals = function () {
        LegendView.__super__.connect_signals.call(this);
        return this.connect(this.model.properties.visible.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
    };
    LegendView.prototype.compute_legend_bbox = function () {
        var ctx, glyph_height, glyph_width, h_range, i, label_height, label_standoff, label_width, legend_height, legend_margin, legend_names, legend_padding, legend_spacing, legend_width, len, location, max_label_width, name, panel, ref, ref1, ref2, v_range, width, x, y;
        legend_names = this.model.get_legend_names();
        glyph_height = this.model.glyph_height;
        glyph_width = this.model.glyph_width;
        label_height = this.model.label_height;
        label_width = this.model.label_width;
        this.max_label_height = array_1.max([
            text_1.get_text_height(this.visuals.label_text.font_value()).height,
            label_height,
            glyph_height
        ]);
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        this.visuals.label_text.set_value(ctx);
        this.text_widths = {};
        for (i = 0, len = legend_names.length; i < len; i++) {
            name = legend_names[i];
            this.text_widths[name] = array_1.max([
                ctx.measureText(name).width,
                label_width
            ]);
        }
        ctx.restore();
        max_label_width = array_1.max(object_1.values(this.text_widths));
        legend_margin = this.model.margin;
        legend_padding = this.model.padding;
        legend_spacing = this.model.spacing;
        label_standoff = this.model.label_standoff;
        if (this.model.orientation === 'vertical') {
            legend_height = legend_names.length * this.max_label_height + (legend_names.length - 1) * legend_spacing + 2 * legend_padding;
            legend_width = max_label_width + glyph_width + label_standoff + 2 * legend_padding;
        } else {
            legend_width = 2 * legend_padding + (legend_names.length - 1) * legend_spacing;
            ref = this.text_widths;
            for (name in ref) {
                width = ref[name];
                legend_width += array_1.max([
                    width,
                    label_width
                ]) + glyph_width + label_standoff;
            }
            legend_height = this.max_label_height + 2 * legend_padding;
        }
        panel = (ref1 = this.model.panel) != null ? ref1 : this.plot_view.frame;
        h_range = {
            start: panel._left.value,
            end: panel._right.value
        };
        v_range = {
            start: panel._bottom.value,
            end: panel._top.value
        };
        location = this.model.location;
        if (types_1.isString(location)) {
            switch (location) {
            case 'top_left':
                x = h_range.start + legend_margin;
                y = v_range.end - legend_margin;
                break;
            case 'top_center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = v_range.end - legend_margin;
                break;
            case 'top_right':
                x = h_range.end - legend_margin - legend_width;
                y = v_range.end - legend_margin;
                break;
            case 'center_right':
                x = h_range.end - legend_margin - legend_width;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
                break;
            case 'bottom_right':
                x = h_range.end - legend_margin - legend_width;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'bottom_center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'bottom_left':
                x = h_range.start + legend_margin;
                y = v_range.start + legend_margin + legend_height;
                break;
            case 'center_left':
                x = h_range.start + legend_margin;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
                break;
            case 'center':
                x = (h_range.end + h_range.start) / 2 - legend_width / 2;
                y = (v_range.end + v_range.start) / 2 + legend_height / 2;
            }
        } else if (types_1.isArray(location) && location.length === 2) {
            x = location[0], y = location[1];
            if ((ref2 = panel.side) === 'left' || ref2 === 'right' || ref2 === 'above' || ref2 === 'below') {
                x += h_range.start;
                y += v_range.end;
            } else {
                x += h_range.start;
                y += v_range.start;
            }
        }
        x = this.plot_view.canvas.vx_to_sx(x);
        y = this.plot_view.canvas.vy_to_sy(y);
        return {
            x: x,
            y: y,
            width: legend_width,
            height: legend_height
        };
    };
    LegendView.prototype.bbox = function () {
        var height, ref, width, x, y;
        ref = this.compute_legend_bbox(), x = ref.x, y = ref.y, width = ref.width, height = ref.height;
        return new bbox_1.BBox({
            x0: x,
            y0: y,
            x1: x + width,
            y1: y + height
        });
    };
    LegendView.prototype.on_hit = function (sx, sy) {
        var bbox, field, glyph_height, glyph_width, h, i, item, j, k, l, label, label_standoff, labels, legend_bbox, legend_spacing, len, len1, len2, len3, r, ref, ref1, ref2, ref3, ref4, vertical, w, x1, x2, xoffset, y1, y2, yoffset;
        glyph_height = this.model.glyph_height;
        glyph_width = this.model.glyph_width;
        legend_spacing = this.model.spacing;
        label_standoff = this.model.label_standoff;
        xoffset = yoffset = this.model.padding;
        legend_bbox = this.compute_legend_bbox();
        vertical = this.model.orientation === 'vertical';
        ref = this.model.items;
        for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            labels = item.get_labels_list_from_label_prop();
            field = item.get_field_from_label_prop();
            for (j = 0, len1 = labels.length; j < len1; j++) {
                label = labels[j];
                x1 = legend_bbox.x + xoffset;
                y1 = legend_bbox.y + yoffset;
                x2 = x1 + glyph_width;
                y2 = y1 + glyph_height;
                if (vertical) {
                    ref1 = [
                        legend_bbox.width - 2 * this.model.padding,
                        this.max_label_height
                    ], w = ref1[0], h = ref1[1];
                } else {
                    ref2 = [
                        this.text_widths[label] + glyph_width + label_standoff,
                        this.max_label_height
                    ], w = ref2[0], h = ref2[1];
                }
                bbox = new bbox_1.BBox({
                    x0: x1,
                    y0: y1,
                    x1: x1 + w,
                    y1: y1 + h
                });
                if (bbox.contains(sx, sy)) {
                    switch (this.model.click_policy) {
                    case 'hide':
                        ref3 = item.renderers;
                        for (k = 0, len2 = ref3.length; k < len2; k++) {
                            r = ref3[k];
                            r.visible = !r.visible;
                        }
                        break;
                    case 'mute':
                        ref4 = item.renderers;
                        for (l = 0, len3 = ref4.length; l < len3; l++) {
                            r = ref4[l];
                            r.muted = !r.muted;
                        }
                    }
                    return true;
                }
                if (vertical) {
                    yoffset += this.max_label_height + legend_spacing;
                } else {
                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;
                }
            }
        }
        return false;
    };
    LegendView.prototype.render = function () {
        var bbox, ctx;
        if (!this.model.visible) {
            return;
        }
        if (this.model.items.length === 0) {
            return;
        }
        ctx = this.plot_view.canvas_view.ctx;
        bbox = this.compute_legend_bbox();
        ctx.save();
        this._draw_legend_box(ctx, bbox);
        this._draw_legend_items(ctx, bbox);
        return ctx.restore();
    };
    LegendView.prototype._draw_legend_box = function (ctx, bbox) {
        ctx.beginPath();
        ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);
        this.visuals.background_fill.set_value(ctx);
        ctx.fill();
        if (this.visuals.border_line.doit) {
            this.visuals.border_line.set_value(ctx);
            return ctx.stroke();
        }
    };
    LegendView.prototype._draw_legend_items = function (ctx, bbox) {
        var active, field, glyph_height, glyph_width, h, i, item, j, k, label, label_standoff, labels, legend_spacing, len, len1, len2, r, ref, ref1, ref2, ref3, vertical, view, w, x1, x2, xoffset, y1, y2, yoffset;
        glyph_height = this.model.glyph_height;
        glyph_width = this.model.glyph_width;
        legend_spacing = this.model.spacing;
        label_standoff = this.model.label_standoff;
        xoffset = yoffset = this.model.padding;
        vertical = this.model.orientation === 'vertical';
        ref = this.model.items;
        for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            labels = item.get_labels_list_from_label_prop();
            field = item.get_field_from_label_prop();
            if (labels.length === 0) {
                continue;
            }
            active = function () {
                switch (this.model.click_policy) {
                case 'none':
                    return true;
                case 'hide':
                    return array_1.all(item.renderers, function (r) {
                        return r.visible;
                    });
                case 'mute':
                    return array_1.all(item.renderers, function (r) {
                        return !r.muted;
                    });
                }
            }.call(this);
            for (j = 0, len1 = labels.length; j < len1; j++) {
                label = labels[j];
                x1 = bbox.x + xoffset;
                y1 = bbox.y + yoffset;
                x2 = x1 + glyph_width;
                y2 = y1 + glyph_height;
                if (vertical) {
                    yoffset += this.max_label_height + legend_spacing;
                } else {
                    xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;
                }
                this.visuals.label_text.set_value(ctx);
                ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2);
                ref1 = item.renderers;
                for (k = 0, len2 = ref1.length; k < len2; k++) {
                    r = ref1[k];
                    view = this.plot_view.renderer_views[r.id];
                    view.draw_legend(ctx, x1, x2, y1, y2, field, label);
                }
                if (!active) {
                    if (vertical) {
                        ref2 = [
                            bbox.width - 2 * this.model.padding,
                            this.max_label_height
                        ], w = ref2[0], h = ref2[1];
                    } else {
                        ref3 = [
                            this.text_widths[label] + glyph_width + label_standoff,
                            this.max_label_height
                        ], w = ref3[0], h = ref3[1];
                    }
                    ctx.beginPath();
                    ctx.rect(x1, y1, w, h);
                    this.visuals.inactive_fill.set_value(ctx);
                    ctx.fill();
                }
            }
        }
        return null;
    };
    LegendView.prototype._get_size = function () {
        var bbox, side;
        bbox = this.compute_legend_bbox();
        side = this.model.panel.side;
        if (side === 'above' || side === 'below') {
            return bbox.height;
        }
        if (side === 'left' || side === 'right') {
            return bbox.width;
        }
    };
    return LegendView;
}(annotation_1.AnnotationView);
exports.Legend = function (superClass) {
    extend(Legend, superClass);
    function Legend() {
        return Legend.__super__.constructor.apply(this, arguments);
    }
    Legend.prototype.default_view = exports.LegendView;
    Legend.prototype.type = 'Legend';
    Legend.prototype.cursor = function () {
        if (this.click_policy === 'none') {
            return null;
        } else {
            return 'pointer';
        }
    };
    Legend.prototype.get_legend_names = function () {
        var i, item, labels, legend_names, len, ref;
        legend_names = [];
        ref = this.items;
        for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            labels = item.get_labels_list_from_label_prop();
            legend_names = legend_names.concat(labels);
        }
        return legend_names;
    };
    Legend.mixins([
        'text:label_',
        'fill:inactive_',
        'line:border_',
        'fill:background_'
    ]);
    Legend.define({
        orientation: [
            p.Orientation,
            'vertical'
        ],
        location: [
            p.Any,
            'top_right'
        ],
        label_standoff: [
            p.Number,
            5
        ],
        glyph_height: [
            p.Number,
            20
        ],
        glyph_width: [
            p.Number,
            20
        ],
        label_height: [
            p.Number,
            20
        ],
        label_width: [
            p.Number,
            20
        ],
        margin: [
            p.Number,
            10
        ],
        padding: [
            p.Number,
            10
        ],
        spacing: [
            p.Number,
            3
        ],
        items: [
            p.Array,
            []
        ],
        click_policy: [
            p.Any,
            'none'
        ]
    });
    Legend.override({
        border_line_color: '#e5e5e5',
        border_line_alpha: 0.5,
        border_line_width: 1,
        background_fill_color: '#ffffff',
        background_fill_alpha: 0.95,
        inactive_fill_color: 'white',
        inactive_fill_alpha: 0.9,
        label_text_font_size: '10pt',
        label_text_baseline: 'middle'
    });
    return Legend;
}(annotation_1.Annotation);    
},
/* models/annotations/legend_item */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    }, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var model_1 = require(48    /* ../../model */);
var p = require(13    /* core/properties */);
var logging_1 = require(12    /* core/logging */);
var array_1 = require(20    /* core/util/array */);
var column_data_source_1 = require(168    /* ../../models/sources/column_data_source */);
exports.LegendItem = function (superClass) {
    extend(LegendItem, superClass);
    function LegendItem() {
        this.get_labels_list_from_label_prop = bind(this.get_labels_list_from_label_prop, this);
        this.get_field_from_label_prop = bind(this.get_field_from_label_prop, this);
        return LegendItem.__super__.constructor.apply(this, arguments);
    }
    LegendItem.prototype.type = 'LegendItem';
    LegendItem.prototype._check_data_sources_on_renderers = function () {
        var field, i, len, r, ref, source;
        field = this.get_field_from_label_prop();
        if (field != null) {
            if (this.renderers.length < 1) {
                return false;
            }
            source = this.renderers[0].data_source;
            if (source != null) {
                ref = this.renderers;
                for (i = 0, len = ref.length; i < len; i++) {
                    r = ref[i];
                    if (r.data_source !== source) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    LegendItem.prototype._check_field_label_on_data_source = function () {
        var field, source;
        field = this.get_field_from_label_prop();
        if (field != null) {
            if (this.renderers.length < 1) {
                return false;
            }
            source = this.renderers[0].data_source;
            if (source != null && indexOf.call(source.columns(), field) < 0) {
                return false;
            }
        }
        return true;
    };
    LegendItem.prototype.initialize = function (attrs, options) {
        var data_source_validation, field_validation;
        LegendItem.__super__.initialize.call(this, attrs, options);
        data_source_validation = this._check_data_sources_on_renderers();
        if (!data_source_validation) {
            logging_1.logger.error('Non matching data sources on legend item renderers');
        }
        field_validation = this._check_field_label_on_data_source();
        if (!field_validation) {
            return logging_1.logger.error('Bad column name on label: ' + this.label);
        }
    };
    LegendItem.define({
        label: [
            p.StringSpec,
            null
        ],
        renderers: [
            p.Array,
            []
        ]
    });
    LegendItem.prototype.get_field_from_label_prop = function () {
        if (this.label != null && this.label.field != null) {
            return this.label.field;
        }
    };
    LegendItem.prototype.get_labels_list_from_label_prop = function () {
        var data, field, source;
        if (this.label != null && this.label.value != null) {
            return [this.label.value];
        }
        field = this.get_field_from_label_prop();
        if (field != null) {
            if (this.renderers[0] && this.renderers[0].data_source != null) {
                source = this.renderers[0].data_source;
            } else {
                return ['No source found'];
            }
            if (source instanceof column_data_source_1.ColumnDataSource) {
                data = source.get_column(field);
                if (data != null) {
                    return array_1.uniq(data);
                } else {
                    return ['Invalid field'];
                }
            }
        }
        return [];
    };
    return LegendItem;
}(model_1.Model);    
},
/* models/annotations/poly_annotation */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var signaling_1 = require(18    /* core/signaling */);
var p = require(13    /* core/properties */);
exports.PolyAnnotationView = function (superClass) {
    extend(PolyAnnotationView, superClass);
    function PolyAnnotationView() {
        return PolyAnnotationView.__super__.constructor.apply(this, arguments);
    }
    PolyAnnotationView.prototype.connect_signals = function () {
        PolyAnnotationView.__super__.connect_signals.call(this);
        this.connect(this.model.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
        return this.connect(this.model.data_update, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
    };
    PolyAnnotationView.prototype.render = function (ctx) {
        var canvas, i, j, ref, sx, sy, vx, vy, xs, ys;
        if (!this.model.visible) {
            return;
        }
        xs = this.model.xs;
        ys = this.model.ys;
        if (xs.length !== ys.length) {
            return null;
        }
        if (xs.length < 3 || ys.length < 3) {
            return null;
        }
        canvas = this.plot_view.canvas;
        ctx = this.plot_view.canvas_view.ctx;
        for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (this.model.xs_units === 'screen') {
                vx = xs[i];
            }
            if (this.model.ys_units === 'screen') {
                vy = ys[i];
            }
            sx = canvas.vx_to_sx(vx);
            sy = canvas.vy_to_sy(vy);
            if (i === 0) {
                ctx.beginPath();
                ctx.moveTo(sx, sy);
            } else {
                ctx.lineTo(sx, sy);
            }
        }
        ctx.closePath();
        if (this.visuals.line.doit) {
            this.visuals.line.set_value(ctx);
            ctx.stroke();
        }
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_value(ctx);
            return ctx.fill();
        }
    };
    return PolyAnnotationView;
}(annotation_1.AnnotationView);
exports.PolyAnnotation = function (superClass) {
    extend(PolyAnnotation, superClass);
    function PolyAnnotation() {
        return PolyAnnotation.__super__.constructor.apply(this, arguments);
    }
    PolyAnnotation.prototype.default_view = exports.PolyAnnotationView;
    PolyAnnotation.prototype.type = 'PolyAnnotation';
    PolyAnnotation.mixins([
        'line',
        'fill'
    ]);
    PolyAnnotation.define({
        xs: [
            p.Array,
            []
        ],
        xs_units: [
            p.SpatialUnits,
            'data'
        ],
        ys: [
            p.Array,
            []
        ],
        ys_units: [
            p.SpatialUnits,
            'data'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    PolyAnnotation.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });
    PolyAnnotation.prototype.initialize = function (attrs, options) {
        PolyAnnotation.__super__.initialize.call(this, attrs, options);
        return this.data_update = new signaling_1.Signal(this, 'data_update');
    };
    PolyAnnotation.prototype.update = function (arg) {
        var xs, ys;
        xs = arg.xs, ys = arg.ys;
        this.setv({
            xs: xs,
            ys: ys
        }, { silent: true });
        return this.data_update.emit();
    };
    return PolyAnnotation;
}(annotation_1.Annotation);    
},
/* models/annotations/span */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
exports.SpanView = function (superClass) {
    extend(SpanView, superClass);
    function SpanView() {
        return SpanView.__super__.constructor.apply(this, arguments);
    }
    SpanView.prototype.initialize = function (options) {
        SpanView.__super__.initialize.call(this, options);
        this.plot_view.canvas_overlays.appendChild(this.el);
        this.el.style.position = 'absolute';
        return dom_1.hide(this.el);
    };
    SpanView.prototype.connect_signals = function () {
        SpanView.__super__.connect_signals.call(this);
        if (this.model.for_hover) {
            return this.connect(this.model.properties.computed_location.change, function () {
                return this._draw_span();
            });
        } else {
            if (this.model.render_mode === 'canvas') {
                this.connect(this.model.change, function (_this) {
                    return function () {
                        return _this.plot_view.request_render();
                    };
                }(this));
                return this.connect(this.model.properties.location.change, function (_this) {
                    return function () {
                        return _this.plot_view.request_render();
                    };
                }(this));
            } else {
                this.connect(this.model.change, function () {
                    return this.render();
                });
                return this.connect(this.model.properties.location.change, function () {
                    return this._draw_span();
                });
            }
        }
    };
    SpanView.prototype.render = function () {
        if (!this.model.visible && this.model.render_mode === 'css') {
            dom_1.hide(this.el);
        }
        if (!this.model.visible) {
            return;
        }
        return this._draw_span();
    };
    SpanView.prototype._draw_span = function () {
        var canvas, ctx, frame, height, loc, sleft, stop, width, xscale, yscale;
        if (this.model.for_hover) {
            loc = this.model.computed_location;
        } else {
            loc = this.model.location;
        }
        if (loc == null) {
            dom_1.hide(this.el);
            return;
        }
        frame = this.plot_model.frame;
        canvas = this.plot_model.canvas;
        xscale = this.plot_view.frame.xscales[this.model.x_range_name];
        yscale = this.plot_view.frame.yscales[this.model.y_range_name];
        if (this.model.dimension === 'width') {
            stop = canvas.vy_to_sy(this._calc_dim(loc, yscale));
            sleft = canvas.vx_to_sx(frame._left.value);
            width = frame._width.value;
            height = this.model.properties.line_width.value();
        } else {
            stop = canvas.vy_to_sy(frame._top.value);
            sleft = canvas.vx_to_sx(this._calc_dim(loc, xscale));
            width = this.model.properties.line_width.value();
            height = frame._height.value;
        }
        if (this.model.render_mode === 'css') {
            this.el.style.top = stop + 'px';
            this.el.style.left = sleft + 'px';
            this.el.style.width = width + 'px';
            this.el.style.height = height + 'px';
            this.el.style.zIndex = 1000;
            this.el.style.backgroundColor = this.model.properties.line_color.value();
            this.el.style.opacity = this.model.properties.line_alpha.value();
            return dom_1.show(this.el);
        } else if (this.model.render_mode === 'canvas') {
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            ctx.beginPath();
            this.visuals.line.set_value(ctx);
            ctx.moveTo(sleft, stop);
            if (this.model.dimension === 'width') {
                ctx.lineTo(sleft + width, stop);
            } else {
                ctx.lineTo(sleft, stop + height);
            }
            ctx.stroke();
            return ctx.restore();
        }
    };
    SpanView.prototype._calc_dim = function (location, scale) {
        var vdim;
        if (this.model.location_units === 'data') {
            vdim = scale.compute(location);
        } else {
            vdim = location;
        }
        return vdim;
    };
    return SpanView;
}(annotation_1.AnnotationView);
exports.Span = function (superClass) {
    extend(Span, superClass);
    function Span() {
        return Span.__super__.constructor.apply(this, arguments);
    }
    Span.prototype.default_view = exports.SpanView;
    Span.prototype.type = 'Span';
    Span.mixins(['line']);
    Span.define({
        render_mode: [
            p.RenderMode,
            'canvas'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        location: [
            p.Number,
            null
        ],
        location_units: [
            p.SpatialUnits,
            'data'
        ],
        dimension: [
            p.Dimension,
            'width'
        ]
    });
    Span.override({ line_color: 'black' });
    Span.internal({
        for_hover: [
            p.Boolean,
            false
        ],
        computed_location: [
            p.Number,
            null
        ]
    });
    return Span;
}(annotation_1.Annotation);    
},
/* models/annotations/text_annotation */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var dom_1 = require(4    /* core/dom */);
var types_1 = require(40    /* core/util/types */);
var text_1 = require(38    /* core/util/text */);
exports.TextAnnotationView = function (superClass) {
    extend(TextAnnotationView, superClass);
    function TextAnnotationView() {
        return TextAnnotationView.__super__.constructor.apply(this, arguments);
    }
    TextAnnotationView.prototype.initialize = function (options) {
        TextAnnotationView.__super__.initialize.call(this, options);
        this.canvas = this.plot_model.canvas;
        this.frame = this.plot_model.frame;
        if (this.model.render_mode === 'css') {
            this.el.classList.add('bk-annotation');
            return this.plot_view.canvas_overlays.appendChild(this.el);
        }
    };
    TextAnnotationView.prototype.connect_signals = function () {
        TextAnnotationView.__super__.connect_signals.call(this);
        if (this.model.render_mode === 'css') {
            return this.connect(this.model.change, function () {
                return this.render();
            });
        } else {
            return this.connect(this.model.change, function (_this) {
                return function () {
                    return _this.plot_view.request_render();
                };
            }(this));
        }
    };
    TextAnnotationView.prototype._calculate_text_dimensions = function (ctx, text) {
        var height, width;
        width = ctx.measureText(text).width;
        height = text_1.get_text_height(this.visuals.text.font_value()).height;
        return [
            width,
            height
        ];
    };
    TextAnnotationView.prototype._calculate_bounding_box_dimensions = function (ctx, text) {
        var height, ref, width, x_offset, y_offset;
        ref = this._calculate_text_dimensions(ctx, text), width = ref[0], height = ref[1];
        switch (ctx.textAlign) {
        case 'left':
            x_offset = 0;
            break;
        case 'center':
            x_offset = -width / 2;
            break;
        case 'right':
            x_offset = -width;
        }
        switch (ctx.textBaseline) {
        case 'top':
            y_offset = 0;
            break;
        case 'middle':
            y_offset = -0.5 * height;
            break;
        case 'bottom':
            y_offset = -1 * height;
            break;
        case 'alphabetic':
            y_offset = -0.8 * height;
            break;
        case 'hanging':
            y_offset = -0.17 * height;
            break;
        case 'ideographic':
            y_offset = -0.83 * height;
        }
        return [
            x_offset,
            y_offset,
            width,
            height
        ];
    };
    TextAnnotationView.prototype._get_size = function () {
        var ctx;
        ctx = this.plot_view.canvas_view.ctx;
        this.visuals.text.set_value(ctx);
        return ctx.measureText(this.model.text).ascent;
    };
    TextAnnotationView.prototype.render = function () {
        return null;
    };
    TextAnnotationView.prototype._canvas_text = function (ctx, text, sx, sy, angle) {
        var bbox_dims;
        this.visuals.text.set_value(ctx);
        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
        ctx.save();
        ctx.beginPath();
        ctx.translate(sx, sy);
        if (angle) {
            ctx.rotate(angle);
        }
        ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);
        if (this.visuals.background_fill.doit) {
            this.visuals.background_fill.set_value(ctx);
            ctx.fill();
        }
        if (this.visuals.border_line.doit) {
            this.visuals.border_line.set_value(ctx);
            ctx.stroke();
        }
        if (this.visuals.text.doit) {
            this.visuals.text.set_value(ctx);
            ctx.fillText(text, 0, 0);
        }
        return ctx.restore();
    };
    TextAnnotationView.prototype._css_text = function (ctx, text, sx, sy, angle) {
        var bbox_dims, ld, line_dash;
        dom_1.hide(this.el);
        this.visuals.text.set_value(ctx);
        bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
        ld = this.visuals.border_line.line_dash.value();
        if (types_1.isArray(ld)) {
            if (ld.length < 2) {
                line_dash = 'solid';
            } else {
                line_dash = 'dashed';
            }
        }
        if (types_1.isString(ld)) {
            line_dash = ld;
        }
        this.visuals.border_line.set_value(ctx);
        this.visuals.background_fill.set_value(ctx);
        this.el.style.position = 'absolute';
        this.el.style.left = sx + bbox_dims[0] + 'px';
        this.el.style.top = sy + bbox_dims[1] + 'px';
        this.el.style.color = '' + this.visuals.text.text_color.value();
        this.el.style.opacity = '' + this.visuals.text.text_alpha.value();
        this.el.style.font = '' + this.visuals.text.font_value();
        this.el.style.lineHeight = 'normal';
        if (angle) {
            this.el.style.transform = 'rotate(' + angle + 'rad)';
        }
        if (this.visuals.background_fill.doit) {
            this.el.style.backgroundColor = '' + this.visuals.background_fill.color_value();
        }
        if (this.visuals.border_line.doit) {
            this.el.style.borderStyle = '' + line_dash;
            this.el.style.borderWidth = this.visuals.border_line.line_width.value() + 'px';
            this.el.style.borderColor = '' + this.visuals.border_line.color_value();
        }
        this.el.textContent = text;
        return dom_1.show(this.el);
    };
    return TextAnnotationView;
}(annotation_1.AnnotationView);
exports.TextAnnotation = function (superClass) {
    extend(TextAnnotation, superClass);
    function TextAnnotation() {
        return TextAnnotation.__super__.constructor.apply(this, arguments);
    }
    TextAnnotation.prototype.type = 'TextAnnotation';
    TextAnnotation.prototype.default_view = exports.TextAnnotationView;
    return TextAnnotation;
}(annotation_1.Annotation);    
},
/* models/annotations/title */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var text_annotation_1 = require(62    /* ./text_annotation */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var Visuals = require(44    /* core/visuals */);
exports.TitleView = function (superClass) {
    extend(TitleView, superClass);
    function TitleView() {
        return TitleView.__super__.constructor.apply(this, arguments);
    }
    TitleView.prototype.initialize = function (options) {
        var ctx;
        TitleView.__super__.initialize.call(this, options);
        this.visuals.text = new Visuals.Text(this.model);
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        this.model.panel.apply_label_text_heuristics(ctx, 'justified');
        this.model.text_baseline = ctx.textBaseline;
        this.model.text_align = this.model.align;
        return ctx.restore();
    };
    TitleView.prototype._get_computed_location = function () {
        var height, ref, sx, sy, vx, vy, width;
        ref = this._calculate_text_dimensions(this.plot_view.canvas_view.ctx, this.text), width = ref[0], height = ref[1];
        switch (this.model.panel.side) {
        case 'left':
            vx = this.model.panel._left.value;
            vy = this._get_text_location(this.model.align, this.frame.v_range) + this.model.offset;
            break;
        case 'right':
            vx = this.model.panel._right.value;
            vy = this.canvas._height.value - this._get_text_location(this.model.align, this.frame.v_range) - this.model.offset;
            break;
        case 'above':
            vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;
            vy = this.model.panel._top.value - 10;
            break;
        case 'below':
            vx = this._get_text_location(this.model.align, this.frame.h_range) + this.model.offset;
            vy = this.model.panel._bottom.value;
        }
        sx = this.canvas.vx_to_sx(vx);
        sy = this.canvas.vy_to_sy(vy);
        return [
            sx,
            sy
        ];
    };
    TitleView.prototype._get_text_location = function (alignment, range) {
        var text_location;
        switch (alignment) {
        case 'left':
            text_location = range.start;
            break;
        case 'center':
            text_location = (range.end + range.start) / 2;
            break;
        case 'right':
            text_location = range.end;
        }
        return text_location;
    };
    TitleView.prototype.render = function () {
        var angle, ctx, ref, sx, sy;
        if (!this.model.visible && this.model.render_mode === 'css') {
            dom_1.hide(this.el);
        }
        if (!this.model.visible) {
            return;
        }
        angle = this.model.panel.get_label_angle_heuristic('parallel');
        ref = this._get_computed_location(), sx = ref[0], sy = ref[1];
        ctx = this.plot_view.canvas_view.ctx;
        if (this.model.text === '' || this.model.text === null) {
            return;
        }
        if (this.model.render_mode === 'canvas') {
            return this._canvas_text(ctx, this.model.text, sx, sy, angle);
        } else {
            return this._css_text(ctx, this.model.text, sx, sy, angle);
        }
    };
    TitleView.prototype._get_size = function () {
        var ctx, text;
        text = this.model.text;
        if (text === '' || text === null) {
            return 0;
        } else {
            ctx = this.plot_view.canvas_view.ctx;
            this.visuals.text.set_value(ctx);
            return ctx.measureText(text).ascent + 10;
        }
    };
    return TitleView;
}(text_annotation_1.TextAnnotationView);
exports.Title = function (superClass) {
    extend(Title, superClass);
    function Title() {
        return Title.__super__.constructor.apply(this, arguments);
    }
    Title.prototype.default_view = exports.TitleView;
    Title.prototype.type = 'Title';
    Title.mixins([
        'line:border_',
        'fill:background_'
    ]);
    Title.define({
        text: [p.String],
        text_font: [
            p.Font,
            'helvetica'
        ],
        text_font_size: [
            p.FontSizeSpec,
            '10pt'
        ],
        text_font_style: [
            p.FontStyle,
            'bold'
        ],
        text_color: [
            p.ColorSpec,
            '#444444'
        ],
        text_alpha: [
            p.NumberSpec,
            1
        ],
        align: [
            p.TextAlign,
            'left'
        ],
        offset: [
            p.Number,
            0
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    Title.override({
        background_fill_color: null,
        border_line_color: null
    });
    Title.internal({
        text_align: [
            p.TextAlign,
            'left'
        ],
        text_baseline: [
            p.TextBaseline,
            'bottom'
        ]
    });
    return Title;
}(text_annotation_1.TextAnnotation);    
},
/* models/annotations/tooltip */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
exports.TooltipView = function (superClass) {
    extend(TooltipView, superClass);
    function TooltipView() {
        return TooltipView.__super__.constructor.apply(this, arguments);
    }
    TooltipView.prototype.className = 'bk-tooltip';
    TooltipView.prototype.initialize = function (options) {
        TooltipView.__super__.initialize.call(this, options);
        this.plot_view.canvas_overlays.appendChild(this.el);
        this.el.style.zIndex = 1010;
        return dom_1.hide(this.el);
    };
    TooltipView.prototype.connect_signals = function () {
        TooltipView.__super__.connect_signals.call(this);
        return this.connect(this.model.properties.data.change, function () {
            return this._draw_tips();
        });
    };
    TooltipView.prototype.render = function () {
        if (!this.model.visible) {
            return;
        }
        return this._draw_tips();
    };
    TooltipView.prototype._draw_tips = function () {
        var arrow_size, attachment, bottom, content, data, height, i, left, len, side, sx, sy, tip, top, val, vx, vy, width;
        data = this.model.data;
        dom_1.empty(this.el);
        dom_1.hide(this.el);
        if (this.model.custom) {
            this.el.classList.add('bk-tooltip-custom');
        } else {
            this.el.classList.remove('bk-tooltip-custom');
        }
        if (data.length === 0) {
            return;
        }
        for (i = 0, len = data.length; i < len; i++) {
            val = data[i];
            vx = val[0], vy = val[1], content = val[2];
            if (this.model.inner_only && !this.plot_view.frame.contains(vx, vy)) {
                continue;
            }
            tip = dom_1.div({}, content);
            this.el.appendChild(tip);
        }
        sx = this.plot_view.model.canvas.vx_to_sx(vx);
        sy = this.plot_view.model.canvas.vy_to_sy(vy);
        attachment = this.model.attachment;
        switch (attachment) {
        case 'horizontal':
            width = this.plot_view.frame._width.value;
            left = this.plot_view.frame._left.value;
            if (vx - left < width / 2) {
                side = 'right';
            } else {
                side = 'left';
            }
            break;
        case 'vertical':
            height = this.plot_view.frame._height.value;
            bottom = this.plot_view.frame._bottom.value;
            if (vy - bottom < height / 2) {
                side = 'below';
            } else {
                side = 'above';
            }
            break;
        default:
            side = attachment;
        }
        this.el.classList.remove('bk-right');
        this.el.classList.remove('bk-left');
        this.el.classList.remove('bk-above');
        this.el.classList.remove('bk-below');
        arrow_size = 10;
        dom_1.show(this.el);
        switch (side) {
        case 'right':
            this.el.classList.add('bk-left');
            left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;
            top = sy - this.el.offsetHeight / 2;
            break;
        case 'left':
            this.el.classList.add('bk-right');
            left = sx - this.el.offsetWidth - arrow_size;
            top = sy - this.el.offsetHeight / 2;
            break;
        case 'above':
            this.el.classList.add('bk-above');
            top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;
            left = Math.round(sx - this.el.offsetWidth / 2);
            break;
        case 'below':
            this.el.classList.add('bk-below');
            top = sy - this.el.offsetHeight - arrow_size;
            left = Math.round(sx - this.el.offsetWidth / 2);
        }
        if (this.model.show_arrow) {
            this.el.classList.add('bk-tooltip-arrow');
        }
        if (this.el.childNodes.length > 0) {
            this.el.style.top = top + 'px';
            return this.el.style.left = left + 'px';
        } else {
            return dom_1.hide(this.el);
        }
    };
    return TooltipView;
}(annotation_1.AnnotationView);
exports.Tooltip = function (superClass) {
    extend(Tooltip, superClass);
    function Tooltip() {
        return Tooltip.__super__.constructor.apply(this, arguments);
    }
    Tooltip.prototype.default_view = exports.TooltipView;
    Tooltip.prototype.type = 'Tooltip';
    Tooltip.define({
        attachment: [
            p.String,
            'horizontal'
        ],
        inner_only: [
            p.Bool,
            true
        ],
        show_arrow: [
            p.Bool,
            true
        ]
    });
    Tooltip.override({ level: 'overlay' });
    Tooltip.internal({
        data: [
            p.Any,
            []
        ],
        custom: [p.Any]
    });
    Tooltip.prototype.clear = function () {
        return this.data = [];
    };
    Tooltip.prototype.add = function (vx, vy, content) {
        var data;
        data = this.data;
        data.push([
            vx,
            vy,
            content
        ]);
        this.data = data;
        return this.properties.data.change.emit();
    };
    return Tooltip;
}(annotation_1.Annotation);    
},
/* models/annotations/whisker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var annotation_1 = require(49    /* ./annotation */);
var column_data_source_1 = require(168    /* ../sources/column_data_source */);
var arrow_head_1 = require(51    /* ./arrow_head */);
var p = require(13    /* core/properties */);
exports.WhiskerView = function (superClass) {
    extend(WhiskerView, superClass);
    function WhiskerView() {
        return WhiskerView.__super__.constructor.apply(this, arguments);
    }
    WhiskerView.prototype.initialize = function (options) {
        WhiskerView.__super__.initialize.call(this, options);
        return this.set_data(this.model.source);
    };
    WhiskerView.prototype.connect_signals = function () {
        WhiskerView.__super__.connect_signals.call(this);
        this.connect(this.model.source.streaming, function () {
            return this.set_data(this.model.source);
        });
        this.connect(this.model.source.patching, function () {
            return this.set_data(this.model.source);
        });
        return this.connect(this.model.source.change, function () {
            return this.set_data(this.model.source);
        });
    };
    WhiskerView.prototype.set_data = function (source) {
        WhiskerView.__super__.set_data.call(this, source);
        this.visuals.warm_cache(source);
        return this.plot_view.request_render();
    };
    WhiskerView.prototype._map_data = function () {
        var _base_vx, _lower, _lower_vx, _upper, _upper_vx, base_scale, i, j, limit_scale, ref, x_scale, y_scale;
        x_scale = this.plot_view.frame.xscales[this.model.x_range_name];
        y_scale = this.plot_view.frame.yscales[this.model.y_range_name];
        limit_scale = this.model.dimension === 'height' ? y_scale : x_scale;
        base_scale = this.model.dimension === 'height' ? x_scale : y_scale;
        if (this.model.lower.units === 'data') {
            _lower_vx = limit_scale.v_compute(this._lower);
        } else {
            _lower_vx = this._lower;
        }
        if (this.model.upper.units === 'data') {
            _upper_vx = limit_scale.v_compute(this._upper);
        } else {
            _upper_vx = this._upper;
        }
        if (this.model.base.units === 'data') {
            _base_vx = base_scale.v_compute(this._base);
        } else {
            _base_vx = this._base;
        }
        ref = this.model._normals(), i = ref[0], j = ref[1];
        _lower = [
            _lower_vx,
            _base_vx
        ];
        _upper = [
            _upper_vx,
            _base_vx
        ];
        this._lower_sx = this.plot_model.canvas.v_vx_to_sx(_lower[i]);
        this._lower_sy = this.plot_model.canvas.v_vy_to_sy(_lower[j]);
        this._upper_sx = this.plot_model.canvas.v_vx_to_sx(_upper[i]);
        return this._upper_sy = this.plot_model.canvas.v_vy_to_sy(_upper[j]);
    };
    WhiskerView.prototype.render = function () {
        var angle, ctx, i, k, l, m, ref, ref1, ref2, results;
        if (!this.model.visible) {
            return;
        }
        this._map_data();
        ctx = this.plot_view.canvas_view.ctx;
        if (this.visuals.line.doit) {
            for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.beginPath();
                ctx.moveTo(this._lower_sx[i], this._lower_sy[i]);
                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
                ctx.stroke();
            }
        }
        angle = this.model.dimension === 'height' ? 0 : Math.PI / 2;
        if (this.model.lower_head != null) {
            for (i = l = 0, ref1 = this._lower_sx.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                ctx.save();
                ctx.translate(this._lower_sx[i], this._lower_sy[i]);
                ctx.rotate(angle + Math.PI);
                this.model.lower_head.render(ctx, i);
                ctx.restore();
            }
        }
        if (this.model.upper_head != null) {
            results = [];
            for (i = m = 0, ref2 = this._upper_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
                ctx.save();
                ctx.translate(this._upper_sx[i], this._upper_sy[i]);
                ctx.rotate(angle);
                this.model.upper_head.render(ctx, i);
                results.push(ctx.restore());
            }
            return results;
        }
    };
    return WhiskerView;
}(annotation_1.AnnotationView);
exports.Whisker = function (superClass) {
    extend(Whisker, superClass);
    function Whisker() {
        return Whisker.__super__.constructor.apply(this, arguments);
    }
    Whisker.prototype.default_view = exports.WhiskerView;
    Whisker.prototype.type = 'Whisker';
    Whisker.mixins(['line']);
    Whisker.define({
        lower: [p.DistanceSpec],
        lower_head: [
            p.Instance,
            function () {
                return new arrow_head_1.TeeHead({
                    level: 'underlay',
                    size: 10
                });
            }
        ],
        upper: [p.DistanceSpec],
        upper_head: [
            p.Instance,
            function () {
                return new arrow_head_1.TeeHead({
                    level: 'underlay',
                    size: 10
                });
            }
        ],
        base: [p.DistanceSpec],
        dimension: [
            p.Dimension,
            'height'
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Whisker.override({ level: 'underlay' });
    Whisker.prototype._normals = function () {
        var i, j, ref, ref1;
        if (this.dimension === 'height') {
            ref = [
                1,
                0
            ], i = ref[0], j = ref[1];
        } else {
            ref1 = [
                0,
                1
            ], i = ref1[0], j = ref1[1];
        }
        return [
            i,
            j
        ];
    };
    return Whisker;
}(annotation_1.Annotation);    
},
/* models/axes/axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var side_panel_1 = require(10    /* core/layout/side_panel */);
var guide_renderer_1 = require(158    /* ../renderers/guide_renderer */);
var renderer_1 = require(160    /* ../renderers/renderer */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
exports.AxisView = function (superClass) {
    extend(AxisView, superClass);
    function AxisView() {
        return AxisView.__super__.constructor.apply(this, arguments);
    }
    AxisView.prototype.render = function () {
        var ctx, extents, tick_coords;
        if (this.model.visible === false) {
            return;
        }
        extents = {
            tick: this._tick_extent(),
            tick_label: this._tick_label_extents(),
            axis_label: this._axis_label_extent()
        };
        tick_coords = this.model.tick_coords;
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        this._draw_rule(ctx, extents);
        this._draw_major_ticks(ctx, extents, tick_coords);
        this._draw_minor_ticks(ctx, extents, tick_coords);
        this._draw_major_labels(ctx, extents, tick_coords);
        this._draw_axis_label(ctx, extents, tick_coords);
        if (this._render != null) {
            this._render(ctx, extents, tick_coords);
        }
        return ctx.restore();
    };
    AxisView.prototype.connect_signals = function () {
        AxisView.__super__.connect_signals.call(this);
        return this.connect(this.model.change, function (_this) {
            return function () {
                return _this.plot_view.request_render();
            };
        }(this));
    };
    AxisView.prototype._get_size = function () {
        return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();
    };
    AxisView.prototype._draw_rule = function (ctx, extents, tick_coords) {
        var i, k, nx, ny, ref, ref1, ref2, ref3, ref4, sx, sy, x, xoff, y, yoff;
        if (!this.visuals.axis_line.doit) {
            return;
        }
        ref = this.model.rule_coords, x = ref[0], y = ref[1];
        ref1 = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name), sx = ref1[0], sy = ref1[1];
        ref2 = this.model.normals, nx = ref2[0], ny = ref2[1];
        ref3 = this.model.offsets, xoff = ref3[0], yoff = ref3[1];
        this.visuals.axis_line.set_value(ctx);
        ctx.beginPath();
        ctx.moveTo(Math.round(sx[0] + nx * xoff), Math.round(sy[0] + ny * yoff));
        for (i = k = 1, ref4 = sx.length; 1 <= ref4 ? k < ref4 : k > ref4; i = 1 <= ref4 ? ++k : --k) {
            sx = Math.round(sx[i] + nx * xoff);
            sy = Math.round(sy[i] + ny * yoff);
            ctx.lineTo(sx, sy);
        }
        ctx.stroke();
    };
    AxisView.prototype._draw_major_ticks = function (ctx, extents, tick_coords) {
        var tin, tout, visuals;
        tin = this.model.major_tick_in;
        tout = this.model.major_tick_out;
        visuals = this.visuals.major_tick_line;
        this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);
    };
    AxisView.prototype._draw_minor_ticks = function (ctx, extents, tick_coords) {
        var tin, tout, visuals;
        tin = this.model.minor_tick_in;
        tout = this.model.minor_tick_out;
        visuals = this.visuals.minor_tick_line;
        this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);
    };
    AxisView.prototype._draw_major_labels = function (ctx, extents, tick_coords) {
        var coords, labels, orient, standoff, visuals;
        coords = tick_coords.major;
        labels = this.model.compute_labels(coords[this.model.dimension]);
        orient = this.model.major_label_orientation;
        standoff = extents.tick + this.model.major_label_standoff;
        visuals = this.visuals.major_label_text;
        this._draw_oriented_labels(ctx, labels, coords, orient, this.model.panel_side, standoff, visuals);
    };
    AxisView.prototype._draw_axis_label = function (ctx, extents, tick_coords) {
        var coords, ref, standoff, visuals, x, xm, y, ym;
        if (this.model.axis_label == null) {
            return;
        }
        ref = this.model.rule_coords, x = ref[0], y = ref[1];
        xm = (x[0] + x[x.length - 1]) / 2;
        ym = (y[0] + y[y.length - 1]) / 2;
        coords = [
            [xm],
            [ym]
        ];
        standoff = extents.tick + array_1.sum(extents.tick_label) + this.model.axis_label_standoff;
        visuals = this.visuals.axis_label_text;
        this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.model.panel_side, standoff, visuals);
    };
    AxisView.prototype._draw_ticks = function (ctx, coords, tin, tout, visuals) {
        var i, k, nx, nxin, nxout, ny, nyin, nyout, ref, ref1, ref2, ref3, ref4, ref5, sx0, sx1, sxs, sy0, sy1, sys, x, xoff, y, yoff;
        if (!visuals.doit || coords.length === 0) {
            return;
        }
        x = coords[0], y = coords[1];
        ref = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name), sxs = ref[0], sys = ref[1];
        ref1 = this.model.normals, nx = ref1[0], ny = ref1[1];
        ref2 = this.model.offsets, xoff = ref2[0], yoff = ref2[1];
        ref3 = [
            nx * (xoff - tin),
            ny * (yoff - tin)
        ], nxin = ref3[0], nyin = ref3[1];
        ref4 = [
            nx * (xoff + tout),
            ny * (yoff + tout)
        ], nxout = ref4[0], nyout = ref4[1];
        visuals.set_value(ctx);
        for (i = k = 0, ref5 = sxs.length; 0 <= ref5 ? k < ref5 : k > ref5; i = 0 <= ref5 ? ++k : --k) {
            sx0 = Math.round(sxs[i] + nxout);
            sy0 = Math.round(sys[i] + nyout);
            sx1 = Math.round(sxs[i] + nxin);
            sy1 = Math.round(sys[i] + nyin);
            ctx.beginPath();
            ctx.moveTo(sx0, sy0);
            ctx.lineTo(sx1, sy1);
            ctx.stroke();
        }
    };
    AxisView.prototype._draw_oriented_labels = function (ctx, labels, coords, orient, side, standoff, visuals) {
        var angle, i, k, nx, nxd, ny, nyd, ref, ref1, ref2, ref3, sx, sxs, sy, sys, x, xoff, y, yoff;
        if (!visuals.doit || labels.length === 0) {
            return;
        }
        x = coords[0], y = coords[1];
        ref = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name), sxs = ref[0], sys = ref[1];
        ref1 = this.model.normals, nx = ref1[0], ny = ref1[1];
        ref2 = this.model.offsets, xoff = ref2[0], yoff = ref2[1];
        nxd = nx * (xoff + standoff);
        nyd = ny * (yoff + standoff);
        visuals.set_value(ctx);
        this.model.panel.apply_label_text_heuristics(ctx, orient);
        if (types_1.isString(orient)) {
            angle = this.model.panel.get_label_angle_heuristic(orient);
        } else {
            angle = -orient;
        }
        for (i = k = 0, ref3 = sxs.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
            sx = Math.round(sxs[i] + nxd);
            sy = Math.round(sys[i] + nyd);
            ctx.translate(sx, sy);
            ctx.rotate(angle);
            ctx.fillText(labels[i], 0, 0);
            ctx.rotate(-angle);
            ctx.translate(-sx, -sy);
        }
    };
    AxisView.prototype._axis_label_extent = function () {
        var standoff, visuals;
        if (this.model.axis_label == null || this.model.axis_label === '') {
            return 0;
        }
        standoff = this.model.axis_label_standoff;
        visuals = this.visuals.axis_label_text;
        return this._oriented_labels_extent([this.model.axis_label], 'parallel', this.model.panel_side, standoff, visuals);
    };
    AxisView.prototype._tick_extent = function () {
        return this.model.major_tick_out;
    };
    AxisView.prototype._tick_label_extent = function () {
        return array_1.sum(this._tick_label_extents());
    };
    AxisView.prototype._tick_label_extents = function () {
        var coords, labels, orient, standoff, visuals;
        coords = this.model.tick_coords.major;
        labels = this.model.compute_labels(coords[this.model.dimension]);
        orient = this.model.major_label_orientation;
        standoff = this.model.major_label_standoff;
        visuals = this.visuals.major_label_text;
        return [this._oriented_labels_extent(labels, orient, this.model.panel_side, standoff, visuals)];
    };
    AxisView.prototype._tick_label_extent = function () {
        return array_1.sum(this._tick_label_extents());
    };
    AxisView.prototype._oriented_labels_extent = function (labels, orient, side, standoff, visuals) {
        var angle, c, ctx, extent, h, hscale, i, k, ref, s, val, w;
        if (labels.length === 0) {
            return 0;
        }
        ctx = this.plot_view.canvas_view.ctx;
        visuals.set_value(ctx);
        if (types_1.isString(orient)) {
            hscale = 1;
            angle = this.model.panel.get_label_angle_heuristic(orient);
        } else {
            hscale = 2;
            angle = -orient;
        }
        angle = Math.abs(angle);
        c = Math.cos(angle);
        s = Math.sin(angle);
        extent = 0;
        for (i = k = 0, ref = labels.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            w = ctx.measureText(labels[i]).width * 1.1;
            h = ctx.measureText(labels[i]).ascent * 0.9;
            if (side === 'above' || side === 'below') {
                val = w * s + h / hscale * c;
            } else {
                val = w * c + h / hscale * s;
            }
            if (val > extent) {
                extent = val;
            }
        }
        if (extent > 0) {
            extent += standoff;
        }
        return extent;
    };
    return AxisView;
}(renderer_1.RendererView);
exports.Axis = function (superClass) {
    extend(Axis, superClass);
    function Axis() {
        return Axis.__super__.constructor.apply(this, arguments);
    }
    Axis.prototype.default_view = exports.AxisView;
    Axis.prototype.type = 'Axis';
    Axis.mixins([
        'line:axis_',
        'line:major_tick_',
        'line:minor_tick_',
        'text:major_label_',
        'text:axis_label_'
    ]);
    Axis.define({
        bounds: [
            p.Any,
            'auto'
        ],
        ticker: [
            p.Instance,
            null
        ],
        formatter: [
            p.Instance,
            null
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        axis_label: [
            p.String,
            ''
        ],
        axis_label_standoff: [
            p.Int,
            5
        ],
        major_label_standoff: [
            p.Int,
            5
        ],
        major_label_orientation: [
            p.Any,
            'horizontal'
        ],
        major_label_overrides: [
            p.Any,
            {}
        ],
        major_tick_in: [
            p.Number,
            2
        ],
        major_tick_out: [
            p.Number,
            6
        ],
        minor_tick_in: [
            p.Number,
            0
        ],
        minor_tick_out: [
            p.Number,
            4
        ]
    });
    Axis.override({
        axis_line_color: 'black',
        major_tick_line_color: 'black',
        minor_tick_line_color: 'black',
        major_label_text_font_size: '8pt',
        major_label_text_align: 'center',
        major_label_text_baseline: 'alphabetic',
        axis_label_text_font_size: '10pt',
        axis_label_text_font_style: 'italic'
    });
    Axis.internal({ panel_side: [p.Any] });
    Axis.prototype.compute_labels = function (ticks) {
        var i, k, labels, ref;
        labels = this.formatter.doFormat(ticks, this);
        for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (ticks[i] in this.major_label_overrides) {
                labels[i] = this.major_label_overrides[ticks[i]];
            }
        }
        return labels;
    };
    Axis.prototype.label_info = function (coords) {
        var info, orient;
        orient = this.major_label_orientation;
        info = {
            dim: this.dimension,
            coords: coords,
            side: this.panel_side,
            orient: orient,
            standoff: this.major_label_standoff
        };
        return info;
    };
    Axis.getters({
        computed_bounds: function () {
            return this._computed_bounds();
        },
        rule_coords: function () {
            return this._rule_coords();
        },
        tick_coords: function () {
            return this._tick_coords();
        },
        ranges: function () {
            return this._ranges();
        },
        normals: function () {
            return this.panel._normals;
        },
        dimension: function () {
            return this.panel._dim;
        },
        offsets: function () {
            return this._offsets();
        },
        loc: function () {
            return this._get_loc();
        }
    });
    Axis.prototype.add_panel = function (side) {
        this.panel = new side_panel_1.SidePanel({ side: side });
        this.panel.attach_document(this.document);
        return this.panel_side = side;
    };
    Axis.prototype._offsets = function () {
        var frame, ref, side, xoff, yoff;
        side = this.panel_side;
        ref = [
            0,
            0
        ], xoff = ref[0], yoff = ref[1];
        frame = this.plot.plot_canvas.frame;
        switch (side) {
        case 'below':
            yoff = Math.abs(this.panel._top.value - frame._bottom.value);
            break;
        case 'above':
            yoff = Math.abs(this.panel._bottom.value - frame._top.value);
            break;
        case 'right':
            xoff = Math.abs(this.panel._left.value - frame._right.value);
            break;
        case 'left':
            xoff = Math.abs(this.panel._right.value - frame._left.value);
        }
        return [
            xoff,
            yoff
        ];
    };
    Axis.prototype._ranges = function () {
        var frame, i, j, ranges;
        i = this.dimension;
        j = (i + 1) % 2;
        frame = this.plot.plot_canvas.frame;
        ranges = [
            frame.x_ranges[this.x_range_name],
            frame.y_ranges[this.y_range_name]
        ];
        return [
            ranges[i],
            ranges[j]
        ];
    };
    Axis.prototype._computed_bounds = function () {
        var cross_range, end, range, range_bounds, ref, ref1, start, user_bounds;
        ref = this.ranges, range = ref[0], cross_range = ref[1];
        user_bounds = (ref1 = this.bounds) != null ? ref1 : 'auto';
        range_bounds = [
            range.min,
            range.max
        ];
        if (user_bounds === 'auto') {
            return range_bounds;
        }
        if (types_1.isArray(user_bounds)) {
            if (Math.abs(user_bounds[0] - user_bounds[1]) > Math.abs(range_bounds[0] - range_bounds[1])) {
                start = Math.max(Math.min(user_bounds[0], user_bounds[1]), range_bounds[0]);
                end = Math.min(Math.max(user_bounds[0], user_bounds[1]), range_bounds[1]);
            } else {
                start = Math.min(user_bounds[0], user_bounds[1]);
                end = Math.max(user_bounds[0], user_bounds[1]);
            }
            return [
                start,
                end
            ];
        }
        logging_1.logger.error('user bounds \'' + user_bounds + '\' not understood');
        return null;
    };
    Axis.prototype._rule_coords = function () {
        var coords, cross_range, end, i, j, range, ref, ref1, start, xs, ys;
        i = this.dimension;
        j = (i + 1) % 2;
        ref = this.ranges, range = ref[0], cross_range = ref[1];
        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];
        xs = new Array(2);
        ys = new Array(2);
        coords = [
            xs,
            ys
        ];
        coords[i][0] = Math.max(start, range.min);
        coords[i][1] = Math.min(end, range.max);
        if (coords[i][0] > coords[i][1]) {
            coords[i][0] = coords[i][1] = 0 / 0;
        }
        coords[j][0] = this.loc;
        coords[j][1] = this.loc;
        return coords;
    };
    Axis.prototype._tick_coords = function () {
        var coords, cross_range, end, i, ii, j, k, l, majors, minor_coords, minor_xs, minor_ys, minors, range, range_max, range_min, ref, ref1, ref2, ref3, ref4, start, ticks, xs, ys;
        i = this.dimension;
        j = (i + 1) % 2;
        ref = this.ranges, range = ref[0], cross_range = ref[1];
        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];
        ticks = this.ticker.get_ticks(start, end, range, this.loc, {});
        majors = ticks.major;
        minors = ticks.minor;
        xs = [];
        ys = [];
        coords = [
            xs,
            ys
        ];
        minor_xs = [];
        minor_ys = [];
        minor_coords = [
            minor_xs,
            minor_ys
        ];
        ref2 = [
            range.min,
            range.max
        ], range_min = ref2[0], range_max = ref2[1];
        for (ii = k = 0, ref3 = majors.length; 0 <= ref3 ? k < ref3 : k > ref3; ii = 0 <= ref3 ? ++k : --k) {
            if (majors[ii] < range_min || majors[ii] > range_max) {
                continue;
            }
            coords[i].push(majors[ii]);
            coords[j].push(this.loc);
        }
        for (ii = l = 0, ref4 = minors.length; 0 <= ref4 ? l < ref4 : l > ref4; ii = 0 <= ref4 ? ++l : --l) {
            if (minors[ii] < range_min || minors[ii] > range_max) {
                continue;
            }
            minor_coords[i].push(minors[ii]);
            minor_coords[j].push(this.loc);
        }
        return {
            'major': coords,
            'minor': minor_coords
        };
    };
    Axis.prototype._get_loc = function () {
        var cend, cross_range, cstart, range, ref, side;
        ref = this.ranges, range = ref[0], cross_range = ref[1];
        cstart = cross_range.start;
        cend = cross_range.end;
        side = this.panel_side;
        switch (side) {
        case 'left':
        case 'below':
            return cross_range.start;
        case 'right':
        case 'above':
            return cross_range.end;
        }
    };
    return Axis;
}(guide_renderer_1.GuideRenderer);    
},
/* models/axes/categorical_axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var axis_1 = require(66    /* ./axis */);
var categorical_tick_formatter_1 = require(89    /* ../formatters/categorical_tick_formatter */);
var categorical_ticker_1 = require(176    /* ../tickers/categorical_ticker */);
exports.CategoricalAxisView = function (superClass) {
    extend(CategoricalAxisView, superClass);
    function CategoricalAxisView() {
        return CategoricalAxisView.__super__.constructor.apply(this, arguments);
    }
    CategoricalAxisView.prototype._render = function (ctx, extents, tick_coords) {
        return this._draw_group_separators(ctx, extents, tick_coords);
    };
    CategoricalAxisView.prototype._draw_group_separators = function (ctx, extents, tick_coords) {
        var alt, coords, cross_range, dim, end, first, i, ind, j, k, l, last, loc, pt, range, ref, ref1, ref2, ref3, ref4, ref5, ref6, start, tex, ticks;
        ref = this.model.ranges, range = ref[0], cross_range = ref[1];
        ref1 = this.model.computed_bounds, start = ref1[0], end = ref1[1];
        loc = this.model.loc;
        ticks = this.model.ticker.get_ticks(start, end, range, loc, {});
        ref2 = this.model.ranges, range = ref2[0], cross_range = ref2[1];
        if (!range.tops || range.tops.length < 2 || !this.visuals.separator_line.doit) {
            return;
        }
        dim = this.model.dimension;
        alt = (dim + 1) % 2;
        coords = [
            [],
            []
        ];
        ind = 0;
        for (i = k = 0, ref3 = range.tops.length - 1; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
            for (j = l = ref4 = ind, ref5 = range.factors.length; ref4 <= ref5 ? l < ref5 : l > ref5; j = ref4 <= ref5 ? ++l : --l) {
                if (range.factors[j][0] === range.tops[i + 1]) {
                    ref6 = [
                        range.factors[j - 1],
                        range.factors[j]
                    ], first = ref6[0], last = ref6[1];
                    ind = j;
                    break;
                }
            }
            pt = (range.synthetic(first) + range.synthetic(last)) / 2;
            if (pt > start && pt < end) {
                coords[dim].push(pt);
                coords[alt].push(this.model.loc);
            }
        }
        tex = this._tick_label_extent();
        this._draw_ticks(ctx, coords, -3, tex - 6, this.visuals.separator_line);
    };
    CategoricalAxisView.prototype._draw_major_labels = function (ctx, extents, tick_coords) {
        var alt, coords, dim, i, info, k, labels, loc, orient, ref, ref1, standoff, visuals;
        info = this._get_factor_info();
        loc = this.model.loc;
        dim = this.model.dimension;
        alt = (dim + 1) % 2;
        standoff = extents.tick + this.model.major_label_standoff;
        for (i = k = 0, ref = info.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            ref1 = info[i], labels = ref1[0], coords = ref1[1], orient = ref1[2], visuals = ref1[3];
            this._draw_oriented_labels(ctx, labels, coords, orient, this.model.panel_side, standoff, visuals);
            standoff += extents.tick_label[i];
        }
    };
    CategoricalAxisView.prototype._tick_label_extents = function () {
        var dim_coords, extent, extents, info, k, labels, len, orient, ref, visuals;
        info = this._get_factor_info();
        extents = [];
        for (k = 0, len = info.length; k < len; k++) {
            ref = info[k], labels = ref[0], dim_coords = ref[1], orient = ref[2], visuals = ref[3];
            extent = this._oriented_labels_extent(labels, orient, this.model.panel_side, this.model.major_label_standoff, visuals);
            extents.push(extent);
        }
        return extents;
    };
    CategoricalAxisView.prototype._get_factor_info = function () {
        var coords, cross_range, end, info, labels, loc, mid_labels, range, ref, ref1, start, ticks, x;
        ref = this.model.ranges, range = ref[0], cross_range = ref[1];
        ref1 = this.model.computed_bounds, start = ref1[0], end = ref1[1];
        loc = this.model.loc;
        ticks = this.model.ticker.get_ticks(start, end, range, loc, {});
        coords = this.model.tick_coords;
        info = [];
        if (range.levels === 1) {
            info.push([
                ticks.major,
                coords.major,
                this.model.major_label_orientation,
                this.visuals.major_label_text
            ]);
        } else if (range.levels === 2) {
            labels = function () {
                var k, len, ref2, results;
                ref2 = ticks.major;
                results = [];
                for (k = 0, len = ref2.length; k < len; k++) {
                    x = ref2[k];
                    results.push(x[1]);
                }
                return results;
            }();
            info.push([
                labels,
                coords.major,
                this.model.major_label_orientation,
                this.visuals.major_label_text
            ]);
            info.push([
                ticks.tops,
                coords.tops,
                'parallel',
                this.visuals.group_text
            ]);
        } else if (range.levels === 3) {
            labels = function () {
                var k, len, ref2, results;
                ref2 = ticks.major;
                results = [];
                for (k = 0, len = ref2.length; k < len; k++) {
                    x = ref2[k];
                    results.push(x[2]);
                }
                return results;
            }();
            mid_labels = function () {
                var k, len, ref2, results;
                ref2 = ticks.mids;
                results = [];
                for (k = 0, len = ref2.length; k < len; k++) {
                    x = ref2[k];
                    results.push(x[1]);
                }
                return results;
            }();
            info.push([
                labels,
                coords.major,
                this.model.major_label_orientation,
                this.visuals.major_label_text
            ]);
            info.push([
                mid_labels,
                coords.mids,
                'parallel',
                this.visuals.subgroup_text
            ]);
            info.push([
                ticks.tops,
                coords.tops,
                'parallel',
                this.visuals.group_text
            ]);
        }
        return info;
    };
    return CategoricalAxisView;
}(axis_1.AxisView);
exports.CategoricalAxis = function (superClass) {
    extend(CategoricalAxis, superClass);
    function CategoricalAxis() {
        return CategoricalAxis.__super__.constructor.apply(this, arguments);
    }
    CategoricalAxis.prototype.default_view = exports.CategoricalAxisView;
    CategoricalAxis.prototype.type = 'CategoricalAxis';
    CategoricalAxis.mixins([
        'line:separator_',
        'text:group_',
        'text:subgroup_'
    ]);
    CategoricalAxis.override({
        ticker: function () {
            return new categorical_ticker_1.CategoricalTicker();
        },
        formatter: function () {
            return new categorical_tick_formatter_1.CategoricalTickFormatter();
        },
        separator_line_color: 'lightgrey',
        separator_line_width: 2,
        group_text_font_style: 'bold',
        group_text_font_size: '8pt',
        group_text_color: 'grey',
        subgroup_text_font_style: 'bold',
        subgroup_text_font_size: '8pt'
    });
    CategoricalAxis.prototype._tick_coords = function () {
        var coords, cross_range, end, i, j, range, ref, ref1, start, ticks, x;
        i = this.dimension;
        j = (i + 1) % 2;
        ref = this.ranges, range = ref[0], cross_range = ref[1];
        ref1 = this.computed_bounds, start = ref1[0], end = ref1[1];
        ticks = this.ticker.get_ticks(start, end, range, this.loc, {});
        coords = {
            major: [
                [],
                []
            ],
            mids: [
                [],
                []
            ],
            tops: [
                [],
                []
            ],
            minor: []
        };
        coords.major[i] = ticks.major;
        coords.major[j] = function () {
            var k, len, ref2, results;
            ref2 = ticks.major;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
                x = ref2[k];
                results.push(this.loc);
            }
            return results;
        }.call(this);
        if (range.levels === 3) {
            coords.mids[i] = ticks.mids;
            coords.mids[j] = function () {
                var k, len, ref2, results;
                ref2 = ticks.mids;
                results = [];
                for (k = 0, len = ref2.length; k < len; k++) {
                    x = ref2[k];
                    results.push(this.loc);
                }
                return results;
            }.call(this);
        }
        if (range.levels > 1) {
            coords.tops[i] = ticks.tops;
            coords.tops[j] = function () {
                var k, len, ref2, results;
                ref2 = ticks.tops;
                results = [];
                for (k = 0, len = ref2.length; k < len; k++) {
                    x = ref2[k];
                    results.push(this.loc);
                }
                return results;
            }.call(this);
        }
        return coords;
    };
    return CategoricalAxis;
}(axis_1.Axis);    
},
/* models/axes/continuous_axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var axis_1 = require(66    /* ./axis */);
exports.ContinuousAxis = function (superClass) {
    extend(ContinuousAxis, superClass);
    function ContinuousAxis() {
        return ContinuousAxis.__super__.constructor.apply(this, arguments);
    }
    ContinuousAxis.prototype.type = 'ContinuousAxis';
    return ContinuousAxis;
}(axis_1.Axis);    
},
/* models/axes/datetime_axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var linear_axis_1 = require(71    /* ./linear_axis */);
var datetime_tick_formatter_1 = require(90    /* ../formatters/datetime_tick_formatter */);
var datetime_ticker_1 = require(179    /* ../tickers/datetime_ticker */);
exports.DatetimeAxisView = function (superClass) {
    extend(DatetimeAxisView, superClass);
    function DatetimeAxisView() {
        return DatetimeAxisView.__super__.constructor.apply(this, arguments);
    }
    return DatetimeAxisView;
}(linear_axis_1.LinearAxisView);
exports.DatetimeAxis = function (superClass) {
    extend(DatetimeAxis, superClass);
    function DatetimeAxis() {
        return DatetimeAxis.__super__.constructor.apply(this, arguments);
    }
    DatetimeAxis.prototype.default_view = exports.DatetimeAxisView;
    DatetimeAxis.prototype.type = 'DatetimeAxis';
    DatetimeAxis.override({
        ticker: function () {
            return new datetime_ticker_1.DatetimeTicker();
        },
        formatter: function () {
            return new datetime_tick_formatter_1.DatetimeTickFormatter();
        }
    });
    return DatetimeAxis;
}(linear_axis_1.LinearAxis);    
},
/* models/axes/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var axis_1 = require(66    /* ./axis */);
exports.Axis = axis_1.Axis;
var categorical_axis_1 = require(67    /* ./categorical_axis */);
exports.CategoricalAxis = categorical_axis_1.CategoricalAxis;
var continuous_axis_1 = require(68    /* ./continuous_axis */);
exports.ContinuousAxis = continuous_axis_1.ContinuousAxis;
var datetime_axis_1 = require(69    /* ./datetime_axis */);
exports.DatetimeAxis = datetime_axis_1.DatetimeAxis;
var linear_axis_1 = require(71    /* ./linear_axis */);
exports.LinearAxis = linear_axis_1.LinearAxis;
var log_axis_1 = require(72    /* ./log_axis */);
exports.LogAxis = log_axis_1.LogAxis;    
},
/* models/axes/linear_axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var axis_1 = require(66    /* ./axis */);
var continuous_axis_1 = require(68    /* ./continuous_axis */);
var basic_tick_formatter_1 = require(88    /* ../formatters/basic_tick_formatter */);
var basic_ticker_1 = require(175    /* ../tickers/basic_ticker */);
exports.LinearAxisView = function (superClass) {
    extend(LinearAxisView, superClass);
    function LinearAxisView() {
        return LinearAxisView.__super__.constructor.apply(this, arguments);
    }
    return LinearAxisView;
}(axis_1.AxisView);
exports.LinearAxis = function (superClass) {
    extend(LinearAxis, superClass);
    function LinearAxis() {
        return LinearAxis.__super__.constructor.apply(this, arguments);
    }
    LinearAxis.prototype.default_view = exports.LinearAxisView;
    LinearAxis.prototype.type = 'LinearAxis';
    LinearAxis.override({
        ticker: function () {
            return new basic_ticker_1.BasicTicker();
        },
        formatter: function () {
            return new basic_tick_formatter_1.BasicTickFormatter();
        }
    });
    return LinearAxis;
}(continuous_axis_1.ContinuousAxis);    
},
/* models/axes/log_axis */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var axis_1 = require(66    /* ./axis */);
var continuous_axis_1 = require(68    /* ./continuous_axis */);
var log_tick_formatter_1 = require(93    /* ../formatters/log_tick_formatter */);
var log_ticker_1 = require(183    /* ../tickers/log_ticker */);
exports.LogAxisView = function (superClass) {
    extend(LogAxisView, superClass);
    function LogAxisView() {
        return LogAxisView.__super__.constructor.apply(this, arguments);
    }
    return LogAxisView;
}(axis_1.AxisView);
exports.LogAxis = function (superClass) {
    extend(LogAxis, superClass);
    function LogAxis() {
        return LogAxis.__super__.constructor.apply(this, arguments);
    }
    LogAxis.prototype.default_view = exports.LogAxisView;
    LogAxis.prototype.type = 'LogAxis';
    LogAxis.override({
        ticker: function () {
            return new log_ticker_1.LogTicker();
        },
        formatter: function () {
            return new log_tick_formatter_1.LogTickFormatter();
        }
    });
    return LogAxis;
}(continuous_axis_1.ContinuousAxis);    
},
/* models/callbacks/customjs */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
var model_1 = require(48    /* ../../model */);
exports.CustomJS = function (superClass) {
    extend(CustomJS, superClass);
    function CustomJS() {
        return CustomJS.__super__.constructor.apply(this, arguments);
    }
    CustomJS.prototype.type = 'CustomJS';
    CustomJS.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });
    CustomJS.getters({
        values: function () {
            return this._make_values();
        },
        func: function () {
            return this._make_func();
        }
    });
    CustomJS.prototype.execute = function (cb_obj, cb_data) {
        return this.func.apply(cb_obj, this.values.concat(cb_obj, cb_data, require, {}));
    };
    CustomJS.prototype._make_values = function () {
        return object_1.values(this.args);
    };
    CustomJS.prototype._make_func = function () {
        return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor(), result = func.apply(child, args);
            return Object(result) === result ? result : child;
        }(Function, slice.call(Object.keys(this.args)).concat(['cb_obj'], ['cb_data'], ['require'], ['exports'], [this.code]), function () {
        });
    };
    return CustomJS;
}(model_1.Model);    
},
/* models/callbacks/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var customjs_1 = require(73    /* ./customjs */);
exports.CustomJS = customjs_1.CustomJS;
var open_url_1 = require(75    /* ./open_url */);
exports.OpenURL = open_url_1.OpenURL;    
},
/* models/callbacks/open_url */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var p = require(13    /* core/properties */);
var selection_1 = require(32    /* core/util/selection */);
var templating_1 = require(37    /* core/util/templating */);
exports.OpenURL = function (superClass) {
    extend(OpenURL, superClass);
    function OpenURL() {
        return OpenURL.__super__.constructor.apply(this, arguments);
    }
    OpenURL.prototype.type = 'OpenURL';
    OpenURL.define({
        url: [
            p.String,
            'http://'
        ]
    });
    OpenURL.prototype.execute = function (cb_obj, cb_data) {
        var i, j, len, ref, url;
        ref = selection_1.get_indices(cb_data.source);
        for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            url = templating_1.replace_placeholders(this.url, cb_data.source, i);
            window.open(url);
        }
        return null;
    };
    return OpenURL;
}(model_1.Model);    
},
/* models/canvas/canvas */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var layout_canvas_1 = require(9    /* core/layout/layout_canvas */);
var dom_view_1 = require(5    /* core/dom_view */);
var solver_1 = require(11    /* core/layout/solver */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var dom_1 = require(4    /* core/dom */);
var canvas_1 = require(23    /* core/util/canvas */);
var canvas2svg = require(242    /* canvas2svg */);
if (window.CanvasPixelArray != null) {
    CanvasPixelArray.prototype.set = function (arr) {
        var i, j, ref, results;
        results = [];
        for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(this[i] = arr[i]);
        }
        return results;
    };
}
exports.CanvasView = function (superClass) {
    extend(CanvasView, superClass);
    function CanvasView() {
        return CanvasView.__super__.constructor.apply(this, arguments);
    }
    CanvasView.prototype.className = 'bk-canvas-wrapper';
    CanvasView.prototype.initialize = function (options) {
        CanvasView.__super__.initialize.call(this, options);
        this.map_el = this.model.map ? this.el.appendChild(dom_1.div({ 'class': 'bk-canvas-map' })) : null;
        this.events_el = this.el.appendChild(dom_1.div({ 'class': 'bk-canvas-events' }));
        this.overlays_el = this.el.appendChild(dom_1.div({ 'class': 'bk-canvas-overlays' }));
        switch (this.model.output_backend) {
        case 'canvas':
        case 'webgl':
            this.canvas_el = this.el.appendChild(dom_1.canvas({ 'class': 'bk-canvas' }));
            this._ctx = this.canvas_el.getContext('2d');
            break;
        case 'svg':
            this._ctx = new canvas2svg();
            this.canvas_el = this.el.appendChild(this._ctx.getSvg());
        }
        this.ctx = this.get_ctx();
        canvas_1.fixup_ctx(this.ctx);
        return logging_1.logger.debug('CanvasView initialized');
    };
    CanvasView.prototype.get_ctx = function () {
        return this._ctx;
    };
    CanvasView.prototype.get_canvas_element = function () {
        return this.canvas_el;
    };
    CanvasView.prototype.prepare_canvas = function () {
        var height, pixel_ratio, width;
        width = this.model._width.value;
        height = this.model._height.value;
        this.el.style.width = width + 'px';
        this.el.style.height = height + 'px';
        pixel_ratio = canvas_1.get_scale_ratio(this.ctx, this.model.use_hidpi, this.model.output_backend);
        this.model.pixel_ratio = pixel_ratio;
        this.canvas_el.style.width = width + 'px';
        this.canvas_el.style.height = height + 'px';
        this.canvas_el.setAttribute('width', width * pixel_ratio);
        this.canvas_el.setAttribute('height', height * pixel_ratio);
        return logging_1.logger.debug('Rendering CanvasView with width: ' + width + ', height: ' + height + ', pixel ratio: ' + pixel_ratio);
    };
    CanvasView.prototype.set_dims = function (arg) {
        var height, width;
        width = arg[0], height = arg[1];
        if (width === 0 || height === 0) {
            return;
        }
        if (this._width_constraint != null && this.solver.has_constraint(this._width_constraint)) {
            this.solver.remove_constraint(this._width_constraint);
        }
        if (this._height_constraint != null && this.solver.has_constraint(this._height_constraint)) {
            this.solver.remove_constraint(this._height_constraint);
        }
        this._width_constraint = solver_1.EQ(this.model._width, -width);
        this.solver.add_constraint(this._width_constraint);
        this._height_constraint = solver_1.EQ(this.model._height, -height);
        this.solver.add_constraint(this._height_constraint);
        return this.solver.update_variables();
    };
    return CanvasView;
}(dom_view_1.DOMView);
exports.Canvas = function (superClass) {
    extend(Canvas, superClass);
    function Canvas() {
        return Canvas.__super__.constructor.apply(this, arguments);
    }
    Canvas.prototype.type = 'Canvas';
    Canvas.prototype.default_view = exports.CanvasView;
    Canvas.internal({
        map: [
            p.Boolean,
            false
        ],
        initial_width: [p.Number],
        initial_height: [p.Number],
        use_hidpi: [
            p.Boolean,
            true
        ],
        pixel_ratio: [
            p.Number,
            1
        ],
        output_backend: [
            p.OutputBackend,
            'canvas'
        ]
    });
    Canvas.prototype.initialize = function (attrs, options) {
        Canvas.__super__.initialize.call(this, attrs, options);
        return this.panel = this;
    };
    Canvas.prototype.vx_to_sx = function (x) {
        return x;
    };
    Canvas.prototype.vy_to_sy = function (y) {
        return this._height.value - y;
    };
    Canvas.prototype.v_vx_to_sx = function (xx) {
        return new Float64Array(xx);
    };
    Canvas.prototype.v_vy_to_sy = function (yy) {
        var _yy, height, idx, j, len, y;
        _yy = new Float64Array(yy.length);
        height = this._height.value;
        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {
            y = yy[idx];
            _yy[idx] = height - y;
        }
        return _yy;
    };
    Canvas.prototype.sx_to_vx = function (x) {
        return x;
    };
    Canvas.prototype.sy_to_vy = function (y) {
        return this._height.value - y;
    };
    Canvas.prototype.v_sx_to_vx = function (xx) {
        return new Float64Array(xx);
    };
    Canvas.prototype.v_sy_to_vy = function (yy) {
        var _yy, height, idx, j, len, y;
        _yy = new Float64Array(yy.length);
        height = this._height.value;
        for (idx = j = 0, len = yy.length; j < len; idx = ++j) {
            y = yy[idx];
            _yy[idx] = height - y;
        }
        return _yy;
    };
    return Canvas;
}(layout_canvas_1.LayoutCanvas);    
},
/* models/canvas/cartesian_frame */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var categorical_scale_1 = require(161    /* ../scales/categorical_scale */);
var linear_scale_1 = require(163    /* ../scales/linear_scale */);
var log_scale_1 = require(164    /* ../scales/log_scale */);
var range1d_1 = require(155    /* ../ranges/range1d */);
var data_range1d_1 = require(151    /* ../ranges/data_range1d */);
var factor_range_1 = require(152    /* ../ranges/factor_range */);
var layout_canvas_1 = require(9    /* core/layout/layout_canvas */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.CartesianFrame = function (superClass) {
    extend(CartesianFrame, superClass);
    function CartesianFrame() {
        return CartesianFrame.__super__.constructor.apply(this, arguments);
    }
    CartesianFrame.prototype.type = 'CartesianFrame';
    CartesianFrame.prototype.initialize = function (attrs, options) {
        CartesianFrame.__super__.initialize.call(this, attrs, options);
        this.panel = this;
        this._configure_scales();
        this.connect(this.change, function (_this) {
            return function () {
                return _this._configure_scales();
            };
        }(this));
        return null;
    };
    CartesianFrame.prototype.contains = function (vx, vy) {
        return vx >= this._left.value && vx <= this._right.value && vy >= this._bottom.value && vy <= this._top.value;
    };
    CartesianFrame.prototype.map_to_screen = function (x, y, canvas, x_name, y_name) {
        var sx, sy, vx, vy;
        if (x_name == null) {
            x_name = 'default';
        }
        if (y_name == null) {
            y_name = 'default';
        }
        vx = this.xscales[x_name].v_compute(x);
        sx = canvas.v_vx_to_sx(vx);
        vy = this.yscales[y_name].v_compute(y);
        sy = canvas.v_vy_to_sy(vy);
        return [
            sx,
            sy
        ];
    };
    CartesianFrame.prototype._get_ranges = function (range, extra_ranges) {
        var extra_range, name, ranges;
        ranges = {};
        ranges['default'] = range;
        if (extra_ranges != null) {
            for (name in extra_ranges) {
                extra_range = extra_ranges[name];
                ranges[name] = extra_range;
            }
        }
        return ranges;
    };
    CartesianFrame.prototype._get_scales = function (scale, ranges, frame_range) {
        var name, range, s, scales;
        scales = {};
        for (name in ranges) {
            range = ranges[name];
            if (range instanceof data_range1d_1.DataRange1d || range instanceof range1d_1.Range1d) {
                if (!(scale instanceof log_scale_1.LogScale) && !(scale instanceof linear_scale_1.LinearScale)) {
                    throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                }
                if (scale instanceof categorical_scale_1.CategoricalScale) {
                    throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                }
            }
            if (range instanceof factor_range_1.FactorRange) {
                if (!(scale instanceof categorical_scale_1.CategoricalScale)) {
                    throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                }
            }
            if (scale instanceof log_scale_1.LogScale && range instanceof data_range1d_1.DataRange1d) {
                range.scale_hint = 'log';
            }
            s = scale.clone();
            s.setv({
                source_range: range,
                target_range: frame_range
            });
            scales[name] = s;
        }
        return scales;
    };
    CartesianFrame.prototype._configure_frame_ranges = function () {
        this._h_range = new range1d_1.Range1d({
            start: this._left.value,
            end: this._left.value + this._width.value
        });
        return this._v_range = new range1d_1.Range1d({
            start: this._bottom.value,
            end: this._bottom.value + this._height.value
        });
    };
    CartesianFrame.prototype._configure_scales = function () {
        this._configure_frame_ranges();
        this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);
        this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);
        this._xscales = this._get_scales(this.x_scale, this._x_ranges, this._h_range);
        return this._yscales = this._get_scales(this.y_scale, this._y_ranges, this._v_range);
    };
    CartesianFrame.prototype._update_scales = function () {
        var name, ref, ref1, scale;
        this._configure_frame_ranges();
        ref = this._xscales;
        for (name in ref) {
            scale = ref[name];
            scale.target_range = this._h_range;
        }
        ref1 = this._yscales;
        for (name in ref1) {
            scale = ref1[name];
            scale.target_range = this._v_range;
        }
        return null;
    };
    CartesianFrame.getters({
        h_range: function () {
            return this._h_range;
        },
        v_range: function () {
            return this._v_range;
        },
        x_ranges: function () {
            return this._x_ranges;
        },
        y_ranges: function () {
            return this._y_ranges;
        },
        xscales: function () {
            return this._xscales;
        },
        yscales: function () {
            return this._yscales;
        },
        x_mappers: function () {
            logging_1.logger.warn('x_mappers attr is deprecated, use xscales');
            return this._xscales;
        },
        y_mappers: function () {
            logging_1.logger.warn('y_mappers attr is deprecated, use yscales');
            return this._yscales;
        }
    });
    CartesianFrame.internal({
        extra_x_ranges: [
            p.Any,
            {}
        ],
        extra_y_ranges: [
            p.Any,
            {}
        ],
        x_range: [p.Instance],
        y_range: [p.Instance],
        x_scale: [p.Instance],
        y_scale: [p.Instance]
    });
    return CartesianFrame;
}(layout_canvas_1.LayoutCanvas);    
},
/* models/canvas/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var canvas_1 = require(76    /* ./canvas */);
exports.Canvas = canvas_1.Canvas;
var cartesian_frame_1 = require(77    /* ./cartesian_frame */);
exports.CartesianFrame = cartesian_frame_1.CartesianFrame;    
},
/* models/expressions/expression */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
exports.Expression = function (superClass) {
    extend(Expression, superClass);
    function Expression() {
        return Expression.__super__.constructor.apply(this, arguments);
    }
    Expression.prototype.initialize = function (attrs, options) {
        Expression.__super__.initialize.call(this, attrs, options);
        this._connected = {};
        return this._result = {};
    };
    Expression.prototype._v_compute = function (source) {
        if (this._connected[source.id] == null) {
            this.connect(source.change, function () {
                return this._result[source.id] = null;
            });
            this._connected[source.id] = true;
        }
        if (this._result[source.id] != null) {
            return this._result[source.id];
        }
        this._result[source.id] = this.v_compute(source);
        return this._result[source.id];
    };
    return Expression;
}(model_1.Model);    
},
/* models/expressions/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var expression_1 = require(79    /* ./expression */);
exports.Expression = expression_1.Expression;
var stack_1 = require(81    /* ./stack */);
exports.Stack = stack_1.Stack;    
},
/* models/expressions/stack */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var expression_1 = require(79    /* ./expression */);
var p = require(13    /* core/properties */);
exports.Stack = function (superClass) {
    extend(Stack, superClass);
    function Stack() {
        return Stack.__super__.constructor.apply(this, arguments);
    }
    Stack.define({
        fields: [
            p.Array,
            []
        ]
    });
    Stack.prototype.v_compute = function (source) {
        var f, i, j, k, len, len1, ref, ref1, result, x;
        result = new Float64Array(source.get_length());
        ref = this.fields;
        for (j = 0, len = ref.length; j < len; j++) {
            f = ref[j];
            ref1 = source.data[f];
            for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
                x = ref1[i];
                result[i] += x;
            }
        }
        return result;
    };
    return Stack;
}(expression_1.Expression);    
},
/* models/filters/boolean_filter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var filter_1 = require(84    /* ./filter */);
var p = require(13    /* core/properties */);
var logging_1 = require(12    /* core/logging */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
exports.BooleanFilter = function (superClass) {
    extend(BooleanFilter, superClass);
    function BooleanFilter() {
        return BooleanFilter.__super__.constructor.apply(this, arguments);
    }
    BooleanFilter.prototype.type = 'BooleanFilter';
    BooleanFilter.define({
        booleans: [
            p.Array,
            null
        ]
    });
    BooleanFilter.prototype.compute_indices = function (source) {
        var i, ref, ref1;
        if (((ref = this.booleans) != null ? ref.length : void 0) > 0) {
            if (array_1.all(this.booleans, types_1.isBoolean)) {
                if (this.booleans.length !== source.get_length()) {
                    logging_1.logger.warn('BooleanFilter ' + this.id + ': length of booleans doesn\'t match data source');
                }
                return function () {
                    var j, len, ref1, results;
                    ref1 = array_1.range(0, this.booleans.length);
                    results = [];
                    for (j = 0, len = ref1.length; j < len; j++) {
                        i = ref1[j];
                        if (this.booleans[i] === true) {
                            results.push(i);
                        }
                    }
                    return results;
                }.call(this);
            } else {
                logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans should be array of booleans, defaulting to no filtering');
                return null;
            }
        } else {
            if (((ref1 = this.booleans) != null ? ref1.length : void 0) === 0) {
                logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans is empty, defaulting to no filtering');
            } else {
                logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans was not set, defaulting to no filtering');
            }
            return null;
        }
    };
    return BooleanFilter;
}(filter_1.Filter);    
},
/* models/filters/customjs_filter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var filter_1 = require(84    /* ./filter */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
exports.CustomJSFilter = function (superClass) {
    extend(CustomJSFilter, superClass);
    function CustomJSFilter() {
        return CustomJSFilter.__super__.constructor.apply(this, arguments);
    }
    CustomJSFilter.prototype.type = 'CustomJSFilter';
    CustomJSFilter.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });
    CustomJSFilter.getters({
        values: function () {
            return this._make_values();
        },
        func: function () {
            return this._make_func();
        }
    });
    CustomJSFilter.prototype.compute_indices = function (source) {
        this.filter = this.func.apply(this, slice.call(this.values).concat([source], [require], [{}]));
        return CustomJSFilter.__super__.compute_indices.call(this);
    };
    CustomJSFilter.prototype._make_values = function () {
        return object_1.values(this.args);
    };
    CustomJSFilter.prototype._make_func = function () {
        return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor(), result = func.apply(child, args);
            return Object(result) === result ? result : child;
        }(Function, slice.call(Object.keys(this.args)).concat(['source'], ['require'], ['exports'], [this.code]), function () {
        });
    };
    return CustomJSFilter;
}(filter_1.Filter);    
},
/* models/filters/filter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
var array_1 = require(20    /* core/util/array */);
var logging_1 = require(12    /* core/logging */);
exports.Filter = function (superClass) {
    extend(Filter, superClass);
    function Filter() {
        return Filter.__super__.constructor.apply(this, arguments);
    }
    Filter.prototype.type = 'Filter';
    Filter.prototype.initialize = function (options) {
        return Filter.__super__.initialize.call(this, options);
    };
    Filter.define({
        filter: [
            p.Array,
            null
        ]
    });
    Filter.prototype.compute_indices = function () {
        var i, ref;
        if (((ref = this.filter) != null ? ref.length : void 0) >= 0) {
            if (array_1.all(this.filter, types_1.isBoolean)) {
                return function () {
                    var j, len, ref1, results;
                    ref1 = array_1.range(0, this.filter.length);
                    results = [];
                    for (j = 0, len = ref1.length; j < len; j++) {
                        i = ref1[j];
                        if (this.filter[i] === true) {
                            results.push(i);
                        }
                    }
                    return results;
                }.call(this);
            } else if (array_1.all(this.filter, types_1.isInteger)) {
                return this.filter;
            } else {
                logging_1.logger.warn('Filter ' + this.id + ': filter should either be array of only booleans or only integers, defaulting to no filtering');
                return null;
            }
        } else {
            logging_1.logger.warn('Filter ' + this.id + ': filter was not set to be an array, defaulting to no filtering');
            return null;
        }
    };
    return Filter;
}(model_1.Model);    
},
/* models/filters/group_filter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var filter_1 = require(84    /* ./filter */);
var p = require(13    /* core/properties */);
var logging_1 = require(12    /* core/logging */);
exports.GroupFilter = function (superClass) {
    extend(GroupFilter, superClass);
    function GroupFilter() {
        return GroupFilter.__super__.constructor.apply(this, arguments);
    }
    GroupFilter.prototype.type = 'GroupFilter';
    GroupFilter.define({
        column_name: [p.String],
        group: [p.String]
    });
    GroupFilter.prototype.compute_indices = function (source) {
        var column, i;
        column = source.get_column(this.column_name);
        if (column == null) {
            logging_1.logger.warn('group filter: groupby column not found in data source');
            return null;
        } else {
            this.indices = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = source.get_length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    if (column[i] === this.group) {
                        results.push(i);
                    }
                }
                return results;
            }.call(this);
            if (this.indices.length === 0) {
                logging_1.logger.warn('group filter: group \'' + this.group + '\' did not match any values in column \'' + this.column_name + '\'');
            }
            return this.indices;
        }
    };
    return GroupFilter;
}(filter_1.Filter);    
},
/* models/filters/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var boolean_filter_1 = require(82    /* ./boolean_filter */);
exports.BooleanFilter = boolean_filter_1.BooleanFilter;
var customjs_filter_1 = require(83    /* ./customjs_filter */);
exports.CustomJSFilter = customjs_filter_1.CustomJSFilter;
var filter_1 = require(84    /* ./filter */);
exports.Filter = filter_1.Filter;
var group_filter_1 = require(85    /* ./group_filter */);
exports.GroupFilter = group_filter_1.GroupFilter;
var index_filter_1 = require(87    /* ./index_filter */);
exports.IndexFilter = index_filter_1.IndexFilter;    
},
/* models/filters/index_filter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var filter_1 = require(84    /* ./filter */);
var p = require(13    /* core/properties */);
var logging_1 = require(12    /* core/logging */);
var types_1 = require(40    /* core/util/types */);
var array_1 = require(20    /* core/util/array */);
exports.IndexFilter = function (superClass) {
    extend(IndexFilter, superClass);
    function IndexFilter() {
        return IndexFilter.__super__.constructor.apply(this, arguments);
    }
    IndexFilter.prototype.type = 'IndexFilter';
    IndexFilter.define({
        indices: [
            p.Array,
            null
        ]
    });
    IndexFilter.prototype.compute_indices = function (source) {
        var ref;
        if (((ref = this.indices) != null ? ref.length : void 0) >= 0) {
            if (array_1.all(this.indices, types_1.isInteger)) {
                return this.indices;
            } else {
                logging_1.logger.warn('IndexFilter ' + this.id + ': indices should be array of integers, defaulting to no filtering');
                return null;
            }
        } else {
            logging_1.logger.warn('IndexFilter ' + this.id + ': indices was not set, defaulting to no filtering');
            return null;
        }
    };
    return IndexFilter;
}(filter_1.Filter);    
},
/* models/formatters/basic_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.BasicTickFormatter = function (superClass) {
    extend(BasicTickFormatter, superClass);
    function BasicTickFormatter() {
        return BasicTickFormatter.__super__.constructor.apply(this, arguments);
    }
    BasicTickFormatter.prototype.type = 'BasicTickFormatter';
    BasicTickFormatter.define({
        precision: [
            p.Any,
            'auto'
        ],
        use_scientific: [
            p.Bool,
            true
        ],
        power_limit_high: [
            p.Number,
            5
        ],
        power_limit_low: [
            p.Number,
            -3
        ]
    });
    BasicTickFormatter.getters({
        scientific_limit_low: function () {
            return Math.pow(10, this.power_limit_low);
        },
        scientific_limit_high: function () {
            return Math.pow(10, this.power_limit_high);
        }
    });
    BasicTickFormatter.prototype.initialize = function (attrs, options) {
        BasicTickFormatter.__super__.initialize.call(this, attrs, options);
        return this.last_precision = 3;
    };
    BasicTickFormatter.prototype.doFormat = function (ticks, axis) {
        var i, is_ok, j, k, l, labels, len, m, n, need_sci, o, precision, ref, ref1, ref2, ref3, ref4, tick, tick_abs, x, zero_eps;
        if (ticks.length === 0) {
            return [];
        }
        zero_eps = 0;
        if (ticks.length >= 2) {
            zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;
        }
        need_sci = false;
        if (this.use_scientific) {
            for (j = 0, len = ticks.length; j < len; j++) {
                tick = ticks[j];
                tick_abs = Math.abs(tick);
                if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {
                    need_sci = true;
                    break;
                }
            }
        }
        precision = this.precision;
        if (precision == null || types_1.isNumber(precision)) {
            labels = new Array(ticks.length);
            if (need_sci) {
                for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                    labels[i] = ticks[i].toExponential(precision || void 0);
                }
            } else {
                for (i = l = 0, ref1 = ticks.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    labels[i] = ticks[i].toFixed(precision || void 0).replace(/(\.[0-9]*?)0+$/, '$1').replace(/\.$/, '');
                }
            }
            return labels;
        } else if (precision === 'auto') {
            labels = new Array(ticks.length);
            for (x = m = ref2 = this.last_precision; ref2 <= 15 ? m <= 15 : m >= 15; x = ref2 <= 15 ? ++m : --m) {
                is_ok = true;
                if (need_sci) {
                    for (i = n = 0, ref3 = ticks.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
                        labels[i] = ticks[i].toExponential(x);
                        if (i > 0) {
                            if (labels[i] === labels[i - 1]) {
                                is_ok = false;
                                break;
                            }
                        }
                    }
                    if (is_ok) {
                        break;
                    }
                } else {
                    for (i = o = 0, ref4 = ticks.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {
                        labels[i] = ticks[i].toFixed(x).replace(/(\.[0-9]*?)0+$/, '$1').replace(/\.$/, '');
                        if (i > 0) {
                            if (labels[i] === labels[i - 1]) {
                                is_ok = false;
                                break;
                            }
                        }
                    }
                    if (is_ok) {
                        break;
                    }
                }
                if (is_ok) {
                    this.last_precision = x;
                    return labels;
                }
            }
        }
        return labels;
    };
    return BasicTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/categorical_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var tick_formatter_1 = require(97    /* ./tick_formatter */);
exports.CategoricalTickFormatter = function (superClass) {
    extend(CategoricalTickFormatter, superClass);
    function CategoricalTickFormatter() {
        return CategoricalTickFormatter.__super__.constructor.apply(this, arguments);
    }
    CategoricalTickFormatter.prototype.type = 'CategoricalTickFormatter';
    CategoricalTickFormatter.prototype.doFormat = function (ticks, axis) {
        return ticks;
    };
    return CategoricalTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/datetime_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _array, _strftime, _us, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var sprintf_js_1 = require(355    /* sprintf-js */);
var tz = require(356    /* timezone */);
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
_us = function (t) {
    return Math.round(t / 1000 % 1 * 1000000);
};
_array = function (t) {
    return tz(t, '%Y %m %d %H %M %S').split(/\s+/).map(function (e) {
        return parseInt(e, 10);
    });
};
_strftime = function (t, format) {
    var microsecond_replacement_string;
    if (types_1.isFunction(format)) {
        return format(t);
    } else {
        microsecond_replacement_string = sprintf_js_1.sprintf('$1%06d', _us(t));
        format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);
        if (format.indexOf('%') === -1) {
            return format;
        }
        return tz(t, format);
    }
};
exports.DatetimeTickFormatter = function (superClass) {
    extend(DatetimeTickFormatter, superClass);
    function DatetimeTickFormatter() {
        return DatetimeTickFormatter.__super__.constructor.apply(this, arguments);
    }
    DatetimeTickFormatter.prototype.type = 'DatetimeTickFormatter';
    DatetimeTickFormatter.define({
        microseconds: [
            p.Array,
            ['%fus']
        ],
        milliseconds: [
            p.Array,
            [
                '%3Nms',
                '%S.%3Ns'
            ]
        ],
        seconds: [
            p.Array,
            ['%Ss']
        ],
        minsec: [
            p.Array,
            [':%M:%S']
        ],
        minutes: [
            p.Array,
            [
                ':%M',
                '%Mm'
            ]
        ],
        hourmin: [
            p.Array,
            ['%H:%M']
        ],
        hours: [
            p.Array,
            [
                '%Hh',
                '%H:%M'
            ]
        ],
        days: [
            p.Array,
            [
                '%m/%d',
                '%a%d'
            ]
        ],
        months: [
            p.Array,
            [
                '%m/%Y',
                '%b%y'
            ]
        ],
        years: [
            p.Array,
            ['%Y']
        ]
    });
    DatetimeTickFormatter.prototype.format_order = [
        'microseconds',
        'milliseconds',
        'seconds',
        'minsec',
        'minutes',
        'hourmin',
        'hours',
        'days',
        'months',
        'years'
    ];
    DatetimeTickFormatter.prototype.strip_leading_zeros = true;
    DatetimeTickFormatter.prototype.initialize = function (attrs, options) {
        DatetimeTickFormatter.__super__.initialize.call(this, attrs, options);
        return this._update_width_formats();
    };
    DatetimeTickFormatter.prototype._update_width_formats = function () {
        var _widths, now;
        now = tz(new Date());
        _widths = function (fmt_strings) {
            var fmt_string, sizes, sorted;
            sizes = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = fmt_strings.length; j < len; j++) {
                    fmt_string = fmt_strings[j];
                    results.push(_strftime(now, fmt_string).length);
                }
                return results;
            }();
            sorted = array_1.sortBy(array_1.zip(sizes, fmt_strings), function (arg) {
                var fmt, size;
                size = arg[0], fmt = arg[1];
                return size;
            });
            return array_1.unzip(sorted);
        };
        return this._width_formats = {
            microseconds: _widths(this.microseconds),
            milliseconds: _widths(this.milliseconds),
            seconds: _widths(this.seconds),
            minsec: _widths(this.minsec),
            minutes: _widths(this.minutes),
            hourmin: _widths(this.hourmin),
            hours: _widths(this.hours),
            days: _widths(this.days),
            months: _widths(this.months),
            years: _widths(this.years)
        };
    };
    DatetimeTickFormatter.prototype._get_resolution_str = function (resolution_secs, span_secs) {
        var adjusted_secs;
        adjusted_secs = resolution_secs * 1.1;
        switch (false) {
        case !(adjusted_secs < 0.001):
            return 'microseconds';
        case !(adjusted_secs < 1):
            return 'milliseconds';
        case !(adjusted_secs < 60):
            if (span_secs >= 60) {
                return 'minsec';
            } else {
                return 'seconds';
            }
        case !(adjusted_secs < 3600):
            if (span_secs >= 3600) {
                return 'hourmin';
            } else {
                return 'minutes';
            }
        case !(adjusted_secs < 24 * 3600):
            return 'hours';
        case !(adjusted_secs < 31 * 24 * 3600):
            return 'days';
        case !(adjusted_secs < 365 * 24 * 3600):
            return 'months';
        default:
            return 'years';
        }
    };
    DatetimeTickFormatter.prototype.doFormat = function (ticks, axis, num_labels, char_width, fill_ratio, ticker) {
        var error, fmt, format, formats, good_formats, hybrid_handled, i, j, k, l, labels, len, len1, next_format, next_ndx, r, ref, ref1, ref2, resol, resol_ndx, s, span, ss, t, time_tuple_ndx_for_resol, tm, widths;
        if (num_labels == null) {
            num_labels = null;
        }
        if (char_width == null) {
            char_width = null;
        }
        if (fill_ratio == null) {
            fill_ratio = 0.3;
        }
        if (ticker == null) {
            ticker = null;
        }
        if (ticks.length === 0) {
            return [];
        }
        span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000;
        if (ticker) {
            r = ticker.resolution;
        } else {
            r = span / (ticks.length - 1);
        }
        resol = this._get_resolution_str(r, span);
        ref = this._width_formats[resol], widths = ref[0], formats = ref[1];
        format = formats[0];
        if (char_width) {
            good_formats = [];
            for (i = j = 0, ref1 = widths.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                if (widths[i] * ticks.length < fill_ratio * char_width) {
                    good_formats.push(this._width_formats[i]);
                }
            }
            if (good_formats.length > 0) {
                format = good_formats[good_formats.length - 1];
            }
        }
        labels = [];
        resol_ndx = this.format_order.indexOf(resol);
        time_tuple_ndx_for_resol = {};
        ref2 = this.format_order;
        for (k = 0, len = ref2.length; k < len; k++) {
            fmt = ref2[k];
            time_tuple_ndx_for_resol[fmt] = 0;
        }
        time_tuple_ndx_for_resol['seconds'] = 5;
        time_tuple_ndx_for_resol['minsec'] = 4;
        time_tuple_ndx_for_resol['minutes'] = 4;
        time_tuple_ndx_for_resol['hourmin'] = 3;
        time_tuple_ndx_for_resol['hours'] = 3;
        for (l = 0, len1 = ticks.length; l < len1; l++) {
            t = ticks[l];
            try {
                tm = _array(t);
                s = _strftime(t, format);
            } catch (error1) {
                error = error1;
                logging_1.logger.warn('unable to format tick for timestamp value ' + t);
                logging_1.logger.warn(' - ' + error);
                labels.push('ERR');
                continue;
            }
            hybrid_handled = false;
            next_ndx = resol_ndx;
            while (tm[time_tuple_ndx_for_resol[this.format_order[next_ndx]]] === 0) {
                next_ndx += 1;
                if (next_ndx === this.format_order.length) {
                    break;
                }
                if ((resol === 'minsec' || resol === 'hourmin') && !hybrid_handled) {
                    if (resol === 'minsec' && tm[4] === 0 && tm[5] !== 0 || resol === 'hourmin' && tm[3] === 0 && tm[4] !== 0) {
                        next_format = this._width_formats[this.format_order[resol_ndx - 1]][1][0];
                        s = _strftime(t, next_format);
                        break;
                    } else {
                        hybrid_handled = true;
                    }
                }
                next_format = this._width_formats[this.format_order[next_ndx]][1][0];
                s = _strftime(t, next_format);
            }
            if (this.strip_leading_zeros) {
                ss = s.replace(/^0+/g, '');
                if (ss !== s && isNaN(parseInt(ss))) {
                    ss = '0' + ss;
                }
                labels.push(ss);
            } else {
                labels.push(s);
            }
        }
        return labels;
    };
    return DatetimeTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/func_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
exports.FuncTickFormatter = function (superClass) {
    extend(FuncTickFormatter, superClass);
    function FuncTickFormatter() {
        return FuncTickFormatter.__super__.constructor.apply(this, arguments);
    }
    FuncTickFormatter.prototype.type = 'FuncTickFormatter';
    FuncTickFormatter.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });
    FuncTickFormatter.prototype._make_func = function () {
        return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor(), result = func.apply(child, args);
            return Object(result) === result ? result : child;
        }(Function, ['tick'].concat(slice.call(Object.keys(this.args)), ['require'], [this.code]), function () {
        });
    };
    FuncTickFormatter.prototype.doFormat = function (ticks, axis) {
        var func, tick;
        func = this._make_func();
        return function () {
            var i, len, results;
            results = [];
            for (i = 0, len = ticks.length; i < len; i++) {
                tick = ticks[i];
                results.push(func.apply(null, [tick].concat(slice.call(object_1.values(this.args)), [require])));
            }
            return results;
        }.call(this);
    };
    return FuncTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var basic_tick_formatter_1 = require(88    /* ./basic_tick_formatter */);
exports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;
var categorical_tick_formatter_1 = require(89    /* ./categorical_tick_formatter */);
exports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;
var datetime_tick_formatter_1 = require(90    /* ./datetime_tick_formatter */);
exports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;
var func_tick_formatter_1 = require(91    /* ./func_tick_formatter */);
exports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;
var log_tick_formatter_1 = require(93    /* ./log_tick_formatter */);
exports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;
var mercator_tick_formatter_1 = require(94    /* ./mercator_tick_formatter */);
exports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;
var numeral_tick_formatter_1 = require(95    /* ./numeral_tick_formatter */);
exports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;
var printf_tick_formatter_1 = require(96    /* ./printf_tick_formatter */);
exports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;
var tick_formatter_1 = require(97    /* ./tick_formatter */);
exports.TickFormatter = tick_formatter_1.TickFormatter;    
},
/* models/formatters/log_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var basic_tick_formatter_1 = require(88    /* ./basic_tick_formatter */);
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.LogTickFormatter = function (superClass) {
    extend(LogTickFormatter, superClass);
    function LogTickFormatter() {
        return LogTickFormatter.__super__.constructor.apply(this, arguments);
    }
    LogTickFormatter.prototype.type = 'LogTickFormatter';
    LogTickFormatter.define({
        ticker: [
            p.Instance,
            null
        ]
    });
    LogTickFormatter.prototype.initialize = function (attrs, options) {
        LogTickFormatter.__super__.initialize.call(this, attrs, options);
        this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();
        if (this.ticker == null) {
            return logging_1.logger.warn('LogTickFormatter not configured with a ticker, using default base of 10 (labels will be incorrect if ticker base is not 10)');
        }
    };
    LogTickFormatter.prototype.doFormat = function (ticks, axis) {
        var base, i, j, labels, ref, small_interval;
        if (ticks.length === 0) {
            return [];
        }
        if (this.ticker != null) {
            base = this.ticker.base;
        } else {
            base = 10;
        }
        small_interval = false;
        labels = new Array(ticks.length);
        for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            labels[i] = base + '^' + Math.round(Math.log(ticks[i]) / Math.log(base));
            if (i > 0 && labels[i] === labels[i - 1]) {
                small_interval = true;
                break;
            }
        }
        if (small_interval) {
            labels = this.basic_formatter.doFormat(ticks);
        }
        return labels;
    };
    return LogTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/mercator_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var basic_tick_formatter_1 = require(88    /* ./basic_tick_formatter */);
var p = require(13    /* core/properties */);
var proj4_1 = require(29    /* core/util/proj4 */);
exports.MercatorTickFormatter = function (superClass) {
    extend(MercatorTickFormatter, superClass);
    function MercatorTickFormatter() {
        return MercatorTickFormatter.__super__.constructor.apply(this, arguments);
    }
    MercatorTickFormatter.prototype.type = 'MercatorTickFormatter';
    MercatorTickFormatter.define({ dimension: [p.LatLon] });
    MercatorTickFormatter.prototype.doFormat = function (ticks, axis) {
        var i, j, k, lat, lon, proj_ticks, ref, ref1, ref2, ref3;
        if (this.dimension == null) {
            throw new Error('MercatorTickFormatter.dimension not configured');
        }
        if (ticks.length === 0) {
            return [];
        }
        proj_ticks = new Array(ticks.length);
        if (this.dimension === 'lon') {
            for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                ref1 = proj4_1.proj4(proj4_1.mercator).inverse([
                    ticks[i],
                    axis.loc
                ]), lon = ref1[0], lat = ref1[1];
                proj_ticks[i] = lon;
            }
        } else {
            for (i = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
                ref3 = proj4_1.proj4(proj4_1.mercator).inverse([
                    axis.loc,
                    ticks[i]
                ]), lon = ref3[0], lat = ref3[1];
                proj_ticks[i] = lat;
            }
        }
        return MercatorTickFormatter.__super__.doFormat.call(this, proj_ticks, axis);
    };
    return MercatorTickFormatter;
}(basic_tick_formatter_1.BasicTickFormatter);    
},
/* models/formatters/numeral_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var Numbro = require(325    /* numbro */);
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var p = require(13    /* core/properties */);
exports.NumeralTickFormatter = function (superClass) {
    extend(NumeralTickFormatter, superClass);
    function NumeralTickFormatter() {
        return NumeralTickFormatter.__super__.constructor.apply(this, arguments);
    }
    NumeralTickFormatter.prototype.type = 'NumeralTickFormatter';
    NumeralTickFormatter.define({
        format: [
            p.String,
            '0,0'
        ],
        language: [
            p.String,
            'en'
        ],
        rounding: [
            p.String,
            'round'
        ]
    });
    NumeralTickFormatter.prototype.doFormat = function (ticks, axis) {
        var format, labels, language, rounding, tick;
        format = this.format;
        language = this.language;
        rounding = function () {
            switch (this.rounding) {
            case 'round':
            case 'nearest':
                return Math.round;
            case 'floor':
            case 'rounddown':
                return Math.floor;
            case 'ceil':
            case 'roundup':
                return Math.ceil;
            }
        }.call(this);
        labels = function () {
            var i, len, results;
            results = [];
            for (i = 0, len = ticks.length; i < len; i++) {
                tick = ticks[i];
                results.push(Numbro.format(tick, format, language, rounding));
            }
            return results;
        }();
        return labels;
    };
    return NumeralTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/printf_tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var sprintf_js_1 = require(355    /* sprintf-js */);
var tick_formatter_1 = require(97    /* ./tick_formatter */);
var p = require(13    /* core/properties */);
exports.PrintfTickFormatter = function (superClass) {
    extend(PrintfTickFormatter, superClass);
    function PrintfTickFormatter() {
        return PrintfTickFormatter.__super__.constructor.apply(this, arguments);
    }
    PrintfTickFormatter.prototype.type = 'PrintfTickFormatter';
    PrintfTickFormatter.define({
        format: [
            p.String,
            '%s'
        ]
    });
    PrintfTickFormatter.prototype.doFormat = function (ticks, axis) {
        var format, labels, tick;
        format = this.format;
        labels = function () {
            var i, len, results;
            results = [];
            for (i = 0, len = ticks.length; i < len; i++) {
                tick = ticks[i];
                results.push(sprintf_js_1.sprintf(format, tick));
            }
            return results;
        }();
        return labels;
    };
    return PrintfTickFormatter;
}(tick_formatter_1.TickFormatter);    
},
/* models/formatters/tick_formatter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
exports.TickFormatter = function (superClass) {
    extend(TickFormatter, superClass);
    function TickFormatter() {
        return TickFormatter.__super__.constructor.apply(this, arguments);
    }
    TickFormatter.prototype.type = 'TickFormatter';
    TickFormatter.prototype.doFormat = function (ticks, axis) {
    };
    return TickFormatter;
}(model_1.Model);    
},
/* models/glyphs/annular_wedge */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
var math_1 = require(27    /* core/util/math */);
exports.AnnularWedgeView = function (superClass) {
    extend(AnnularWedgeView, superClass);
    function AnnularWedgeView() {
        return AnnularWedgeView.__super__.constructor.apply(this, arguments);
    }
    AnnularWedgeView.prototype._map_data = function () {
        var i, j, ref, results;
        if (this.model.properties.inner_radius.units === 'data') {
            this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);
        } else {
            this.sinner_radius = this._inner_radius;
        }
        if (this.model.properties.outer_radius.units === 'data') {
            this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);
        } else {
            this.souter_radius = this._outer_radius;
        }
        this._angle = new Float32Array(this._start_angle.length);
        results = [];
        for (i = j = 0, ref = this._start_angle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(this._angle[i] = this._end_angle[i] - this._start_angle[i]);
        }
        return results;
    };
    AnnularWedgeView.prototype._render = function (ctx, indices, arg) {
        var _angle, _start_angle, direction, i, j, len, results, sinner_radius, souter_radius, sx, sy;
        sx = arg.sx, sy = arg.sy, _start_angle = arg._start_angle, _angle = arg._angle, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;
        direction = this.model.properties.direction.value();
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i])) {
                continue;
            }
            ctx.translate(sx[i], sy[i]);
            ctx.rotate(_start_angle[i]);
            ctx.moveTo(souter_radius[i], 0);
            ctx.beginPath();
            ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);
            ctx.rotate(_angle[i]);
            ctx.lineTo(sinner_radius[i], 0);
            ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);
            ctx.closePath();
            ctx.rotate(-_angle[i] - _start_angle[i]);
            ctx.translate(-sx[i], -sy[i]);
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    AnnularWedgeView.prototype._hit_point = function (geometry) {
        var angle, bbox, candidates, direction, dist, hits, i, ir2, j, k, len, len1, or2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        if (this.model.properties.outer_radius.units === 'data') {
            x0 = x - this.max_outer_radius;
            x1 = x + this.max_outer_radius;
            y0 = y - this.max_outer_radius;
            y1 = y + this.max_outer_radius;
        } else {
            vx0 = vx - this.max_outer_radius;
            vx1 = vx + this.max_outer_radius;
            ref1 = this.renderer.xscale.v_invert([
                vx0,
                vx1
            ]), x0 = ref1[0], x1 = ref1[1];
            vy0 = vy - this.max_outer_radius;
            vy1 = vy + this.max_outer_radius;
            ref2 = this.renderer.yscale.v_invert([
                vy0,
                vy1
            ]), y0 = ref2[0], y1 = ref2[1];
        }
        candidates = [];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        ref3 = this.index.indices(bbox);
        for (j = 0, len = ref3.length; j < len; j++) {
            i = ref3[j];
            or2 = Math.pow(this.souter_radius[i], 2);
            ir2 = Math.pow(this.sinner_radius[i], 2);
            sx0 = this.renderer.xscale.compute(x);
            sx1 = this.renderer.xscale.compute(this._x[i]);
            sy0 = this.renderer.yscale.compute(y);
            sy1 = this.renderer.yscale.compute(this._y[i]);
            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
            if (dist <= or2 && dist >= ir2) {
                candidates.push([
                    i,
                    dist
                ]);
            }
        }
        direction = this.model.properties.direction.value();
        hits = [];
        for (k = 0, len1 = candidates.length; k < len1; k++) {
            ref4 = candidates[k], i = ref4[0], dist = ref4[1];
            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {
                hits.push([
                    i,
                    dist
                ]);
            }
        }
        return hittest.create_1d_hit_test_result(hits);
    };
    AnnularWedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    AnnularWedgeView.prototype._scxy = function (i) {
        var a, r;
        r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;
        a = (this._start_angle[i] + this._end_angle[i]) / 2;
        return {
            x: this.sx[i] + r * Math.cos(a),
            y: this.sy[i] + r * Math.sin(a)
        };
    };
    AnnularWedgeView.prototype.scx = function (i) {
        return this._scxy(i).x;
    };
    AnnularWedgeView.prototype.scy = function (i) {
        return this._scxy(i).y;
    };
    return AnnularWedgeView;
}(xy_glyph_1.XYGlyphView);
exports.AnnularWedge = function (superClass) {
    extend(AnnularWedge, superClass);
    function AnnularWedge() {
        return AnnularWedge.__super__.constructor.apply(this, arguments);
    }
    AnnularWedge.prototype.default_view = exports.AnnularWedgeView;
    AnnularWedge.prototype.type = 'AnnularWedge';
    AnnularWedge.mixins([
        'line',
        'fill'
    ]);
    AnnularWedge.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        inner_radius: [p.DistanceSpec],
        outer_radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });
    return AnnularWedge;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/annulus */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
exports.AnnulusView = function (superClass) {
    extend(AnnulusView, superClass);
    function AnnulusView() {
        return AnnulusView.__super__.constructor.apply(this, arguments);
    }
    AnnulusView.prototype._map_data = function () {
        if (this.model.properties.inner_radius.units === 'data') {
            this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);
        } else {
            this.sinner_radius = this._inner_radius;
        }
        if (this.model.properties.outer_radius.units === 'data') {
            return this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);
        } else {
            return this.souter_radius = this._outer_radius;
        }
    };
    AnnulusView.prototype._render = function (ctx, indices, arg) {
        var clockwise, i, isie, j, k, len, len1, ref, results, sinner_radius, souter_radius, sx, sy;
        sx = arg.sx, sy = arg.sy, sinner_radius = arg.sinner_radius, souter_radius = arg.souter_radius;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i])) {
                continue;
            }
            isie = navigator.userAgent.indexOf('MSIE') >= 0 || navigator.userAgent.indexOf('Trident') > 0 || navigator.userAgent.indexOf('Edge') > 0;
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.beginPath();
                if (isie) {
                    ref = [
                        false,
                        true
                    ];
                    for (k = 0, len1 = ref.length; k < len1; k++) {
                        clockwise = ref[k];
                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);
                        ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);
                    }
                } else {
                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);
                    ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);
                }
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.beginPath();
                ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);
                ctx.moveTo(sx[i] + souter_radius[i], sy[i]);
                ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    AnnulusView.prototype._hit_point = function (geometry) {
        var bbox, dist, hits, i, ir2, j, len, or2, ref, ref1, sx0, sx1, sy0, sy1, vx, vy, x, x0, x1, y, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        x0 = x - this.max_radius;
        x1 = x + this.max_radius;
        y = this.renderer.yscale.invert(vy);
        y0 = y - this.max_radius;
        y1 = y + this.max_radius;
        hits = [];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        ref1 = this.index.indices(bbox);
        for (j = 0, len = ref1.length; j < len; j++) {
            i = ref1[j];
            or2 = Math.pow(this.souter_radius[i], 2);
            ir2 = Math.pow(this.sinner_radius[i], 2);
            sx0 = this.renderer.xscale.compute(x);
            sx1 = this.renderer.xscale.compute(this._x[i]);
            sy0 = this.renderer.yscale.compute(y);
            sy1 = this.renderer.yscale.compute(this._y[i]);
            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
            if (dist <= or2 && dist >= ir2) {
                hits.push([
                    i,
                    dist
                ]);
            }
        }
        return hittest.create_1d_hit_test_result(hits);
    };
    AnnulusView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        var data, indices, r, sinner_radius, souter_radius, sx, sy;
        indices = [index];
        sx = {};
        sx[index] = (x0 + x1) / 2;
        sy = {};
        sy[index] = (y0 + y1) / 2;
        r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;
        sinner_radius = {};
        sinner_radius[index] = r * 0.4;
        souter_radius = {};
        souter_radius[index] = r * 0.8;
        data = {
            sx: sx,
            sy: sy,
            sinner_radius: sinner_radius,
            souter_radius: souter_radius
        };
        return this._render(ctx, indices, data);
    };
    return AnnulusView;
}(xy_glyph_1.XYGlyphView);
exports.Annulus = function (superClass) {
    extend(Annulus, superClass);
    function Annulus() {
        return Annulus.__super__.constructor.apply(this, arguments);
    }
    Annulus.prototype.default_view = exports.AnnulusView;
    Annulus.prototype.type = 'Annulus';
    Annulus.mixins([
        'line',
        'fill'
    ]);
    Annulus.define({
        inner_radius: [p.DistanceSpec],
        outer_radius: [p.DistanceSpec]
    });
    return Annulus;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/arc */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
exports.ArcView = function (superClass) {
    extend(ArcView, superClass);
    function ArcView() {
        return ArcView.__super__.constructor.apply(this, arguments);
    }
    ArcView.prototype._map_data = function () {
        if (this.model.properties.radius.units === 'data') {
            return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);
        } else {
            return this.sradius = this._radius;
        }
    };
    ArcView.prototype._render = function (ctx, indices, arg) {
        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;
        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;
        if (this.visuals.line.doit) {
            direction = this.model.properties.direction.value();
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            }
            return results;
        }
    };
    ArcView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return ArcView;
}(xy_glyph_1.XYGlyphView);
exports.Arc = function (superClass) {
    extend(Arc, superClass);
    function Arc() {
        return Arc.__super__.constructor.apply(this, arguments);
    }
    Arc.prototype.default_view = exports.ArcView;
    Arc.prototype.type = 'Arc';
    Arc.mixins(['line']);
    Arc.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });
    return Arc;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/bezier */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _cbb, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
_cbb = function (x0, y0, x1, y1, x2, y2, x3, y3) {
    var a, b, b2ac, bounds, c, i, j, jlen, k, mt, sqrtb2ac, t, t1, t2, tvalues, x, y;
    tvalues = [];
    bounds = [
        [],
        []
    ];
    for (i = k = 0; k <= 2; i = ++k) {
        if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
        } else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
        }
        if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
                continue;
            }
            t = -c / b;
            if (0 < t && t < 1) {
                tvalues.push(t);
            }
            continue;
        }
        b2ac = b * b - 4 * c * a;
        sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
            continue;
        }
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
            tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
            tvalues.push(t2);
        }
    }
    j = tvalues.length;
    jlen = j;
    while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
        bounds[0][j] = x;
        y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        bounds[1][j] = y;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    return [
        Math.min.apply(null, bounds[0]),
        Math.max.apply(null, bounds[1]),
        Math.max.apply(null, bounds[0]),
        Math.min.apply(null, bounds[1])
    ];
};
exports.BezierView = function (superClass) {
    extend(BezierView, superClass);
    function BezierView() {
        return BezierView.__super__.constructor.apply(this, arguments);
    }
    BezierView.prototype._index_data = function () {
        var i, k, points, ref, ref1, x0, x1, y0, y1;
        points = [];
        for (i = k = 0, ref = this._x0.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i])) {
                continue;
            }
            ref1 = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]), x0 = ref1[0], y0 = ref1[1], x1 = ref1[2], y1 = ref1[3];
            points.push({
                minX: x0,
                minY: y0,
                maxX: x1,
                maxY: y1,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    BezierView.prototype._render = function (ctx, indices, arg) {
        var i, k, len, results, scx, scx0, scx1, scy0, scy1, sx0, sx1, sy0, sy1;
        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scx0 = arg.scx0, scy0 = arg.scy0, scx1 = arg.scx1, scy1 = arg.scy1;
        if (this.visuals.line.doit) {
            results = [];
            for (k = 0, len = indices.length; k < len; k++) {
                i = indices[k];
                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.moveTo(sx0[i], sy0[i]);
                ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            }
            return results;
        }
    };
    BezierView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return BezierView;
}(glyph_1.GlyphView);
exports.Bezier = function (superClass) {
    extend(Bezier, superClass);
    function Bezier() {
        return Bezier.__super__.constructor.apply(this, arguments);
    }
    Bezier.prototype.default_view = exports.BezierView;
    Bezier.prototype.type = 'Bezier';
    Bezier.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ],
        [
            'cx0',
            'cy0'
        ],
        [
            'cx1',
            'cy1'
        ]
    ]);
    Bezier.mixins(['line']);
    return Bezier;
}(glyph_1.Glyph);    
},
/* models/glyphs/circle */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
exports.CircleView = function (superClass) {
    extend(CircleView, superClass);
    function CircleView() {
        return CircleView.__super__.constructor.apply(this, arguments);
    }
    CircleView.prototype._map_data = function () {
        var rd, s;
        if (this._radius != null) {
            if (this.model.properties.radius.spec.units === 'data') {
                rd = this.model.properties.radius_dimension.spec.value;
                return this.sradius = this.sdist(this.renderer[rd + 'scale'], this['_' + rd], this._radius);
            } else {
                this.sradius = this._radius;
                return this.max_size = 2 * this.max_radius;
            }
        } else {
            return this.sradius = function () {
                var j, len, ref, results;
                ref = this._size;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    s = ref[j];
                    results.push(s / 2);
                }
                return results;
            }.call(this);
        }
    };
    CircleView.prototype._mask_data = function (all_indices) {
        var bbox, hr, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, vr, x0, x1, y0, y1;
        hr = this.renderer.plot_view.frame.h_range;
        vr = this.renderer.plot_view.frame.v_range;
        if (this._radius != null && this.model.properties.radius.units === 'data') {
            sx0 = hr.start;
            sx1 = hr.end;
            ref = this.renderer.xscale.v_invert([
                sx0,
                sx1
            ]), x0 = ref[0], x1 = ref[1];
            x0 -= this.max_radius;
            x1 += this.max_radius;
            sy0 = vr.start;
            sy1 = vr.end;
            ref1 = this.renderer.yscale.v_invert([
                sy0,
                sy1
            ]), y0 = ref1[0], y1 = ref1[1];
            y0 -= this.max_radius;
            y1 += this.max_radius;
        } else {
            sx0 = hr.start - this.max_size;
            sx1 = hr.end + this.max_size;
            ref2 = this.renderer.xscale.v_invert([
                sx0,
                sx1
            ]), x0 = ref2[0], x1 = ref2[1];
            sy0 = vr.start - this.max_size;
            sy1 = vr.end + this.max_size;
            ref3 = this.renderer.yscale.v_invert([
                sy0,
                sy1
            ]), y0 = ref3[0], y1 = ref3[1];
        }
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        return this.index.indices(bbox);
    };
    CircleView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sradius, sx, sy;
        sx = arg.sx, sy = arg.sy, sradius = arg.sradius;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sradius[i])) {
                continue;
            }
            ctx.beginPath();
            ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    CircleView.prototype._hit_point = function (geometry) {
        var bbox, candidates, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        if (this._radius != null && this.model.properties.radius.units === 'data') {
            x0 = x - this.max_radius;
            x1 = x + this.max_radius;
            y0 = y - this.max_radius;
            y1 = y + this.max_radius;
        } else {
            vx0 = vx - this.max_size;
            vx1 = vx + this.max_size;
            ref1 = this.renderer.xscale.v_invert([
                vx0,
                vx1
            ]), x0 = ref1[0], x1 = ref1[1];
            ref2 = [
                Math.min(x0, x1),
                Math.max(x0, x1)
            ], x0 = ref2[0], x1 = ref2[1];
            vy0 = vy - this.max_size;
            vy1 = vy + this.max_size;
            ref3 = this.renderer.yscale.v_invert([
                vy0,
                vy1
            ]), y0 = ref3[0], y1 = ref3[1];
            ref4 = [
                Math.min(y0, y1),
                Math.max(y0, y1)
            ], y0 = ref4[0], y1 = ref4[1];
        }
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        candidates = this.index.indices(bbox);
        hits = [];
        if (this._radius != null && this.model.properties.radius.units === 'data') {
            for (j = 0, len = candidates.length; j < len; j++) {
                i = candidates[j];
                r2 = Math.pow(this.sradius[i], 2);
                sx0 = this.renderer.xscale.compute(x);
                sx1 = this.renderer.xscale.compute(this._x[i]);
                sy0 = this.renderer.yscale.compute(y);
                sy1 = this.renderer.yscale.compute(this._y[i]);
                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                if (dist <= r2) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
        } else {
            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
            for (k = 0, len1 = candidates.length; k < len1; k++) {
                i = candidates[k];
                r2 = Math.pow(this.sradius[i], 2);
                dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                if (dist <= r2) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
        }
        return hittest.create_1d_hit_test_result(hits);
    };
    CircleView.prototype._hit_span = function (geometry) {
        var bbox, hits, maxX, maxY, minX, minY, ms, ref, ref1, ref2, ref3, ref4, ref5, result, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        ref1 = this.bounds(), minX = ref1.minX, minY = ref1.minY, maxX = ref1.maxX, maxY = ref1.maxY;
        result = hittest.create_hit_test_result();
        if (geometry.direction === 'h') {
            y0 = minY;
            y1 = maxY;
            if (this._radius != null && this.model.properties.radius.units === 'data') {
                vx0 = vx - this.max_radius;
                vx1 = vx + this.max_radius;
                ref2 = this.renderer.xscale.v_invert([
                    vx0,
                    vx1
                ]), x0 = ref2[0], x1 = ref2[1];
            } else {
                ms = this.max_size / 2;
                vx0 = vx - ms;
                vx1 = vx + ms;
                ref3 = this.renderer.xscale.v_invert([
                    vx0,
                    vx1
                ]), x0 = ref3[0], x1 = ref3[1];
            }
        } else {
            x0 = minX;
            x1 = maxX;
            if (this._radius != null && this.model.properties.radius.units === 'data') {
                vy0 = vy - this.max_radius;
                vy1 = vy + this.max_radius;
                ref4 = this.renderer.yscale.v_invert([
                    vy0,
                    vy1
                ]), y0 = ref4[0], y1 = ref4[1];
            } else {
                ms = this.max_size / 2;
                vy0 = vy - ms;
                vy1 = vy + ms;
                ref5 = this.renderer.yscale.v_invert([
                    vy0,
                    vy1
                ]), y0 = ref5[0], y1 = ref5[1];
            }
        }
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        hits = this.index.indices(bbox);
        result['1d'].indices = hits;
        return result;
    };
    CircleView.prototype._hit_rect = function (geometry) {
        var bbox, ref, ref1, result, x0, x1, y0, y1;
        ref = this.renderer.xscale.v_invert([
            geometry.vx0,
            geometry.vx1
        ]), x0 = ref[0], x1 = ref[1];
        ref1 = this.renderer.yscale.v_invert([
            geometry.vy0,
            geometry.vy1
        ]), y0 = ref1[0], y1 = ref1[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        result = hittest.create_hit_test_result();
        result['1d'].indices = this.index.indices(bbox);
        return result;
    };
    CircleView.prototype._hit_poly = function (geometry) {
        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);
        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);
        candidates = function () {
            results = [];
            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {
                results.push(j);
            }
            return results;
        }.apply(this);
        hits = [];
        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
            idx = candidates[i];
            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                hits.push(idx);
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    CircleView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        var data, indices, sradius, sx, sy;
        indices = [index];
        sx = {};
        sx[index] = (x0 + x1) / 2;
        sy = {};
        sy[index] = (y0 + y1) / 2;
        sradius = {};
        sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;
        data = {
            sx: sx,
            sy: sy,
            sradius: sradius
        };
        return this._render(ctx, indices, data);
    };
    return CircleView;
}(xy_glyph_1.XYGlyphView);
exports.Circle = function (superClass) {
    extend(Circle, superClass);
    function Circle() {
        return Circle.__super__.constructor.apply(this, arguments);
    }
    Circle.prototype.default_view = exports.CircleView;
    Circle.prototype.type = 'Circle';
    Circle.mixins([
        'line',
        'fill'
    ]);
    Circle.define({
        angle: [
            p.AngleSpec,
            0
        ],
        size: [
            p.DistanceSpec,
            {
                units: 'screen',
                value: 4
            }
        ],
        radius: [
            p.DistanceSpec,
            null
        ],
        radius_dimension: [
            p.String,
            'x'
        ]
    });
    Circle.prototype.initialize = function (attrs, options) {
        Circle.__super__.initialize.call(this, attrs, options);
        return this.properties.radius.optional = true;
    };
    return Circle;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/ellipse */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
exports.EllipseView = function (superClass) {
    extend(EllipseView, superClass);
    function EllipseView() {
        return EllipseView.__super__.constructor.apply(this, arguments);
    }
    EllipseView.prototype._set_data = function () {
        this.max_w2 = 0;
        if (this.model.properties.width.units === 'data') {
            this.max_w2 = this.max_width / 2;
        }
        this.max_h2 = 0;
        if (this.model.properties.height.units === 'data') {
            return this.max_h2 = this.max_height / 2;
        }
    };
    EllipseView.prototype._map_data = function () {
        if (this.model.properties.width.units === 'data') {
            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
        } else {
            this.sw = this._width;
        }
        if (this.model.properties.height.units === 'data') {
            return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
        } else {
            return this.sh = this._height;
        }
    };
    EllipseView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sh, sw, sx, sy;
        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {
                continue;
            }
            ctx.beginPath();
            ctx.ellipse(sx[i], sy[i], sw[i] / 2, sh[i] / 2, this._angle[i], 0, 2 * Math.PI);
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    EllipseView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        var d, data, indices, scale, sh, sw, sx, sy;
        indices = [index];
        sx = {};
        sx[index] = (x0 + x1) / 2;
        sy = {};
        sy[index] = (y0 + y1) / 2;
        scale = this.sw[index] / this.sh[index];
        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
        sw = {};
        sh = {};
        if (scale > 1) {
            sw[index] = d;
            sh[index] = d / scale;
        } else {
            sw[index] = d * scale;
            sh[index] = d;
        }
        data = {
            sx: sx,
            sy: sy,
            sw: sw,
            sh: sh
        };
        return this._render(ctx, indices, data);
    };
    EllipseView.prototype._bounds = function (bds) {
        return this.max_wh2_bounds(bds);
    };
    return EllipseView;
}(xy_glyph_1.XYGlyphView);
exports.Ellipse = function (superClass) {
    extend(Ellipse, superClass);
    function Ellipse() {
        return Ellipse.__super__.constructor.apply(this, arguments);
    }
    Ellipse.prototype.default_view = exports.EllipseView;
    Ellipse.prototype.type = 'Ellipse';
    Ellipse.mixins([
        'line',
        'fill'
    ]);
    Ellipse.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec]
    });
    return Ellipse;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/glyph */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var bbox = require(21    /* core/util/bbox */);
var proj = require(30    /* core/util/projections */);
var view_1 = require(43    /* core/view */);
var model_1 = require(48    /* ../../model */);
var visuals_1 = require(44    /* core/visuals */);
var logging_1 = require(12    /* core/logging */);
var object_1 = require(28    /* core/util/object */);
var types_1 = require(40    /* core/util/types */);
var line_1 = require(110    /* ./line */);
exports.GlyphView = function (superClass) {
    extend1(GlyphView, superClass);
    function GlyphView() {
        return GlyphView.__super__.constructor.apply(this, arguments);
    }
    GlyphView.prototype.initialize = function (options) {
        var Cls, ctx, e, glglyphs;
        GlyphView.__super__.initialize.call(this, options);
        this._nohit_warned = {};
        this.renderer = options.renderer;
        this.visuals = new visuals_1.Visuals(this.model);
        ctx = this.renderer.plot_view.canvas_view.ctx;
        if (ctx.glcanvas != null) {
            try {
                glglyphs = require(418    /* ./webgl/index */);
            } catch (error) {
                e = error;
                if (e.code === 'MODULE_NOT_FOUND') {
                    logging_1.logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');
                    glglyphs = null;
                } else {
                    throw e;
                }
            }
            if (glglyphs != null) {
                Cls = glglyphs[this.model.type + 'GLGlyph'];
                if (Cls != null) {
                    return this.glglyph = new Cls(ctx.glcanvas.gl, this);
                }
            }
        }
    };
    GlyphView.prototype.set_visuals = function (source) {
        this.visuals.warm_cache(source);
        if (this.glglyph != null) {
            return this.glglyph.set_visuals_changed();
        }
    };
    GlyphView.prototype.render = function (ctx, indices, data) {
        ctx.beginPath();
        if (this.glglyph != null) {
            if (this.glglyph.render(ctx, indices, data)) {
                return;
            }
        }
        return this._render(ctx, indices, data);
    };
    GlyphView.prototype.has_finished = function () {
        return true;
    };
    GlyphView.prototype.notify_finished = function () {
        return this.renderer.notify_finished();
    };
    GlyphView.prototype.bounds = function () {
        if (this.index == null) {
            return bbox.empty();
        } else {
            return this._bounds(this.index.bbox);
        }
    };
    GlyphView.prototype.log_bounds = function () {
        var bb, j, l, len, len1, positive_x_bbs, positive_y_bbs, x, y;
        if (this.index == null) {
            return bbox.empty();
        }
        bb = bbox.empty();
        positive_x_bbs = this.index.search(bbox.positive_x());
        positive_y_bbs = this.index.search(bbox.positive_y());
        for (j = 0, len = positive_x_bbs.length; j < len; j++) {
            x = positive_x_bbs[j];
            if (x.minX < bb.minX) {
                bb.minX = x.minX;
            }
            if (x.maxX > bb.maxX) {
                bb.maxX = x.maxX;
            }
        }
        for (l = 0, len1 = positive_y_bbs.length; l < len1; l++) {
            y = positive_y_bbs[l];
            if (y.minY < bb.minY) {
                bb.minY = y.minY;
            }
            if (y.maxY > bb.maxY) {
                bb.maxY = y.maxY;
            }
        }
        return this._bounds(bb);
    };
    GlyphView.prototype.max_wh2_bounds = function (bds) {
        return {
            minX: bds.minX - this.max_w2,
            maxX: bds.maxX + this.max_w2,
            minY: bds.minY - this.max_h2,
            maxY: bds.maxY + this.max_h2
        };
    };
    GlyphView.prototype.get_anchor_point = function (anchor, i, arg) {
        var sx, sy;
        sx = arg[0], sy = arg[1];
        switch (anchor) {
        case 'center':
            return {
                x: this.scx(i, sx, sy),
                y: this.scy(i, sx, sy)
            };
        default:
            return null;
        }
    };
    GlyphView.prototype.scx = function (i) {
        return this.sx[i];
    };
    GlyphView.prototype.scy = function (i) {
        return this.sy[i];
    };
    GlyphView.prototype.sdist = function (scale, pts, spans, pts_location, dilate) {
        var d, halfspan, i, pt0, pt1, spt0, spt1;
        if (pts_location == null) {
            pts_location = 'edge';
        }
        if (dilate == null) {
            dilate = false;
        }
        if (scale.source_range.v_synthetic != null) {
            pts = scale.source_range.v_synthetic(pts);
        }
        if (pts_location === 'center') {
            halfspan = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = spans.length; j < len; j++) {
                    d = spans[j];
                    results.push(d / 2);
                }
                return results;
            }();
            pt0 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(pts[i] - halfspan[i]);
                }
                return results;
            }();
            pt1 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(pts[i] + halfspan[i]);
                }
                return results;
            }();
        } else {
            pt0 = pts;
            pt1 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(pt0[i] + spans[i]);
                }
                return results;
            }();
        }
        spt0 = scale.v_compute(pt0);
        spt1 = scale.v_compute(pt1);
        if (dilate) {
            return function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Math.ceil(Math.abs(spt1[i] - spt0[i])));
                }
                return results;
            }();
        } else {
            return function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Math.abs(spt1[i] - spt0[i]));
                }
                return results;
            }();
        }
    };
    GlyphView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return null;
    };
    GlyphView.prototype._generic_line_legend = function (ctx, x0, x1, y0, y1, index) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x0, (y0 + y1) / 2);
        ctx.lineTo(x1, (y0 + y1) / 2);
        if (this.visuals.line.doit) {
            this.visuals.line.set_vectorize(ctx, index);
            ctx.stroke();
        }
        return ctx.restore();
    };
    GlyphView.prototype._generic_area_legend = function (ctx, x0, x1, y0, y1, index) {
        var dh, dw, h, indices, sx0, sx1, sy0, sy1, w;
        indices = [index];
        w = Math.abs(x1 - x0);
        dw = w * 0.1;
        h = Math.abs(y1 - y0);
        dh = h * 0.1;
        sx0 = x0 + dw;
        sx1 = x1 - dw;
        sy0 = y0 + dh;
        sy1 = y1 - dh;
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_vectorize(ctx, index);
            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);
        }
        if (this.visuals.line.doit) {
            ctx.beginPath();
            ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);
            this.visuals.line.set_vectorize(ctx, index);
            return ctx.stroke();
        }
    };
    GlyphView.prototype.hit_test = function (geometry) {
        var func, result;
        result = null;
        func = '_hit_' + geometry.type;
        if (this[func] != null) {
            result = this[func](geometry);
        } else if (this._nohit_warned[geometry.type] == null) {
            logging_1.logger.debug('\'' + geometry.type + '\' selection not available for ' + this.model.type);
            this._nohit_warned[geometry.type] = true;
        }
        return result;
    };
    GlyphView.prototype.set_data = function (source, indices, indices_to_update) {
        var data, data_subset, i, j, k, len, ref, ref1, ref2, ref3, v, xname, xr, yname, yr;
        data = this.model.materialize_dataspecs(source);
        if (indices && !(this instanceof line_1.LineView)) {
            data_subset = {};
            for (k in data) {
                v = data[k];
                if (k.charAt(0) === '_') {
                    data_subset[k] = function () {
                        var j, len, results;
                        results = [];
                        for (j = 0, len = indices.length; j < len; j++) {
                            i = indices[j];
                            results.push(v[i]);
                        }
                        return results;
                    }();
                } else {
                    data_subset[k] = v;
                }
            }
            data = data_subset;
        }
        object_1.extend(this, data);
        if (this.renderer.plot_view.model.use_map) {
            if (this._x != null) {
                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];
            }
            if (this._xs != null) {
                ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1];
            }
        }
        if (this.renderer.plot_view.frame.x_ranges != null) {
            xr = this.renderer.plot_view.frame.x_ranges[this.model.x_range_name];
            yr = this.renderer.plot_view.frame.y_ranges[this.model.y_range_name];
            ref2 = this.model._coords;
            for (j = 0, len = ref2.length; j < len; j++) {
                ref3 = ref2[j], xname = ref3[0], yname = ref3[1];
                xname = '_' + xname;
                yname = '_' + yname;
                if (xr.v_synthetic != null) {
                    this[xname] = xr.v_synthetic(this[xname]);
                }
                if (yr.v_synthetic != null) {
                    this[yname] = yr.v_synthetic(this[yname]);
                }
            }
        }
        if (this.glglyph != null) {
            this.glglyph.set_data_changed(this._x.length);
        }
        this._set_data(source, indices_to_update);
        return this.index = this._index_data();
    };
    GlyphView.prototype._set_data = function () {
    };
    GlyphView.prototype._index_data = function () {
    };
    GlyphView.prototype.mask_data = function (indices) {
        if (this.glglyph != null) {
            return indices;
        } else {
            return this._mask_data(indices);
        }
    };
    GlyphView.prototype._mask_data = function (indices) {
        return indices;
    };
    GlyphView.prototype._bounds = function (bounds) {
        return bounds;
    };
    GlyphView.prototype.map_data = function () {
        var i, j, l, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sx, sxname, sy, syname, xname, yname;
        ref = this.model._coords;
        for (j = 0, len = ref.length; j < len; j++) {
            ref1 = ref[j], xname = ref1[0], yname = ref1[1];
            sxname = 's' + xname;
            syname = 's' + yname;
            xname = '_' + xname;
            yname = '_' + yname;
            if (types_1.isArray((ref2 = this[xname]) != null ? ref2[0] : void 0) || ((ref3 = this[xname]) != null ? (ref4 = ref3[0]) != null ? ref4.buffer : void 0 : void 0) instanceof ArrayBuffer) {
                ref5 = [
                    [],
                    []
                ], this[sxname] = ref5[0], this[syname] = ref5[1];
                for (i = l = 0, ref6 = this[xname].length; 0 <= ref6 ? l < ref6 : l > ref6; i = 0 <= ref6 ? ++l : --l) {
                    ref7 = this.map_to_screen(this[xname][i], this[yname][i]), sx = ref7[0], sy = ref7[1];
                    this[sxname].push(sx);
                    this[syname].push(sy);
                }
            } else {
                ref8 = this.map_to_screen(this[xname], this[yname]), this[sxname] = ref8[0], this[syname] = ref8[1];
            }
        }
        return this._map_data();
    };
    GlyphView.prototype._map_data = function () {
    };
    GlyphView.prototype.map_to_screen = function (x, y) {
        return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);
    };
    return GlyphView;
}(view_1.View);
exports.Glyph = function (superClass) {
    extend1(Glyph, superClass);
    function Glyph() {
        return Glyph.__super__.constructor.apply(this, arguments);
    }
    Glyph.prototype._coords = [];
    Glyph.coords = function (coords) {
        var _coords, j, len, ref, result, x, y;
        _coords = this.prototype._coords.concat(coords);
        this.prototype._coords = _coords;
        result = {};
        for (j = 0, len = coords.length; j < len; j++) {
            ref = coords[j], x = ref[0], y = ref[1];
            result[x] = [p.NumberSpec];
            result[y] = [p.NumberSpec];
        }
        return this.define(result);
    };
    Glyph.internal({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    return Glyph;
}(model_1.Model);    
},
/* models/glyphs/hbar */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
exports.HBarView = function (superClass) {
    extend(HBarView, superClass);
    function HBarView() {
        return HBarView.__super__.constructor.apply(this, arguments);
    }
    HBarView.prototype._map_data = function () {
        var i, j, ref, vleft, vright, vy;
        vy = this.renderer.yscale.v_compute(this._y);
        this.sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);
        vright = this.renderer.xscale.v_compute(this._right);
        this.sright = this.renderer.plot_view.canvas.v_vx_to_sx(vright);
        vleft = this.renderer.xscale.v_compute(this._left);
        this.sleft = this.renderer.plot_view.canvas.v_vx_to_sx(vleft);
        this.stop = [];
        this.sbottom = [];
        this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
        for (i = j = 0, ref = this.sy.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.stop.push(this.sy[i] - this.sh[i] / 2);
            this.sbottom.push(this.sy[i] + this.sh[i] / 2);
        }
        return null;
    };
    HBarView.prototype._index_data = function () {
        var b, i, j, l, points, r, ref, t;
        points = [];
        for (i = j = 0, ref = this._y.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            l = Math.min(this._left[i], this._right[i]);
            r = Math.max(this._left[i], this._right[i]);
            t = this._y[i] + 0.5 * this._height[i];
            b = this._y[i] - 0.5 * this._height[i];
            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {
                continue;
            }
            points.push({
                minX: l,
                minY: b,
                maxX: r,
                maxY: t,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    HBarView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sbottom, sleft, sright, stop;
        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {
                continue;
            }
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
            }
            if (this.visuals.line.doit) {
                ctx.beginPath();
                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    HBarView.prototype._hit_point = function (geometry) {
        var hits, ref, result, vx, vy, x, y;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        hits = this.index.indices({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y
        });
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    HBarView.prototype.scx = function (i) {
        return (this.sleft[i] + this.sright[i]) / 2;
    };
    HBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return HBarView;
}(glyph_1.GlyphView);
exports.HBar = function (superClass) {
    extend(HBar, superClass);
    function HBar() {
        return HBar.__super__.constructor.apply(this, arguments);
    }
    HBar.prototype.default_view = exports.HBarView;
    HBar.prototype.type = 'HBar';
    HBar.coords([[
            'y',
            'left'
        ]]);
    HBar.mixins([
        'line',
        'fill'
    ]);
    HBar.define({
        height: [p.DistanceSpec],
        right: [p.NumberSpec]
    });
    HBar.override({ left: 0 });
    return HBar;
}(glyph_1.Glyph);    
},
/* models/glyphs/image */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var Greys9, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var linear_color_mapper_1 = require(141    /* ../mappers/linear_color_mapper */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.ImageView = function (superClass) {
    extend(ImageView, superClass);
    function ImageView() {
        return ImageView.__super__.constructor.apply(this, arguments);
    }
    ImageView.prototype.initialize = function (options) {
        ImageView.__super__.initialize.call(this, options);
        return this.connect(this.model.color_mapper.change, function () {
            return this._update_image();
        });
    };
    ImageView.prototype._update_image = function () {
        if (this.image_data != null) {
            this._set_data();
            return this.renderer.plot_view.request_render();
        }
    };
    ImageView.prototype._set_data = function () {
        var buf, buf8, canvas, cmap, ctx, i, image_data, img, j, ref, results, shape;
        if (this.image_data == null || this.image_data.length !== this._image.length) {
            this.image_data = new Array(this._image.length);
        }
        if (this._width == null || this._width.length !== this._image.length) {
            this._width = new Array(this._image.length);
        }
        if (this._height == null || this._height.length !== this._image.length) {
            this._height = new Array(this._image.length);
        }
        results = [];
        for (i = j = 0, ref = this._image.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            shape = [];
            if (this._image_shape != null) {
                shape = this._image_shape[i];
            }
            if (shape.length > 0) {
                img = this._image[i];
                this._height[i] = shape[0];
                this._width[i] = shape[1];
            } else {
                img = array_1.concat(this._image[i]);
                this._height[i] = this._image[i].length;
                this._width[i] = this._image[i][0].length;
            }
            if (this.image_data[i] != null && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {
                canvas = this.image_data[i];
            } else {
                canvas = document.createElement('canvas');
                canvas.width = this._width[i];
                canvas.height = this._height[i];
            }
            ctx = canvas.getContext('2d');
            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);
            cmap = this.model.color_mapper;
            buf = cmap.v_map_screen(img, true);
            buf8 = new Uint8Array(buf);
            image_data.data.set(buf8);
            ctx.putImageData(image_data, 0, 0);
            this.image_data[i] = canvas;
            this.max_dw = 0;
            if (this._dw.units === 'data') {
                this.max_dw = array_1.max(this._dw);
            }
            this.max_dh = 0;
            if (this._dh.units === 'data') {
                results.push(this.max_dh = array_1.max(this._dh));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    ImageView.prototype._map_data = function () {
        switch (this.model.properties.dw.units) {
        case 'data':
            this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);
            break;
        case 'screen':
            this.sw = this._dw;
        }
        switch (this.model.properties.dh.units) {
        case 'data':
            return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);
        case 'screen':
            return this.sh = this._dh;
        }
    };
    ImageView.prototype._render = function (ctx, indices, arg) {
        var i, image_data, j, len, old_smoothing, sh, sw, sx, sy, y_offset;
        image_data = arg.image_data, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;
        old_smoothing = ctx.getImageSmoothingEnabled();
        ctx.setImageSmoothingEnabled(false);
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (image_data[i] == null) {
                continue;
            }
            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {
                continue;
            }
            y_offset = sy[i];
            ctx.translate(0, y_offset);
            ctx.scale(1, -1);
            ctx.translate(0, -y_offset);
            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);
            ctx.translate(0, y_offset);
            ctx.scale(1, -1);
            ctx.translate(0, -y_offset);
        }
        return ctx.setImageSmoothingEnabled(old_smoothing);
    };
    ImageView.prototype.bounds = function () {
        var bbox;
        bbox = this.index.bbox;
        bbox.maxX += this.max_dw;
        bbox.maxY += this.max_dh;
        return bbox;
    };
    return ImageView;
}(xy_glyph_1.XYGlyphView);
Greys9 = function () {
    return [
        0,
        2434341,
        5395026,
        7566195,
        9868950,
        12434877,
        14277081,
        15790320,
        16777215
    ];
};
exports.Image = function (superClass) {
    extend(Image, superClass);
    function Image() {
        return Image.__super__.constructor.apply(this, arguments);
    }
    Image.prototype.default_view = exports.ImageView;
    Image.prototype.type = 'Image';
    Image.define({
        image: [p.NumberSpec],
        dw: [p.DistanceSpec],
        dh: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ],
        color_mapper: [
            p.Instance,
            function () {
                return new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() });
            }
        ]
    });
    return Image;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/image_rgba */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.ImageRGBAView = function (superClass) {
    extend(ImageRGBAView, superClass);
    function ImageRGBAView() {
        return ImageRGBAView.__super__.constructor.apply(this, arguments);
    }
    ImageRGBAView.prototype._set_data = function (source, indices) {
        var buf, buf8, canvas, color, ctx, flat, i, image_data, j, k, l, ref, ref1, results, shape;
        if (this.image_data == null || this.image_data.length !== this._image.length) {
            this.image_data = new Array(this._image.length);
        }
        if (this._width == null || this._width.length !== this._image.length) {
            this._width = new Array(this._image.length);
        }
        if (this._height == null || this._height.length !== this._image.length) {
            this._height = new Array(this._image.length);
        }
        results = [];
        for (i = k = 0, ref = this._image.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (indices != null && indices.indexOf(i) < 0) {
                continue;
            }
            shape = [];
            if (this._image_shape != null) {
                shape = this._image_shape[i];
            }
            if (shape.length > 0) {
                buf = this._image[i].buffer;
                this._height[i] = shape[0];
                this._width[i] = shape[1];
            } else {
                flat = array_1.concat(this._image[i]);
                buf = new ArrayBuffer(flat.length * 4);
                color = new Uint32Array(buf);
                for (j = l = 0, ref1 = flat.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    color[j] = flat[j];
                }
                this._height[i] = this._image[i].length;
                this._width[i] = this._image[i][0].length;
            }
            if (this.image_data[i] != null && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {
                canvas = this.image_data[i];
            } else {
                canvas = document.createElement('canvas');
                canvas.width = this._width[i];
                canvas.height = this._height[i];
            }
            ctx = canvas.getContext('2d');
            image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);
            buf8 = new Uint8Array(buf);
            image_data.data.set(buf8);
            ctx.putImageData(image_data, 0, 0);
            this.image_data[i] = canvas;
            this.max_dw = 0;
            if (this._dw.units === 'data') {
                this.max_dw = array_1.max(this._dw);
            }
            this.max_dh = 0;
            if (this._dh.units === 'data') {
                results.push(this.max_dh = array_1.max(this._dh));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    ImageRGBAView.prototype._map_data = function () {
        switch (this.model.properties.dw.units) {
        case 'data':
            this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);
            break;
        case 'screen':
            this.sw = this._dw;
        }
        switch (this.model.properties.dh.units) {
        case 'data':
            return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);
        case 'screen':
            return this.sh = this._dh;
        }
    };
    ImageRGBAView.prototype._render = function (ctx, indices, arg) {
        var i, image_data, k, len, old_smoothing, sh, sw, sx, sy, y_offset;
        image_data = arg.image_data, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;
        old_smoothing = ctx.getImageSmoothingEnabled();
        ctx.setImageSmoothingEnabled(false);
        for (k = 0, len = indices.length; k < len; k++) {
            i = indices[k];
            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {
                continue;
            }
            y_offset = sy[i];
            ctx.translate(0, y_offset);
            ctx.scale(1, -1);
            ctx.translate(0, -y_offset);
            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);
            ctx.translate(0, y_offset);
            ctx.scale(1, -1);
            ctx.translate(0, -y_offset);
        }
        return ctx.setImageSmoothingEnabled(old_smoothing);
    };
    ImageRGBAView.prototype.bounds = function () {
        var bbox;
        bbox = this.index.bbox;
        bbox.maxX += this.max_dw;
        bbox.maxY += this.max_dh;
        return bbox;
    };
    return ImageRGBAView;
}(xy_glyph_1.XYGlyphView);
exports.ImageRGBA = function (superClass) {
    extend(ImageRGBA, superClass);
    function ImageRGBA() {
        return ImageRGBA.__super__.constructor.apply(this, arguments);
    }
    ImageRGBA.prototype.default_view = exports.ImageRGBAView;
    ImageRGBA.prototype.type = 'ImageRGBA';
    ImageRGBA.define({
        image: [p.NumberSpec],
        dw: [p.DistanceSpec],
        dh: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ]
    });
    return ImageRGBA;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/image_url */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var glyph_1 = require(104    /* ./glyph */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.ImageURLView = function (superClass) {
    extend(ImageURLView, superClass);
    function ImageURLView() {
        return ImageURLView.__super__.constructor.apply(this, arguments);
    }
    ImageURLView.prototype.initialize = function (options) {
        ImageURLView.__super__.initialize.call(this, options);
        return this.connect(this.model.properties.global_alpha.change, function (_this) {
            return function () {
                return _this.renderer.request_render();
            };
        }(this));
    };
    ImageURLView.prototype._index_data = function () {
    };
    ImageURLView.prototype._set_data = function () {
        var i, img, j, ref, results, retry_attempts, retry_timeout;
        if (this.image == null || this.image.length !== this._url.length) {
            this.image = function () {
                var j, len, ref, results;
                ref = this._url;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    img = ref[j];
                    results.push(null);
                }
                return results;
            }.call(this);
        }
        retry_attempts = this.model.retry_attempts;
        retry_timeout = this.model.retry_timeout;
        this.retries = function () {
            var j, len, ref, results;
            ref = this._url;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                img = ref[j];
                results.push(retry_attempts);
            }
            return results;
        }.call(this);
        results = [];
        for (i = j = 0, ref = this._url.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (this._url[i] == null) {
                continue;
            }
            img = new Image();
            img.onerror = function (_this) {
                return function (i, img) {
                    return function () {
                        if (_this.retries[i] > 0) {
                            logging_1.logger.trace('ImageURL failed to load ' + _this._url[i] + ' image, retrying in ' + retry_timeout + ' ms');
                            setTimeout(function () {
                                return img.src = _this._url[i];
                            }, retry_timeout);
                        } else {
                            logging_1.logger.warn('ImageURL unable to load ' + _this._url[i] + ' image after ' + retry_attempts + ' retries');
                        }
                        return _this.retries[i] -= 1;
                    };
                };
            }(this)(i, img);
            img.onload = function (_this) {
                return function (img, i) {
                    return function () {
                        _this.image[i] = img;
                        return _this.renderer.request_render();
                    };
                };
            }(this)(img, i);
            results.push(img.src = this._url[i]);
        }
        return results;
    };
    ImageURLView.prototype.has_finished = function () {
        return ImageURLView.__super__.has_finished.call(this) && this._images_rendered === true;
    };
    ImageURLView.prototype._map_data = function () {
        var hs, ws, x;
        ws = function () {
            var j, len, ref, results;
            if (this.model.w != null) {
                return this._w;
            } else {
                ref = this._x;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    results.push(0 / 0);
                }
                return results;
            }
        }.call(this);
        hs = function () {
            var j, len, ref, results;
            if (this.model.h != null) {
                return this._h;
            } else {
                ref = this._x;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    results.push(0 / 0);
                }
                return results;
            }
        }.call(this);
        switch (this.model.properties.w.units) {
        case 'data':
            this.sw = this.sdist(this.renderer.xscale, this._x, ws, 'edge', this.model.dilate);
            break;
        case 'screen':
            this.sw = ws;
        }
        switch (this.model.properties.h.units) {
        case 'data':
            return this.sh = this.sdist(this.renderer.yscale, this._y, hs, 'edge', this.model.dilate);
        case 'screen':
            return this.sh = hs;
        }
    };
    ImageURLView.prototype._render = function (ctx, indices, arg) {
        var _angle, _url, finished, frame, i, image, j, len, sh, sw, sx, sy;
        _url = arg._url, image = arg.image, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh, _angle = arg._angle;
        frame = this.renderer.plot_view.frame;
        ctx.rect(frame._left.value + 1, frame._bottom.value + 1, frame._width.value - 2, frame._height.value - 2);
        ctx.clip();
        finished = true;
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + _angle[i])) {
                continue;
            }
            if (this.retries[i] === -1) {
                continue;
            }
            if (image[i] == null) {
                finished = false;
                continue;
            }
            this._render_image(ctx, i, image[i], sx, sy, sw, sh, _angle);
        }
        if (finished && !this._images_rendered) {
            this._images_rendered = true;
            return this.notify_finished();
        }
    };
    ImageURLView.prototype._final_sx_sy = function (anchor, sx, sy, sw, sh) {
        switch (anchor) {
        case 'top_left':
            return [
                sx,
                sy
            ];
        case 'top_center':
            return [
                sx - sw / 2,
                sy
            ];
        case 'top_right':
            return [
                sx - sw,
                sy
            ];
        case 'center_right':
            return [
                sx - sw,
                sy - sh / 2
            ];
        case 'bottom_right':
            return [
                sx - sw,
                sy - sh
            ];
        case 'bottom_center':
            return [
                sx - sw / 2,
                sy - sh
            ];
        case 'bottom_left':
            return [
                sx,
                sy - sh
            ];
        case 'center_left':
            return [
                sx,
                sy - sh / 2
            ];
        case 'center':
            return [
                sx - sw / 2,
                sy - sh / 2
            ];
        }
    };
    ImageURLView.prototype._render_image = function (ctx, i, image, sx, sy, sw, sh, angle) {
        var anchor, ref;
        if (isNaN(sw[i])) {
            sw[i] = image.width;
        }
        if (isNaN(sh[i])) {
            sh[i] = image.height;
        }
        anchor = this.model.anchor;
        ref = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]), sx = ref[0], sy = ref[1];
        ctx.save();
        ctx.globalAlpha = this.model.global_alpha;
        if (angle[i]) {
            ctx.translate(sx, sy);
            ctx.rotate(angle[i]);
            ctx.drawImage(image, 0, 0, sw[i], sh[i]);
            ctx.rotate(-angle[i]);
            ctx.translate(-sx, -sy);
        } else {
            ctx.drawImage(image, sx, sy, sw[i], sh[i]);
        }
        return ctx.restore();
    };
    return ImageURLView;
}(glyph_1.GlyphView);
exports.ImageURL = function (superClass) {
    extend(ImageURL, superClass);
    function ImageURL() {
        return ImageURL.__super__.constructor.apply(this, arguments);
    }
    ImageURL.prototype.default_view = exports.ImageURLView;
    ImageURL.prototype.type = 'ImageURL';
    ImageURL.coords([[
            'x',
            'y'
        ]]);
    ImageURL.mixins([]);
    ImageURL.define({
        url: [p.StringSpec],
        anchor: [
            p.Anchor,
            'top_left'
        ],
        global_alpha: [
            p.Number,
            1
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        w: [p.DistanceSpec],
        h: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ],
        retry_attempts: [
            p.Number,
            0
        ],
        retry_timeout: [
            p.Number,
            0
        ]
    });
    return ImageURL;
}(glyph_1.Glyph);    
},
/* models/glyphs/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var annular_wedge_1 = require(98    /* ./annular_wedge */);
exports.AnnularWedge = annular_wedge_1.AnnularWedge;
var annulus_1 = require(99    /* ./annulus */);
exports.Annulus = annulus_1.Annulus;
var arc_1 = require(100    /* ./arc */);
exports.Arc = arc_1.Arc;
var bezier_1 = require(101    /* ./bezier */);
exports.Bezier = bezier_1.Bezier;
var circle_1 = require(102    /* ./circle */);
exports.Circle = circle_1.Circle;
var ellipse_1 = require(103    /* ./ellipse */);
exports.Ellipse = ellipse_1.Ellipse;
var glyph_1 = require(104    /* ./glyph */);
exports.Glyph = glyph_1.Glyph;
var hbar_1 = require(105    /* ./hbar */);
exports.HBar = hbar_1.HBar;
var image_1 = require(106    /* ./image */);
exports.Image = image_1.Image;
var image_rgba_1 = require(107    /* ./image_rgba */);
exports.ImageRGBA = image_rgba_1.ImageRGBA;
var image_url_1 = require(108    /* ./image_url */);
exports.ImageURL = image_url_1.ImageURL;
var line_1 = require(110    /* ./line */);
exports.Line = line_1.Line;
var multi_line_1 = require(111    /* ./multi_line */);
exports.MultiLine = multi_line_1.MultiLine;
var oval_1 = require(112    /* ./oval */);
exports.Oval = oval_1.Oval;
var patch_1 = require(113    /* ./patch */);
exports.Patch = patch_1.Patch;
var patches_1 = require(114    /* ./patches */);
exports.Patches = patches_1.Patches;
var quad_1 = require(115    /* ./quad */);
exports.Quad = quad_1.Quad;
var quadratic_1 = require(116    /* ./quadratic */);
exports.Quadratic = quadratic_1.Quadratic;
var ray_1 = require(117    /* ./ray */);
exports.Ray = ray_1.Ray;
var rect_1 = require(118    /* ./rect */);
exports.Rect = rect_1.Rect;
var segment_1 = require(119    /* ./segment */);
exports.Segment = segment_1.Segment;
var text_1 = require(120    /* ./text */);
exports.Text = text_1.Text;
var vbar_1 = require(121    /* ./vbar */);
exports.VBar = vbar_1.VBar;
var wedge_1 = require(122    /* ./wedge */);
exports.Wedge = wedge_1.Wedge;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
exports.XYGlyph = xy_glyph_1.XYGlyph;    
},
/* models/glyphs/line */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
exports.LineView = function (superClass) {
    extend(LineView, superClass);
    function LineView() {
        return LineView.__super__.constructor.apply(this, arguments);
    }
    LineView.prototype._render = function (ctx, indices, arg) {
        var drawing, i, j, last_index, len, sx, sy;
        sx = arg.sx, sy = arg.sy;
        drawing = false;
        this.visuals.line.set_value(ctx);
        last_index = null;
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (drawing) {
                if (!isFinite(sx[i] + sy[i])) {
                    ctx.stroke();
                    ctx.beginPath();
                    drawing = false;
                    last_index = i;
                    continue;
                }
                if (last_index !== null && i - last_index > 1) {
                    ctx.stroke();
                    drawing = false;
                }
            }
            if (drawing) {
                ctx.lineTo(sx[i], sy[i]);
            } else {
                ctx.beginPath();
                ctx.moveTo(sx[i], sy[i]);
                drawing = true;
            }
            last_index = i;
        }
        if (drawing) {
            return ctx.stroke();
        }
    };
    LineView.prototype._hit_point = function (geometry) {
        /* Check if the point geometry hits this line glyph and return an object
        that describes the hit result:
          Args:
            * geometry (object): object with the following keys
              * vx (float): view x coordinate of the point
              * vy (float): view y coordinate of the point
              * type (str): type of geometry (in this case it's a point)
          Output:
            Object with the following keys:
              * 0d (bool): whether the point hits the glyph or not
              * 1d (array(int)): array with the indices hit by the point
         */
        var dist, i, j, p0, p1, point, ref, ref1, result, shortest, threshold;
        result = hittest.create_hit_test_result();
        point = {
            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),
            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)
        };
        shortest = 9999;
        threshold = Math.max(2, this.visuals.line.line_width.value() / 2);
        for (i = j = 0, ref = this.sx.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            ref1 = [
                {
                    x: this.sx[i],
                    y: this.sy[i]
                },
                {
                    x: this.sx[i + 1],
                    y: this.sy[i + 1]
                }
            ], p0 = ref1[0], p1 = ref1[1];
            dist = hittest.dist_to_segment(point, p0, p1);
            if (dist < threshold && dist < shortest) {
                shortest = dist;
                result['0d'].glyph = this.model;
                result['0d'].get_view = function () {
                    return this;
                }.bind(this);
                result['0d'].flag = true;
                result['0d'].indices = [i];
            }
        }
        return result;
    };
    LineView.prototype._hit_span = function (geometry) {
        var i, j, ref, ref1, result, val, values, vx, vy;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        result = hittest.create_hit_test_result();
        if (geometry.direction === 'v') {
            val = this.renderer.yscale.invert(vy);
            values = this._y;
        } else {
            val = this.renderer.xscale.invert(vx);
            values = this._x;
        }
        for (i = j = 0, ref1 = values.length - 1; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            if (values[i] <= val && val <= values[i + 1] || values[i + 1] <= val && val <= values[i]) {
                result['0d'].glyph = this.model;
                result['0d'].get_view = function () {
                    return this;
                }.bind(this);
                result['0d'].flag = true;
                result['0d'].indices.push(i);
            }
        }
        return result;
    };
    LineView.prototype.get_interpolation_hit = function (i, geometry) {
        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        ref1 = [
            this._x[i],
            this._y[i],
            this._x[i + 1],
            this._y[i + 1]
        ], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];
        if (geometry.type === 'point') {
            ref2 = this.renderer.yscale.v_invert([
                vy - 1,
                vy + 1
            ]), y0 = ref2[0], y1 = ref2[1];
            ref3 = this.renderer.xscale.v_invert([
                vx - 1,
                vx + 1
            ]), x0 = ref3[0], x1 = ref3[1];
        } else {
            if (geometry.direction === 'v') {
                ref4 = this.renderer.yscale.v_invert([
                    vy,
                    vy
                ]), y0 = ref4[0], y1 = ref4[1];
                ref5 = [
                    x2,
                    x3
                ], x0 = ref5[0], x1 = ref5[1];
            } else {
                ref6 = this.renderer.xscale.v_invert([
                    vx,
                    vx
                ]), x0 = ref6[0], x1 = ref6[1];
                ref7 = [
                    y2,
                    y3
                ], y0 = ref7[0], y1 = ref7[1];
            }
        }
        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);
        return [
            res.x,
            res.y
        ];
    };
    LineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return LineView;
}(xy_glyph_1.XYGlyphView);
exports.Line = function (superClass) {
    extend(Line, superClass);
    function Line() {
        return Line.__super__.constructor.apply(this, arguments);
    }
    Line.prototype.default_view = exports.LineView;
    Line.prototype.type = 'Line';
    Line.mixins(['line']);
    return Line;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/multi_line */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var hittest = require(8    /* core/hittest */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
var glyph_1 = require(104    /* ./glyph */);
exports.MultiLineView = function (superClass) {
    extend(MultiLineView, superClass);
    function MultiLineView() {
        return MultiLineView.__super__.constructor.apply(this, arguments);
    }
    MultiLineView.prototype._index_data = function () {
        var i, k, points, ref, x, xs, y, ys;
        points = [];
        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            if (this._xs[i] === null || this._xs[i].length === 0) {
                continue;
            }
            xs = function () {
                var l, len, ref1, results;
                ref1 = this._xs[i];
                results = [];
                for (l = 0, len = ref1.length; l < len; l++) {
                    x = ref1[l];
                    if (!types_1.isStrictNaN(x)) {
                        results.push(x);
                    }
                }
                return results;
            }.call(this);
            ys = function () {
                var l, len, ref1, results;
                ref1 = this._ys[i];
                results = [];
                for (l = 0, len = ref1.length; l < len; l++) {
                    y = ref1[l];
                    if (!types_1.isStrictNaN(y)) {
                        results.push(y);
                    }
                }
                return results;
            }.call(this);
            points.push({
                minX: array_1.min(xs),
                minY: array_1.min(ys),
                maxX: array_1.max(xs),
                maxY: array_1.max(ys),
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    MultiLineView.prototype._render = function (ctx, indices, arg) {
        var i, j, k, l, len, ref, ref1, results, sx, sxs, sy, sys;
        sxs = arg.sxs, sys = arg.sys;
        results = [];
        for (k = 0, len = indices.length; k < len; k++) {
            i = indices[k];
            ref = [
                sxs[i],
                sys[i]
            ], sx = ref[0], sy = ref[1];
            this.visuals.line.set_vectorize(ctx, i);
            for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                if (j === 0) {
                    ctx.beginPath();
                    ctx.moveTo(sx[j], sy[j]);
                    continue;
                } else if (isNaN(sx[j]) || isNaN(sy[j])) {
                    ctx.stroke();
                    ctx.beginPath();
                    continue;
                } else {
                    ctx.lineTo(sx[j], sy[j]);
                }
            }
            results.push(ctx.stroke());
        }
        return results;
    };
    MultiLineView.prototype._hit_point = function (geometry) {
        var dist, hits, i, j, k, l, p0, p1, point, points, ref, ref1, ref2, result, shortest, threshold;
        result = hittest.create_hit_test_result();
        point = {
            x: this.renderer.plot_view.canvas.vx_to_sx(geometry.vx),
            y: this.renderer.plot_view.canvas.vy_to_sy(geometry.vy)
        };
        shortest = 9999;
        hits = {};
        for (i = k = 0, ref = this.sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);
            points = null;
            for (j = l = 0, ref1 = this.sxs[i].length - 1; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                ref2 = [
                    {
                        x: this.sxs[i][j],
                        y: this.sys[i][j]
                    },
                    {
                        x: this.sxs[i][j + 1],
                        y: this.sys[i][j + 1]
                    }
                ], p0 = ref2[0], p1 = ref2[1];
                dist = hittest.dist_to_segment(point, p0, p1);
                if (dist < threshold && dist < shortest) {
                    shortest = dist;
                    points = [j];
                }
            }
            if (points) {
                hits[i] = points;
            }
        }
        result['1d'].indices = function () {
            var len, m, ref3, results;
            ref3 = Object.keys(hits);
            results = [];
            for (m = 0, len = ref3.length; m < len; m++) {
                i = ref3[m];
                results.push(parseInt(i));
            }
            return results;
        }();
        result['2d'].indices = hits;
        return result;
    };
    MultiLineView.prototype._hit_span = function (geometry) {
        var hits, i, j, k, l, points, ref, ref1, ref2, result, val, values, vx, vy;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        result = hittest.create_hit_test_result();
        if (geometry.direction === 'v') {
            val = this.renderer.yscale.invert(vy);
            values = this._ys;
        } else {
            val = this.renderer.xscale.invert(vx);
            values = this._xs;
        }
        hits = {};
        for (i = k = 0, ref1 = values.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            points = [];
            for (j = l = 0, ref2 = values[i].length - 1; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {
                if (values[i][j] <= val && val <= values[i][j + 1]) {
                    points.push(j);
                }
            }
            if (points.length > 0) {
                hits[i] = points;
            }
        }
        result['1d'].indices = function () {
            var len, m, ref3, results;
            ref3 = Object.keys(hits);
            results = [];
            for (m = 0, len = ref3.length; m < len; m++) {
                i = ref3[m];
                results.push(parseInt(i));
            }
            return results;
        }();
        result['2d'].indices = hits;
        return result;
    };
    MultiLineView.prototype.get_interpolation_hit = function (i, point_i, geometry) {
        var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, res, vx, vy, x0, x1, x2, x3, y0, y1, y2, y3;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        ref1 = [
            this._xs[i][point_i],
            this._ys[i][point_i],
            this._xs[i][point_i + 1],
            this._ys[i][point_i + 1]
        ], x2 = ref1[0], y2 = ref1[1], x3 = ref1[2], y3 = ref1[3];
        if (geometry.type === 'point') {
            ref2 = this.renderer.yscale.v_invert([
                vy - 1,
                vy + 1
            ]), y0 = ref2[0], y1 = ref2[1];
            ref3 = this.renderer.xscale.v_invert([
                vx - 1,
                vx + 1
            ]), x0 = ref3[0], x1 = ref3[1];
        } else {
            if (geometry.direction === 'v') {
                ref4 = this.renderer.yscale.v_invert([
                    vy,
                    vy
                ]), y0 = ref4[0], y1 = ref4[1];
                ref5 = [
                    x2,
                    x3
                ], x0 = ref5[0], x1 = ref5[1];
            } else {
                ref6 = this.renderer.xscale.v_invert([
                    vx,
                    vx
                ]), x0 = ref6[0], x1 = ref6[1];
                ref7 = [
                    y2,
                    y3
                ], y0 = ref7[0], y1 = ref7[1];
            }
        }
        res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);
        return [
            res.x,
            res.y
        ];
    };
    MultiLineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return MultiLineView;
}(glyph_1.GlyphView);
exports.MultiLine = function (superClass) {
    extend(MultiLine, superClass);
    function MultiLine() {
        return MultiLine.__super__.constructor.apply(this, arguments);
    }
    MultiLine.prototype.default_view = exports.MultiLineView;
    MultiLine.prototype.type = 'MultiLine';
    MultiLine.coords([[
            'xs',
            'ys'
        ]]);
    MultiLine.mixins(['line']);
    return MultiLine;
}(glyph_1.Glyph);    
},
/* models/glyphs/oval */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
exports.OvalView = function (superClass) {
    extend(OvalView, superClass);
    function OvalView() {
        return OvalView.__super__.constructor.apply(this, arguments);
    }
    OvalView.prototype._set_data = function () {
        this.max_w2 = 0;
        if (this.model.properties.width.units === 'data') {
            this.max_w2 = this.max_width / 2;
        }
        this.max_h2 = 0;
        if (this.model.properties.height.units === 'data') {
            return this.max_h2 = this.max_height / 2;
        }
    };
    OvalView.prototype._map_data = function () {
        if (this.model.properties.width.units === 'data') {
            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
        } else {
            this.sw = this._width;
        }
        if (this.model.properties.height.units === 'data') {
            return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
        } else {
            return this.sh = this._height;
        }
    };
    OvalView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sh, sw, sx, sy;
        sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {
                continue;
            }
            ctx.translate(sx[i], sy[i]);
            ctx.rotate(this._angle[i]);
            ctx.beginPath();
            ctx.moveTo(0, -sh[i] / 2);
            ctx.bezierCurveTo(sw[i] / 2, -sh[i] / 2, sw[i] / 2, sh[i] / 2, 0, sh[i] / 2);
            ctx.bezierCurveTo(-sw[i] / 2, sh[i] / 2, -sw[i] / 2, -sh[i] / 2, 0, -sh[i] / 2);
            ctx.closePath();
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.stroke();
            }
            ctx.rotate(-this._angle[i]);
            results.push(ctx.translate(-sx[i], -sy[i]));
        }
        return results;
    };
    OvalView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        var d, data, indices, scale, sh, sw, sx, sy;
        indices = [index];
        sx = {};
        sx[index] = (x0 + x1) / 2;
        sy = {};
        sy[index] = (y0 + y1) / 2;
        scale = this.sw[index] / this.sh[index];
        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
        sw = {};
        sh = {};
        if (scale > 1) {
            sw[index] = d;
            sh[index] = d / scale;
        } else {
            sw[index] = d * scale;
            sh[index] = d;
        }
        data = {
            sx: sx,
            sy: sy,
            sw: sw,
            sh: sh
        };
        return this._render(ctx, indices, data);
    };
    OvalView.prototype._bounds = function (bds) {
        return this.max_wh2_bounds(bds);
    };
    return OvalView;
}(xy_glyph_1.XYGlyphView);
exports.Oval = function (superClass) {
    extend(Oval, superClass);
    function Oval() {
        return Oval.__super__.constructor.apply(this, arguments);
    }
    Oval.prototype.default_view = exports.OvalView;
    Oval.prototype.type = 'Oval';
    Oval.mixins([
        'line',
        'fill'
    ]);
    Oval.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec]
    });
    return Oval;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/patch */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
exports.PatchView = function (superClass) {
    extend(PatchView, superClass);
    function PatchView() {
        return PatchView.__super__.constructor.apply(this, arguments);
    }
    PatchView.prototype._render = function (ctx, indices, arg) {
        var i, j, k, len, len1, sx, sy;
        sx = arg.sx, sy = arg.sy;
        if (this.visuals.fill.doit) {
            this.visuals.fill.set_value(ctx);
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (i === 0) {
                    ctx.beginPath();
                    ctx.moveTo(sx[i], sy[i]);
                    continue;
                } else if (isNaN(sx[i] + sy[i])) {
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    continue;
                } else {
                    ctx.lineTo(sx[i], sy[i]);
                }
            }
            ctx.closePath();
            ctx.fill();
        }
        if (this.visuals.line.doit) {
            this.visuals.line.set_value(ctx);
            for (k = 0, len1 = indices.length; k < len1; k++) {
                i = indices[k];
                if (i === 0) {
                    ctx.beginPath();
                    ctx.moveTo(sx[i], sy[i]);
                    continue;
                } else if (isNaN(sx[i] + sy[i])) {
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    continue;
                } else {
                    ctx.lineTo(sx[i], sy[i]);
                }
            }
            ctx.closePath();
            return ctx.stroke();
        }
    };
    PatchView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return PatchView;
}(xy_glyph_1.XYGlyphView);
exports.Patch = function (superClass) {
    extend(Patch, superClass);
    function Patch() {
        return Patch.__super__.constructor.apply(this, arguments);
    }
    Patch.prototype.default_view = exports.PatchView;
    Patch.prototype.type = 'Patch';
    Patch.mixins([
        'line',
        'fill'
    ]);
    return Patch;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/patches */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
var hittest = require(8    /* core/hittest */);
exports.PatchesView = function (superClass) {
    extend(PatchesView, superClass);
    function PatchesView() {
        return PatchesView.__super__.constructor.apply(this, arguments);
    }
    PatchesView.prototype._build_discontinuous_object = function (nanned_qs) {
        var denanned, ds, i, k, nan_index, q, qs, qs_part, ref;
        ds = {};
        for (i = k = 0, ref = nanned_qs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            ds[i] = [];
            qs = array_1.copy(nanned_qs[i]);
            while (qs.length > 0) {
                nan_index = array_1.findLastIndex(qs, function (q) {
                    return types_1.isStrictNaN(q);
                });
                if (nan_index >= 0) {
                    qs_part = qs.splice(nan_index);
                } else {
                    qs_part = qs;
                    qs = [];
                }
                denanned = function () {
                    var l, len, results;
                    results = [];
                    for (l = 0, len = qs_part.length; l < len; l++) {
                        q = qs_part[l];
                        if (!types_1.isStrictNaN(q)) {
                            results.push(q);
                        }
                    }
                    return results;
                }();
                ds[i].push(denanned);
            }
        }
        return ds;
    };
    PatchesView.prototype._index_data = function () {
        var i, j, k, l, points, ref, ref1, xs, xss, ys, yss;
        xss = this._build_discontinuous_object(this._xs);
        yss = this._build_discontinuous_object(this._ys);
        points = [];
        for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            for (j = l = 0, ref1 = xss[i].length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                xs = xss[i][j];
                ys = yss[i][j];
                if (xs.length === 0) {
                    continue;
                }
                points.push({
                    minX: array_1.min(xs),
                    minY: array_1.min(ys),
                    maxX: array_1.max(xs),
                    maxY: array_1.max(ys),
                    i: i
                });
            }
        }
        return new spatial_1.RBush(points);
    };
    PatchesView.prototype._mask_data = function (all_indices) {
        var bbox, ref, ref1, x0, x1, xr, y0, y1, yr;
        xr = this.renderer.plot_view.frame.x_ranges['default'];
        ref = [
            xr.min,
            xr.max
        ], x0 = ref[0], x1 = ref[1];
        yr = this.renderer.plot_view.frame.y_ranges['default'];
        ref1 = [
            yr.min,
            yr.max
        ], y0 = ref1[0], y1 = ref1[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        return this.index.indices(bbox);
    };
    PatchesView.prototype._render = function (ctx, indices, arg) {
        var i, j, k, l, len, m, ref, ref1, ref2, results, sx, sxs, sy, sys;
        sxs = arg.sxs, sys = arg.sys;
        this.renderer.sxss = this._build_discontinuous_object(sxs);
        this.renderer.syss = this._build_discontinuous_object(sys);
        results = [];
        for (k = 0, len = indices.length; k < len; k++) {
            i = indices[k];
            ref = [
                sxs[i],
                sys[i]
            ], sx = ref[0], sy = ref[1];
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                for (j = l = 0, ref1 = sx.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    if (j === 0) {
                        ctx.beginPath();
                        ctx.moveTo(sx[j], sy[j]);
                        continue;
                    } else if (isNaN(sx[j] + sy[j])) {
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        continue;
                    } else {
                        ctx.lineTo(sx[j], sy[j]);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                for (j = m = 0, ref2 = sx.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {
                    if (j === 0) {
                        ctx.beginPath();
                        ctx.moveTo(sx[j], sy[j]);
                        continue;
                    } else if (isNaN(sx[j] + sy[j])) {
                        ctx.closePath();
                        ctx.stroke();
                        ctx.beginPath();
                        continue;
                    } else {
                        ctx.lineTo(sx[j], sy[j]);
                    }
                }
                ctx.closePath();
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    PatchesView.prototype._hit_point = function (geometry) {
        var candidates, hits, i, idx, j, k, l, ref, ref1, ref2, result, sx, sxs, sy, sys, vx, vy, x, y;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        candidates = this.index.indices({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y
        });
        hits = [];
        for (i = k = 0, ref1 = candidates.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            idx = candidates[i];
            sxs = this.renderer.sxss[idx];
            sys = this.renderer.syss[idx];
            for (j = l = 0, ref2 = sxs.length; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {
                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                    hits.push(idx);
                }
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    PatchesView.prototype._get_snap_coord = function (array) {
        var k, len, s, sum;
        sum = 0;
        for (k = 0, len = array.length; k < len; k++) {
            s = array[k];
            sum += s;
        }
        return sum / array.length;
    };
    PatchesView.prototype.scx = function (i, sx, sy) {
        var j, k, ref, sxs, sys;
        if (this.renderer.sxss[i].length === 1) {
            return this._get_snap_coord(this.sxs[i]);
        } else {
            sxs = this.renderer.sxss[i];
            sys = this.renderer.syss[i];
            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                    return this._get_snap_coord(sxs[j]);
                }
            }
        }
        return null;
    };
    PatchesView.prototype.scy = function (i, sx, sy) {
        var j, k, ref, sxs, sys;
        if (this.renderer.syss[i].length === 1) {
            return this._get_snap_coord(this.sys[i]);
        } else {
            sxs = this.renderer.sxss[i];
            sys = this.renderer.syss[i];
            for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
                if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                    return this._get_snap_coord(sys[j]);
                }
            }
        }
    };
    PatchesView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return PatchesView;
}(glyph_1.GlyphView);
exports.Patches = function (superClass) {
    extend(Patches, superClass);
    function Patches() {
        return Patches.__super__.constructor.apply(this, arguments);
    }
    Patches.prototype.default_view = exports.PatchesView;
    Patches.prototype.type = 'Patches';
    Patches.coords([[
            'xs',
            'ys'
        ]]);
    Patches.mixins([
        'line',
        'fill'
    ]);
    return Patches;
}(glyph_1.Glyph);    
},
/* models/glyphs/quad */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
var hittest = require(8    /* core/hittest */);
exports.QuadView = function (superClass) {
    extend(QuadView, superClass);
    function QuadView() {
        return QuadView.__super__.constructor.apply(this, arguments);
    }
    QuadView.prototype._index_data = function () {
        var b, i, j, l, points, r, ref, t;
        points = [];
        for (i = j = 0, ref = this._left.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            l = this._left[i];
            r = this._right[i];
            t = this._top[i];
            b = this._bottom[i];
            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {
                continue;
            }
            points.push({
                minX: l,
                minY: b,
                maxX: r,
                maxY: t,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    QuadView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sbottom, sleft, sright, stop;
        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {
                continue;
            }
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
            }
            if (this.visuals.line.doit) {
                ctx.beginPath();
                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    QuadView.prototype._hit_point = function (geometry) {
        var hits, ref, result, vx, vy, x, y;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        hits = this.index.indices({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y
        });
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    QuadView.prototype.get_anchor_point = function (anchor, i, spt) {
        var bottom, left, right, top;
        left = Math.min(this.sleft[i], this.sright[i]);
        right = Math.max(this.sright[i], this.sleft[i]);
        top = Math.min(this.stop[i], this.sbottom[i]);
        bottom = Math.max(this.sbottom[i], this.stop[i]);
        switch (anchor) {
        case 'top_left':
            return {
                x: left,
                y: top
            };
        case 'top_center':
            return {
                x: (left + right) / 2,
                y: top
            };
        case 'top_right':
            return {
                x: right,
                y: top
            };
        case 'center_right':
            return {
                x: right,
                y: (top + bottom) / 2
            };
        case 'bottom_right':
            return {
                x: right,
                y: bottom
            };
        case 'bottom_center':
            return {
                x: (left + right) / 2,
                y: bottom
            };
        case 'bottom_left':
            return {
                x: left,
                y: bottom
            };
        case 'center_left':
            return {
                x: left,
                y: (top + bottom) / 2
            };
        case 'center':
            return {
                x: (left + right) / 2,
                y: (top + bottom) / 2
            };
        }
    };
    QuadView.prototype.scx = function (i) {
        return (this.sleft[i] + this.sright[i]) / 2;
    };
    QuadView.prototype.scy = function (i) {
        return (this.stop[i] + this.sbottom[i]) / 2;
    };
    QuadView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return QuadView;
}(glyph_1.GlyphView);
exports.Quad = function (superClass) {
    extend(Quad, superClass);
    function Quad() {
        return Quad.__super__.constructor.apply(this, arguments);
    }
    Quad.prototype.default_view = exports.QuadView;
    Quad.prototype.type = 'Quad';
    Quad.coords([
        [
            'right',
            'bottom'
        ],
        [
            'left',
            'top'
        ]
    ]);
    Quad.mixins([
        'line',
        'fill'
    ]);
    return Quad;
}(glyph_1.Glyph);    
},
/* models/glyphs/quadratic */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _qbb, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
_qbb = function (u, v, w) {
    var bd, t;
    if (v === (u + w) / 2) {
        return [
            u,
            w
        ];
    } else {
        t = (u - v) / (u - 2 * v + w);
        bd = u * Math.pow(1 - t, 2) + 2 * v * (1 - t) * t + w * Math.pow(t, 2);
        return [
            Math.min(u, w, bd),
            Math.max(u, w, bd)
        ];
    }
};
exports.QuadraticView = function (superClass) {
    extend(QuadraticView, superClass);
    function QuadraticView() {
        return QuadraticView.__super__.constructor.apply(this, arguments);
    }
    QuadraticView.prototype._index_data = function () {
        var i, j, points, ref, ref1, ref2, x0, x1, y0, y1;
        points = [];
        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i])) {
                continue;
            }
            ref1 = _qbb(this._x0[i], this._cx[i], this._x1[i]), x0 = ref1[0], x1 = ref1[1];
            ref2 = _qbb(this._y0[i], this._cy[i], this._y1[i]), y0 = ref2[0], y1 = ref2[1];
            points.push({
                minX: x0,
                minY: y0,
                maxX: x1,
                maxY: y1,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    QuadraticView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, scx, scy, sx0, sx1, sy0, sy1;
        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1, scx = arg.scx, scy = arg.scy;
        if (this.visuals.line.doit) {
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.moveTo(sx0[i], sy0[i]);
                ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            }
            return results;
        }
    };
    QuadraticView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return QuadraticView;
}(glyph_1.GlyphView);
exports.Quadratic = function (superClass) {
    extend(Quadratic, superClass);
    function Quadratic() {
        return Quadratic.__super__.constructor.apply(this, arguments);
    }
    Quadratic.prototype.default_view = exports.QuadraticView;
    Quadratic.prototype.type = 'Quadratic';
    Quadratic.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ],
        [
            'cx',
            'cy'
        ]
    ]);
    Quadratic.mixins(['line']);
    return Quadratic;
}(glyph_1.Glyph);    
},
/* models/glyphs/ray */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
exports.RayView = function (superClass) {
    extend(RayView, superClass);
    function RayView() {
        return RayView.__super__.constructor.apply(this, arguments);
    }
    RayView.prototype._map_data = function () {
        return this.slength = this.sdist(this.renderer.xscale, this._x, this._length);
    };
    RayView.prototype._render = function (ctx, indices, arg) {
        var _angle, height, i, inf_len, j, k, len, ref, results, slength, sx, sy, width;
        sx = arg.sx, sy = arg.sy, slength = arg.slength, _angle = arg._angle;
        if (this.visuals.line.doit) {
            width = this.renderer.plot_view.frame._width.value;
            height = this.renderer.plot_view.frame._height.value;
            inf_len = 2 * (width + height);
            for (i = j = 0, ref = slength.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (slength[i] === 0) {
                    slength[i] = inf_len;
                }
            }
            results = [];
            for (k = 0, len = indices.length; k < len; k++) {
                i = indices[k];
                if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i])) {
                    continue;
                }
                ctx.translate(sx[i], sy[i]);
                ctx.rotate(_angle[i]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(slength[i], 0);
                this.visuals.line.set_vectorize(ctx, i);
                ctx.stroke();
                ctx.rotate(-_angle[i]);
                results.push(ctx.translate(-sx[i], -sy[i]));
            }
            return results;
        }
    };
    RayView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return RayView;
}(xy_glyph_1.XYGlyphView);
exports.Ray = function (superClass) {
    extend(Ray, superClass);
    function Ray() {
        return Ray.__super__.constructor.apply(this, arguments);
    }
    Ray.prototype.default_view = exports.RayView;
    Ray.prototype.type = 'Ray';
    Ray.mixins(['line']);
    Ray.define({
        length: [p.DistanceSpec],
        angle: [p.AngleSpec]
    });
    return Ray;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/rect */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.RectView = function (superClass) {
    extend(RectView, superClass);
    function RectView() {
        return RectView.__super__.constructor.apply(this, arguments);
    }
    RectView.prototype._set_data = function () {
        this.max_w2 = 0;
        if (this.model.properties.width.units === 'data') {
            this.max_w2 = this.max_width / 2;
        }
        this.max_h2 = 0;
        if (this.model.properties.height.units === 'data') {
            return this.max_h2 = this.max_height / 2;
        }
    };
    RectView.prototype._map_data = function () {
        var canvas, i, ref, ref1;
        canvas = this.renderer.plot_view.canvas;
        if (this.model.properties.width.units === 'data') {
            ref = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xscale, canvas, 0), this.sw = ref[0], this.sx0 = ref[1];
        } else {
            this.sw = this._width;
            this.sx0 = function () {
                var j, ref1, results;
                results = [];
                for (i = j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                    results.push(this.sx[i] - this.sw[i] / 2);
                }
                return results;
            }.call(this);
        }
        if (this.model.properties.height.units === 'data') {
            ref1 = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.yscale, canvas, 1), this.sh = ref1[0], this.sy1 = ref1[1];
        } else {
            this.sh = this._height;
            this.sy1 = function () {
                var j, ref2, results;
                results = [];
                for (i = j = 0, ref2 = this.sy.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
                    results.push(this.sy[i] - this.sh[i] / 2);
                }
                return results;
            }.call(this);
        }
        return this.ssemi_diag = function () {
            var j, ref2, results;
            results = [];
            for (i = j = 0, ref2 = this.sw.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
                results.push(Math.sqrt(this.sw[i] / 2 * this.sw[i] / 2 + this.sh[i] / 2 * this.sh[i] / 2));
            }
            return results;
        }.call(this);
    };
    RectView.prototype._render = function (ctx, indices, arg) {
        var _angle, i, j, k, len, len1, sh, sw, sx, sx0, sy, sy1;
        sx = arg.sx, sy = arg.sy, sx0 = arg.sx0, sy1 = arg.sy1, sw = arg.sw, sh = arg.sh, _angle = arg._angle;
        if (this.visuals.fill.doit) {
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {
                    continue;
                }
                this.visuals.fill.set_vectorize(ctx, i);
                if (_angle[i]) {
                    ctx.translate(sx[i], sy[i]);
                    ctx.rotate(_angle[i]);
                    ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                    ctx.rotate(-_angle[i]);
                    ctx.translate(-sx[i], -sy[i]);
                } else {
                    ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);
                }
            }
        }
        if (this.visuals.line.doit) {
            ctx.beginPath();
            for (k = 0, len1 = indices.length; k < len1; k++) {
                i = indices[k];
                if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {
                    continue;
                }
                if (sw[i] === 0 || sh[i] === 0) {
                    continue;
                }
                if (_angle[i]) {
                    ctx.translate(sx[i], sy[i]);
                    ctx.rotate(_angle[i]);
                    ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                    ctx.rotate(-_angle[i]);
                    ctx.translate(-sx[i], -sy[i]);
                } else {
                    ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);
                }
                this.visuals.line.set_vectorize(ctx, i);
                ctx.stroke();
                ctx.beginPath();
            }
            return ctx.stroke();
        }
    };
    RectView.prototype._hit_rect = function (geometry) {
        var bbox, ref, ref1, result, x0, x1, y0, y1;
        ref = this.renderer.xscale.v_invert([
            geometry.vx0,
            geometry.vx1
        ]), x0 = ref[0], x1 = ref[1];
        ref1 = this.renderer.yscale.v_invert([
            geometry.vy0,
            geometry.vy1
        ]), y0 = ref1[0], y1 = ref1[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        result = hittest.create_hit_test_result();
        result['1d'].indices = this.index.indices(bbox);
        return result;
    };
    RectView.prototype._hit_point = function (geometry) {
        var bbox, c, d, height_in, hits, i, j, len, max_x2_ddist, max_y2_ddist, px, py, ref, ref1, result, s, scenter_x, scenter_y, sx, sy, vx, vy, width_in, x, x0, x1, y, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        scenter_x = function () {
            var j, ref1, results;
            results = [];
            for (i = j = 0, ref1 = this.sx0.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                results.push(this.sx0[i] + this.sw[i] / 2);
            }
            return results;
        }.call(this);
        scenter_y = function () {
            var j, ref1, results;
            results = [];
            for (i = j = 0, ref1 = this.sy1.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                results.push(this.sy1[i] + this.sh[i] / 2);
            }
            return results;
        }.call(this);
        max_x2_ddist = array_1.max(this._ddist(0, scenter_x, this.ssemi_diag));
        max_y2_ddist = array_1.max(this._ddist(1, scenter_y, this.ssemi_diag));
        x0 = x - max_x2_ddist;
        x1 = x + max_x2_ddist;
        y0 = y - max_y2_ddist;
        y1 = y + max_y2_ddist;
        hits = [];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        ref1 = this.index.indices(bbox);
        for (j = 0, len = ref1.length; j < len; j++) {
            i = ref1[j];
            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
            if (this._angle[i]) {
                d = Math.sqrt(Math.pow(sx - this.sx[i], 2) + Math.pow(sy - this.sy[i], 2));
                s = Math.sin(-this._angle[i]);
                c = Math.cos(-this._angle[i]);
                px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];
                py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];
                sx = px;
                sy = py;
                width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;
                height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;
            } else {
                width_in = sx - this.sx0[i] <= this.sw[i] && sx - this.sx0[i] >= 0;
                height_in = sy - this.sy1[i] <= this.sh[i] && sy - this.sy1[i] >= 0;
            }
            if (height_in && width_in) {
                hits.push(i);
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    RectView.prototype._map_dist_corner_for_data_side_length = function (coord, side_length, scale, canvas, dim) {
        var i, pt0, pt1, sside_length, vpt0, vpt1, vpt_corner, x;
        if (scale.source_range.synthetic != null) {
            coord = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = coord.length; j < len; j++) {
                    x = coord[j];
                    results.push(scale.source_range.synthetic(x));
                }
                return results;
            }();
        }
        pt0 = function () {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(Number(coord[i]) - side_length[i] / 2);
            }
            return results;
        }();
        pt1 = function () {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(Number(coord[i]) + side_length[i] / 2);
            }
            return results;
        }();
        vpt0 = scale.v_compute(pt0);
        vpt1 = scale.v_compute(pt1);
        sside_length = this.sdist(scale, pt0, side_length, 'edge', this.model.dilate);
        if (dim === 0) {
            vpt_corner = vpt0[0] < vpt1[0] ? vpt0 : vpt1;
            return [
                sside_length,
                canvas.v_vx_to_sx(vpt_corner)
            ];
        } else if (dim === 1) {
            vpt_corner = vpt0[0] < vpt1[0] ? vpt1 : vpt0;
            return [
                sside_length,
                canvas.v_vy_to_sy(vpt_corner)
            ];
        }
    };
    RectView.prototype._ddist = function (dim, spts, spans) {
        var i, pt0, pt1, scale, vpt0, vpt1, vpts;
        if (dim === 0) {
            vpts = this.renderer.plot_view.canvas.v_sx_to_vx(spts);
            scale = this.renderer.xscale;
        } else {
            vpts = this.renderer.plot_view.canvas.v_vy_to_sy(spts);
            scale = this.renderer.yscale;
        }
        vpt0 = vpts;
        vpt1 = function () {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = vpt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(vpt0[i] + spans[i]);
            }
            return results;
        }();
        pt0 = scale.v_invert(vpt0);
        pt1 = scale.v_invert(vpt1);
        return function () {
            var j, ref, results;
            results = [];
            for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(Math.abs(pt1[i] - pt0[i]));
            }
            return results;
        }();
    };
    RectView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    RectView.prototype._bounds = function (bds) {
        return this.max_wh2_bounds(bds);
    };
    return RectView;
}(xy_glyph_1.XYGlyphView);
exports.Rect = function (superClass) {
    extend(Rect, superClass);
    function Rect() {
        return Rect.__super__.constructor.apply(this, arguments);
    }
    Rect.prototype.default_view = exports.RectView;
    Rect.prototype.type = 'Rect';
    Rect.mixins([
        'line',
        'fill'
    ]);
    Rect.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ]
    });
    return Rect;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/segment */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var hittest = require(8    /* core/hittest */);
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
exports.SegmentView = function (superClass) {
    extend(SegmentView, superClass);
    function SegmentView() {
        return SegmentView.__super__.constructor.apply(this, arguments);
    }
    SegmentView.prototype._index_data = function () {
        var i, j, points, ref;
        points = [];
        for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (!isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i])) {
                points.push({
                    minX: Math.min(this._x0[i], this._x1[i]),
                    minY: Math.min(this._y0[i], this._y1[i]),
                    maxX: Math.max(this._x0[i], this._x1[i]),
                    maxY: Math.max(this._y0[i], this._y1[i]),
                    i: i
                });
            }
        }
        return new spatial_1.RBush(points);
    };
    SegmentView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sx0, sx1, sy0, sy1;
        sx0 = arg.sx0, sy0 = arg.sy0, sx1 = arg.sx1, sy1 = arg.sy1;
        if (this.visuals.line.doit) {
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.moveTo(sx0[i], sy0[i]);
                ctx.lineTo(sx1[i], sy1[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            }
            return results;
        }
    };
    SegmentView.prototype._hit_point = function (geometry) {
        var candidates, dist, hits, i, j, len, p0, p1, point, ref, ref1, result, threshold, vx, vy, x, y;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx, true);
        y = this.renderer.yscale.invert(vy, true);
        point = {
            x: this.renderer.plot_view.canvas.vx_to_sx(vx),
            y: this.renderer.plot_view.canvas.vy_to_sy(vy)
        };
        hits = [];
        candidates = this.index.indices({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y
        });
        for (j = 0, len = candidates.length; j < len; j++) {
            i = candidates[j];
            threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);
            ref1 = [
                {
                    x: this.sx0[i],
                    y: this.sy0[i]
                },
                {
                    x: this.sx1[i],
                    y: this.sy1[i]
                }
            ], p0 = ref1[0], p1 = ref1[1];
            dist = hittest.dist_to_segment(point, p0, p1);
            if (dist < threshold) {
                hits.push(i);
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    SegmentView.prototype._hit_span = function (geometry) {
        var candidates, hits, hr, i, j, len, ref, ref1, ref2, result, v0, v1, val, vr, vx, vy;
        hr = this.renderer.plot_view.frame.h_range;
        vr = this.renderer.plot_view.frame.v_range;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        if (geometry.direction === 'v') {
            val = this.renderer.yscale.invert(vy);
            ref1 = [
                this._y0,
                this._y1
            ], v0 = ref1[0], v1 = ref1[1];
        } else {
            val = this.renderer.xscale.invert(vx);
            ref2 = [
                this._x0,
                this._x1
            ], v0 = ref2[0], v1 = ref2[1];
        }
        hits = [];
        candidates = this.index.indices({
            minX: this.renderer.xscale.invert(hr.min),
            minY: this.renderer.yscale.invert(vr.min),
            maxX: this.renderer.xscale.invert(hr.max),
            maxY: this.renderer.yscale.invert(vr.max)
        });
        for (j = 0, len = candidates.length; j < len; j++) {
            i = candidates[j];
            if (v0[i] <= val && val <= v1[i] || v1[i] <= val && val <= v0[i]) {
                hits.push(i);
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    SegmentView.prototype.scx = function (i) {
        return (this.sx0[i] + this.sx1[i]) / 2;
    };
    SegmentView.prototype.scy = function (i) {
        return (this.sy0[i] + this.sy1[i]) / 2;
    };
    SegmentView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
    };
    return SegmentView;
}(glyph_1.GlyphView);
exports.Segment = function (superClass) {
    extend(Segment, superClass);
    function Segment() {
        return Segment.__super__.constructor.apply(this, arguments);
    }
    Segment.prototype.default_view = exports.SegmentView;
    Segment.prototype.type = 'Segment';
    Segment.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ]
    ]);
    Segment.mixins(['line']);
    return Segment;
}(glyph_1.Glyph);    
},
/* models/glyphs/text */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var p = require(13    /* core/properties */);
exports.TextView = function (superClass) {
    extend(TextView, superClass);
    function TextView() {
        return TextView.__super__.constructor.apply(this, arguments);
    }
    TextView.prototype._render = function (ctx, indices, arg) {
        var _angle, _text, _x_offset, _y_offset, i, j, len, results, sx, sy;
        sx = arg.sx, sy = arg.sy, _x_offset = arg._x_offset, _y_offset = arg._y_offset, _angle = arg._angle, _text = arg._text;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null) {
                continue;
            }
            if (this.visuals.text.doit) {
                ctx.save();
                ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);
                ctx.rotate(_angle[i]);
                this.visuals.text.set_vectorize(ctx, i);
                ctx.fillText(_text[i], 0, 0);
                results.push(ctx.restore());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    TextView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        ctx.save();
        this.text_props.set_value(ctx);
        ctx.font = this.text_props.font_value();
        ctx.font = ctx.font.replace(/\b[\d\.]+[\w]+\b/, '10pt');
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText('text', x2, (y1 + y2) / 2);
        return ctx.restore();
    };
    return TextView;
}(xy_glyph_1.XYGlyphView);
exports.Text = function (superClass) {
    extend(Text, superClass);
    function Text() {
        return Text.__super__.constructor.apply(this, arguments);
    }
    Text.prototype.default_view = exports.TextView;
    Text.prototype.type = 'Text';
    Text.mixins(['text']);
    Text.define({
        text: [
            p.StringSpec,
            { field: 'text' }
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        x_offset: [
            p.NumberSpec,
            0
        ],
        y_offset: [
            p.NumberSpec,
            0
        ]
    });
    return Text;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/vbar */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
exports.VBarView = function (superClass) {
    extend(VBarView, superClass);
    function VBarView() {
        return VBarView.__super__.constructor.apply(this, arguments);
    }
    VBarView.prototype._map_data = function () {
        var i, j, ref, vbottom, vtop;
        this.sx = this.renderer.xscale.v_compute(this._x);
        vtop = this.renderer.yscale.v_compute(this._top);
        this.stop = this.renderer.plot_view.canvas.v_vy_to_sy(vtop);
        vbottom = this.renderer.yscale.v_compute(this._bottom);
        this.sbottom = this.renderer.plot_view.canvas.v_vy_to_sy(vbottom);
        this.sleft = [];
        this.sright = [];
        this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
        for (i = j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.sleft.push(this.sx[i] - this.sw[i] / 2);
            this.sright.push(this.sx[i] + this.sw[i] / 2);
        }
        return null;
    };
    VBarView.prototype._index_data = function () {
        var b, i, j, l, points, r, ref, t;
        points = [];
        for (i = j = 0, ref = this._x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            l = this._x[i] - this._width[i] / 2;
            r = this._x[i] + this._width[i] / 2;
            t = Math.max(this._top[i], this._bottom[i]);
            b = Math.min(this._top[i], this._bottom[i]);
            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {
                continue;
            }
            points.push({
                minX: l,
                minY: b,
                maxX: r,
                maxY: t,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    VBarView.prototype._render = function (ctx, indices, arg) {
        var i, j, len, results, sbottom, sleft, sright, stop;
        sleft = arg.sleft, sright = arg.sright, stop = arg.stop, sbottom = arg.sbottom;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {
                continue;
            }
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
            }
            if (this.visuals.line.doit) {
                ctx.beginPath();
                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    VBarView.prototype._hit_point = function (geometry) {
        var hits, ref, result, vx, vy, x, y;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        hits = this.index.indices({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y
        });
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    VBarView.prototype.scy = function (i) {
        return (this.stop[i] + this.sbottom[i]) / 2;
    };
    VBarView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return VBarView;
}(glyph_1.GlyphView);
exports.VBar = function (superClass) {
    extend(VBar, superClass);
    function VBar() {
        return VBar.__super__.constructor.apply(this, arguments);
    }
    VBar.prototype.default_view = exports.VBarView;
    VBar.prototype.type = 'VBar';
    VBar.coords([[
            'x',
            'bottom'
        ]]);
    VBar.mixins([
        'line',
        'fill'
    ]);
    VBar.define({
        width: [p.DistanceSpec],
        top: [p.NumberSpec]
    });
    VBar.override({ bottom: 0 });
    return VBar;
}(glyph_1.Glyph);    
},
/* models/glyphs/wedge */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ./xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
var math_1 = require(27    /* core/util/math */);
exports.WedgeView = function (superClass) {
    extend(WedgeView, superClass);
    function WedgeView() {
        return WedgeView.__super__.constructor.apply(this, arguments);
    }
    WedgeView.prototype._map_data = function () {
        if (this.model.properties.radius.units === 'data') {
            return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);
        } else {
            return this.sradius = this._radius;
        }
    };
    WedgeView.prototype._render = function (ctx, indices, arg) {
        var _end_angle, _start_angle, direction, i, j, len, results, sradius, sx, sy;
        sx = arg.sx, sy = arg.sy, sradius = arg.sradius, _start_angle = arg._start_angle, _end_angle = arg._end_angle;
        direction = this.model.properties.direction.value();
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {
                continue;
            }
            ctx.beginPath();
            ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);
            ctx.lineTo(sx[i], sy[i]);
            ctx.closePath();
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                results.push(ctx.stroke());
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    WedgeView.prototype._hit_point = function (geometry) {
        var angle, bbox, candidates, direction, dist, hits, i, j, k, len, len1, r2, ref, ref1, ref2, ref3, ref4, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        x = this.renderer.xscale.invert(vx);
        y = this.renderer.yscale.invert(vy);
        if (this.model.properties.radius.units === 'data') {
            x0 = x - this.max_radius;
            x1 = x + this.max_radius;
            y0 = y - this.max_radius;
            y1 = y + this.max_radius;
        } else {
            vx0 = vx - this.max_radius;
            vx1 = vx + this.max_radius;
            ref1 = this.renderer.xscale.v_invert([
                vx0,
                vx1
            ]), x0 = ref1[0], x1 = ref1[1];
            vy0 = vy - this.max_radius;
            vy1 = vy + this.max_radius;
            ref2 = this.renderer.yscale.v_invert([
                vy0,
                vy1
            ]), y0 = ref2[0], y1 = ref2[1];
        }
        candidates = [];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        ref3 = this.index.indices(bbox);
        for (j = 0, len = ref3.length; j < len; j++) {
            i = ref3[j];
            r2 = Math.pow(this.sradius[i], 2);
            sx0 = this.renderer.xscale.compute(x);
            sx1 = this.renderer.xscale.compute(this._x[i]);
            sy0 = this.renderer.yscale.compute(y);
            sy1 = this.renderer.yscale.compute(this._y[i]);
            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
            if (dist <= r2) {
                candidates.push([
                    i,
                    dist
                ]);
            }
        }
        direction = this.model.properties.direction.value();
        hits = [];
        for (k = 0, len1 = candidates.length; k < len1; k++) {
            ref4 = candidates[k], i = ref4[0], dist = ref4[1];
            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
            angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
            if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {
                hits.push([
                    i,
                    dist
                ]);
            }
        }
        return hittest.create_1d_hit_test_result(hits);
    };
    WedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
    };
    return WedgeView;
}(xy_glyph_1.XYGlyphView);
exports.Wedge = function (superClass) {
    extend(Wedge, superClass);
    function Wedge() {
        return Wedge.__super__.constructor.apply(this, arguments);
    }
    Wedge.prototype.default_view = exports.WedgeView;
    Wedge.prototype.type = 'Wedge';
    Wedge.mixins([
        'line',
        'fill'
    ]);
    Wedge.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });
    return Wedge;
}(xy_glyph_1.XYGlyph);    
},
/* models/glyphs/xy_glyph */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var spatial_1 = require(34    /* core/util/spatial */);
var glyph_1 = require(104    /* ./glyph */);
exports.XYGlyphView = function (superClass) {
    extend(XYGlyphView, superClass);
    function XYGlyphView() {
        return XYGlyphView.__super__.constructor.apply(this, arguments);
    }
    XYGlyphView.prototype._index_data = function () {
        var i, j, points, ref, x, y;
        points = [];
        for (i = j = 0, ref = this._x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            x = this._x[i];
            y = this._y[i];
            if (isNaN(x + y) || !isFinite(x + y)) {
                continue;
            }
            points.push({
                minX: x,
                minY: y,
                maxX: x,
                maxY: y,
                i: i
            });
        }
        return new spatial_1.RBush(points);
    };
    return XYGlyphView;
}(glyph_1.GlyphView);
exports.XYGlyph = function (superClass) {
    extend(XYGlyph, superClass);
    function XYGlyph() {
        return XYGlyph.__super__.constructor.apply(this, arguments);
    }
    XYGlyph.prototype.type = 'XYGlyph';
    XYGlyph.prototype.default_view = exports.XYGlyphView;
    XYGlyph.coords([[
            'x',
            'y'
        ]]);
    return XYGlyph;
}(glyph_1.Glyph);    
},
/* models/graphs/graph_hit_test_policy */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var array_1 = require(20    /* core/util/array */);
var hittest_1 = require(8    /* core/hittest */);
exports.GraphHitTestPolicy = function (superClass) {
    extend(GraphHitTestPolicy, superClass);
    function GraphHitTestPolicy() {
        return GraphHitTestPolicy.__super__.constructor.apply(this, arguments);
    }
    GraphHitTestPolicy.prototype.do_selection = function (geometry, graph_view, final, append) {
        return false;
    };
    GraphHitTestPolicy.prototype.do_inspection = function (geometry, graph_view, final, append) {
        return false;
    };
    return GraphHitTestPolicy;
}(model_1.Model);
exports.NodesOnly = function (superClass) {
    extend(NodesOnly, superClass);
    function NodesOnly() {
        return NodesOnly.__super__.constructor.apply(this, arguments);
    }
    NodesOnly.prototype.type = 'NodesOnly';
    NodesOnly.prototype._do = function (geometry, graph_view, final, append) {
        var hit_test_result, node_view;
        node_view = graph_view.node_view;
        hit_test_result = node_view.glyph.hit_test(geometry);
        if (hit_test_result === null) {
            return false;
        }
        this._node_selector.update(hit_test_result, final, append);
        return !this._node_selector.indices.is_empty();
    };
    NodesOnly.prototype.do_selection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.node_view.model.data_source.selected = this._node_selector.indices;
        graph_view.node_view.model.data_source.select.emit();
        return did_hit;
    };
    NodesOnly.prototype.do_inspection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._node_selector = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
        graph_view.node_view.model.data_source.inspect.emit([
            graph_view.node_view,
            { geometry: geometry }
        ]);
        return did_hit;
    };
    return NodesOnly;
}(exports.GraphHitTestPolicy);
exports.NodesAndLinkedEdges = function (superClass) {
    extend(NodesAndLinkedEdges, superClass);
    function NodesAndLinkedEdges() {
        return NodesAndLinkedEdges.__super__.constructor.apply(this, arguments);
    }
    NodesAndLinkedEdges.prototype.type = 'NodesAndLinkedEdges';
    NodesAndLinkedEdges.prototype._do = function (geometry, graph_view, final, append) {
        var edge_indices, edge_source, edge_view, hit_test_result, i, j, k, len, linked_index, node_indices, node_view, ref, ref1;
        ref = [
            graph_view.node_view,
            graph_view.edge_view
        ], node_view = ref[0], edge_view = ref[1];
        hit_test_result = node_view.glyph.hit_test(geometry);
        if (hit_test_result === null) {
            return false;
        }
        this._node_selector.update(hit_test_result, final, append);
        node_indices = function () {
            var j, len, ref1, results;
            ref1 = hit_test_result['1d'].indices;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
                i = ref1[j];
                results.push(node_view.model.data_source.data.index[i]);
            }
            return results;
        }();
        edge_source = edge_view.model.data_source;
        edge_indices = [];
        for (i = j = 0, ref1 = edge_source.data.start.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            if (array_1.contains(node_indices, edge_source.data.start[i]) || array_1.contains(node_indices, edge_source.data.end[i])) {
                edge_indices.push(i);
            }
        }
        linked_index = hittest_1.create_hit_test_result();
        for (k = 0, len = edge_indices.length; k < len; k++) {
            i = edge_indices[k];
            linked_index['2d'].indices[i] = [0];
        }
        this._edge_selector.update(linked_index, final, append);
        return !this._node_selector.indices.is_empty();
    };
    NodesAndLinkedEdges.prototype.do_selection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
        this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.selector;
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.node_view.model.data_source.selected = this._node_selector.indices;
        graph_view.edge_view.model.data_source.selected = this._edge_selector.indices;
        graph_view.node_view.model.data_source.select.emit();
        return did_hit;
    };
    NodesAndLinkedEdges.prototype.do_inspection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._node_selector = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
        this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
        graph_view.edge_view.model.data_source.setv({ inspected: this._edge_selector.indices }, { silent: true });
        graph_view.node_view.model.data_source.inspect.emit([
            graph_view.node_view,
            { geometry: geometry }
        ]);
        return did_hit;
    };
    return NodesAndLinkedEdges;
}(exports.GraphHitTestPolicy);
exports.EdgesAndLinkedNodes = function (superClass) {
    extend(EdgesAndLinkedNodes, superClass);
    function EdgesAndLinkedNodes() {
        return EdgesAndLinkedNodes.__super__.constructor.apply(this, arguments);
    }
    EdgesAndLinkedNodes.prototype.type = 'EdgesAndLinkedNodes';
    EdgesAndLinkedNodes.prototype._do = function (geometry, graph_view, final, append) {
        var edge_indices, edge_view, hit_test_result, i, j, len, node_hit_test_result, node_indices, node_view, nodes, ref;
        ref = [
            graph_view.node_view,
            graph_view.edge_view
        ], node_view = ref[0], edge_view = ref[1];
        hit_test_result = edge_view.glyph.hit_test(geometry);
        if (hit_test_result === null) {
            return false;
        }
        this._edge_selector.update(hit_test_result, final, append);
        edge_indices = function () {
            var j, len, ref1, results;
            ref1 = Object.keys(hit_test_result['2d'].indices);
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
                i = ref1[j];
                results.push(parseInt(i));
            }
            return results;
        }();
        nodes = [];
        for (j = 0, len = edge_indices.length; j < len; j++) {
            i = edge_indices[j];
            nodes.push(edge_view.model.data_source.data.start[i]);
            nodes.push(edge_view.model.data_source.data.end[i]);
        }
        node_indices = function () {
            var k, len1, ref1, results;
            ref1 = array_1.uniq(nodes);
            results = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
                i = ref1[k];
                results.push(node_view.model.data_source.data.index.indexOf(i));
            }
            return results;
        }();
        node_hit_test_result = hittest_1.create_hit_test_result();
        node_hit_test_result['1d'].indices = node_indices;
        this._node_selector.update(node_hit_test_result, final, append);
        return !this._edge_selector.indices.is_empty();
    };
    EdgesAndLinkedNodes.prototype.do_selection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.selector;
        this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.edge_view.model.data_source.selected = this._edge_selector.indices;
        graph_view.node_view.model.data_source.selected = this._node_selector.indices;
        graph_view.edge_view.model.data_source.select.emit();
        return did_hit;
    };
    EdgesAndLinkedNodes.prototype.do_inspection = function (geometry, graph_view, final, append) {
        var did_hit;
        this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
        this._node_selector = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
        did_hit = this._do(geometry, graph_view, final, append);
        graph_view.edge_view.model.data_source.setv({ inspected: this._edge_selector.indices }, { silent: true });
        graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
        graph_view.edge_view.model.data_source.inspect.emit([
            graph_view.edge_view,
            { geometry: geometry }
        ]);
        return did_hit;
    };
    return EdgesAndLinkedNodes;
}(exports.GraphHitTestPolicy);    
},
/* models/graphs/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var tslib_1 = require(357    /* tslib */);
tslib_1.__exportStar(require(124    /* ./graph_hit_test_policy */), exports);
tslib_1.__exportStar(require(126    /* ./layout_provider */), exports);
tslib_1.__exportStar(require(127    /* ./static_layout_provider */), exports);    
},
/* models/graphs/layout_provider */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
exports.LayoutProvider = function (superClass) {
    extend(LayoutProvider, superClass);
    function LayoutProvider() {
        return LayoutProvider.__super__.constructor.apply(this, arguments);
    }
    LayoutProvider.prototype.get_node_coordinates = function (graph_source) {
        return [
            [],
            []
        ];
    };
    LayoutProvider.prototype.get_edge_coordinates = function (graph_source) {
        return [
            [],
            []
        ];
    };
    return LayoutProvider;
}(model_1.Model);    
},
/* models/graphs/static_layout_provider */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var layout_provider_1 = require(126    /* ./layout_provider */);
var p = require(13    /* ../../core/properties */);
exports.StaticLayoutProvider = function (superClass) {
    extend(StaticLayoutProvider, superClass);
    function StaticLayoutProvider() {
        return StaticLayoutProvider.__super__.constructor.apply(this, arguments);
    }
    StaticLayoutProvider.prototype.type = 'StaticLayoutProvider';
    StaticLayoutProvider.prototype.get_node_coordinates = function (node_source) {
        var i, j, len, ref, ref1, x, xs, y, ys;
        ref = [
            [],
            []
        ], xs = ref[0], ys = ref[1];
        ref1 = node_source.data.index;
        for (j = 0, len = ref1.length; j < len; j++) {
            i = ref1[j];
            x = this.graph_layout[i] != null ? this.graph_layout[i][0] : 0 / 0;
            y = this.graph_layout[i] != null ? this.graph_layout[i][1] : 0 / 0;
            xs.push(x);
            ys.push(y);
        }
        return [
            xs,
            ys
        ];
    };
    StaticLayoutProvider.prototype.get_edge_coordinates = function (edge_source) {
        var end, ends, i, j, ref, ref1, ref2, ref3, start, starts, xs, ys;
        ref = [
            [],
            []
        ], xs = ref[0], ys = ref[1];
        starts = edge_source.data.start;
        ends = edge_source.data.end;
        for (i = j = 0, ref1 = starts.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            if (this.graph_layout[starts[i]] != null && this.graph_layout[ends[i]] != null) {
                ref2 = [
                    this.graph_layout[starts[i]],
                    this.graph_layout[ends[i]]
                ], start = ref2[0], end = ref2[1];
            } else {
                ref3 = [
                    [
                        0 / 0,
                        0 / 0
                    ],
                    [
                        0 / 0,
                        0 / 0
                    ]
                ], start = ref3[0], end = ref3[1];
            }
            xs.push([
                start[0],
                end[0]
            ]);
            ys.push([
                start[1],
                end[1]
            ]);
        }
        return [
            xs,
            ys
        ];
    };
    StaticLayoutProvider.define({
        graph_layout: [
            p.Any,
            {}
        ]
    });
    return StaticLayoutProvider;
}(layout_provider_1.LayoutProvider);    
},
/* models/grids/grid */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var guide_renderer_1 = require(158    /* ../renderers/guide_renderer */);
var renderer_1 = require(160    /* ../renderers/renderer */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.GridView = function (superClass) {
    extend(GridView, superClass);
    function GridView() {
        return GridView.__super__.constructor.apply(this, arguments);
    }
    GridView.prototype.initialize = function (attrs, options) {
        GridView.__super__.initialize.call(this, attrs, options);
        this._x_range_name = this.model.x_range_name;
        return this._y_range_name = this.model.y_range_name;
    };
    GridView.prototype.render = function () {
        var ctx;
        if (this.model.visible === false) {
            return;
        }
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        this._draw_regions(ctx);
        this._draw_minor_grids(ctx);
        this._draw_grids(ctx);
        return ctx.restore();
    };
    GridView.prototype.connect_signals = function () {
        GridView.__super__.connect_signals.call(this);
        return this.connect(this.model.change, function () {
            return this.request_render();
        });
    };
    GridView.prototype._draw_regions = function (ctx) {
        var i, k, ref, ref1, ref2, ref3, sx0, sx1, sy0, sy1, xs, ys;
        if (!this.visuals.band_fill.doit) {
            return;
        }
        ref = this.model.grid_coords('major', false), xs = ref[0], ys = ref[1];
        this.visuals.band_fill.set_value(ctx);
        for (i = k = 0, ref1 = xs.length - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            if (i % 2 === 1) {
                ref2 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx0 = ref2[0], sy0 = ref2[1];
                ref3 = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this._x_range_name, this._y_range_name), sx1 = ref3[0], sy1 = ref3[1];
                ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);
                ctx.fill();
            }
        }
    };
    GridView.prototype._draw_grids = function (ctx) {
        var ref, xs, ys;
        if (!this.visuals.grid_line.doit) {
            return;
        }
        ref = this.model.grid_coords('major'), xs = ref[0], ys = ref[1];
        return this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);
    };
    GridView.prototype._draw_minor_grids = function (ctx) {
        var ref, xs, ys;
        if (!this.visuals.minor_grid_line.doit) {
            return;
        }
        ref = this.model.grid_coords('minor'), xs = ref[0], ys = ref[1];
        return this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);
    };
    GridView.prototype._draw_grid_helper = function (ctx, props, xs, ys) {
        var i, k, l, ref, ref1, ref2, sx, sy;
        props.set_value(ctx);
        for (i = k = 0, ref = xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            ref1 = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx = ref1[0], sy = ref1[1];
            ctx.beginPath();
            ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));
            for (i = l = 1, ref2 = sx.length; 1 <= ref2 ? l < ref2 : l > ref2; i = 1 <= ref2 ? ++l : --l) {
                ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));
            }
            ctx.stroke();
        }
    };
    return GridView;
}(renderer_1.RendererView);
exports.Grid = function (superClass) {
    extend(Grid, superClass);
    function Grid() {
        return Grid.__super__.constructor.apply(this, arguments);
    }
    Grid.prototype.default_view = exports.GridView;
    Grid.prototype.type = 'Grid';
    Grid.mixins([
        'line:grid_',
        'line:minor_grid_',
        'fill:band_'
    ]);
    Grid.define({
        bounds: [
            p.Any,
            'auto'
        ],
        dimension: [
            p.Number,
            0
        ],
        ticker: [p.Instance],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Grid.override({
        level: 'underlay',
        band_fill_color: null,
        band_fill_alpha: 0,
        grid_line_color: '#e5e5e5',
        minor_grid_line_color: null
    });
    Grid.prototype.ranges = function () {
        var frame, i, j, ranges;
        i = this.dimension;
        j = (i + 1) % 2;
        frame = this.plot.plot_canvas.frame;
        ranges = [
            frame.x_ranges[this.x_range_name],
            frame.y_ranges[this.y_range_name]
        ];
        return [
            ranges[i],
            ranges[j]
        ];
    };
    Grid.prototype.computed_bounds = function () {
        var cross_range, end, range, range_bounds, ref, start, user_bounds;
        ref = this.ranges(), range = ref[0], cross_range = ref[1];
        user_bounds = this.bounds;
        range_bounds = [
            range.min,
            range.max
        ];
        if (types_1.isArray(user_bounds)) {
            start = Math.min(user_bounds[0], user_bounds[1]);
            end = Math.max(user_bounds[0], user_bounds[1]);
            if (start < range_bounds[0]) {
                start = range_bounds[0];
            } else if (start > range_bounds[1]) {
                start = null;
            }
            if (end > range_bounds[1]) {
                end = range_bounds[1];
            } else if (end < range_bounds[0]) {
                end = null;
            }
        } else {
            start = range_bounds[0], end = range_bounds[1];
        }
        return [
            start,
            end
        ];
    };
    Grid.prototype.grid_coords = function (location, exclude_ends) {
        var N, cmax, cmin, coords, cross_range, dim_i, dim_j, end, i, ii, j, k, l, loc, max, min, n, range, ref, ref1, ref2, ref3, start, ticks, tmp;
        if (exclude_ends == null) {
            exclude_ends = true;
        }
        i = this.dimension;
        j = (i + 1) % 2;
        ref = this.ranges(), range = ref[0], cross_range = ref[1];
        ref1 = this.computed_bounds(), start = ref1[0], end = ref1[1];
        tmp = Math.min(start, end);
        end = Math.max(start, end);
        start = tmp;
        ticks = this.ticker.get_ticks(start, end, range, cross_range.min, {})[location];
        min = range.min;
        max = range.max;
        cmin = cross_range.min;
        cmax = cross_range.max;
        coords = [
            [],
            []
        ];
        for (ii = k = 0, ref2 = ticks.length; 0 <= ref2 ? k < ref2 : k > ref2; ii = 0 <= ref2 ? ++k : --k) {
            if ((ticks[ii] === min || ticks[ii] === max) && exclude_ends) {
                continue;
            }
            dim_i = [];
            dim_j = [];
            N = 2;
            for (n = l = 0, ref3 = N; 0 <= ref3 ? l < ref3 : l > ref3; n = 0 <= ref3 ? ++l : --l) {
                loc = cmin + (cmax - cmin) / (N - 1) * n;
                dim_i.push(ticks[ii]);
                dim_j.push(loc);
            }
            coords[i].push(dim_i);
            coords[j].push(dim_j);
        }
        return coords;
    };
    return Grid;
}(guide_renderer_1.GuideRenderer);    
},
/* models/grids/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var grid_1 = require(128    /* ./grid */);
exports.Grid = grid_1.Grid;    
},
/* models/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var tslib_1 = require(357    /* tslib */);
tslib_1.__exportStar(require(55    /* ./annotations */), exports);
tslib_1.__exportStar(require(70    /* ./axes */), exports);
tslib_1.__exportStar(require(74    /* ./callbacks */), exports);
tslib_1.__exportStar(require(78    /* ./canvas */), exports);
tslib_1.__exportStar(require(80    /* ./expressions */), exports);
tslib_1.__exportStar(require(86    /* ./filters */), exports);
tslib_1.__exportStar(require(92    /* ./formatters */), exports);
tslib_1.__exportStar(require(109    /* ./glyphs */), exports);
tslib_1.__exportStar(require(125    /* ./graphs */), exports);
tslib_1.__exportStar(require(129    /* ./grids */), exports);
tslib_1.__exportStar(require(133    /* ./layouts */), exports);
tslib_1.__exportStar(require(140    /* ./mappers */), exports);
tslib_1.__exportStar(require(233    /* ./transforms */), exports);
tslib_1.__exportStar(require(143    /* ./markers */), exports);
tslib_1.__exportStar(require(147    /* ./plots */), exports);
tslib_1.__exportStar(require(153    /* ./ranges */), exports);
tslib_1.__exportStar(require(159    /* ./renderers */), exports);
tslib_1.__exportStar(require(162    /* ./scales */), exports);
tslib_1.__exportStar(require(172    /* ./sources */), exports);
tslib_1.__exportStar(require(182    /* ./tickers */), exports);
tslib_1.__exportStar(require(194    /* ./tiles */), exports);
tslib_1.__exportStar(require(221    /* ./tools */), exports);    
},
/* models/layouts/box */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var solver_1 = require(11    /* core/layout/solver */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
var layout_dom_1 = require(134    /* ./layout_dom */);
exports.BoxView = function (superClass) {
    extend1(BoxView, superClass);
    function BoxView() {
        return BoxView.__super__.constructor.apply(this, arguments);
    }
    BoxView.prototype.className = 'bk-grid';
    BoxView.prototype.connect_signals = function () {
        BoxView.__super__.connect_signals.call(this);
        return this.connect(this.model.properties.children.change, function (_this) {
            return function () {
                return _this.rebuild_child_views();
            };
        }(this));
    };
    BoxView.prototype.get_height = function () {
        var child_heights, children, height;
        children = this.model.get_layoutable_children();
        child_heights = children.map(function (child) {
            return child._height.value;
        });
        if (this.model._horizontal) {
            height = array_1.max(child_heights);
        } else {
            height = array_1.sum(child_heights);
        }
        return height;
    };
    BoxView.prototype.get_width = function () {
        var child_widths, children, width;
        children = this.model.get_layoutable_children();
        child_widths = children.map(function (child) {
            return child._width.value;
        });
        if (this.model._horizontal) {
            width = array_1.sum(child_widths);
        } else {
            width = array_1.max(child_widths);
        }
        return width;
    };
    return BoxView;
}(layout_dom_1.LayoutDOMView);
exports.Box = function (superClass) {
    extend1(Box, superClass);
    Box.prototype.default_view = exports.BoxView;
    function Box(attrs, options) {
        Box.__super__.constructor.call(this, attrs, options);
        this._child_equal_size_width = new solver_1.Variable(this.toString() + '.child_equal_size_width');
        this._child_equal_size_height = new solver_1.Variable(this.toString() + '.child_equal_size_height');
        this._box_equal_size_top = new solver_1.Variable(this.toString() + '.box_equal_size_top');
        this._box_equal_size_bottom = new solver_1.Variable(this.toString() + '.box_equal_size_bottom');
        this._box_equal_size_left = new solver_1.Variable(this.toString() + '.box_equal_size_left');
        this._box_equal_size_right = new solver_1.Variable(this.toString() + '.box_equal_size_right');
        this._box_cell_align_top = new solver_1.Variable(this.toString() + '.box_cell_align_top');
        this._box_cell_align_bottom = new solver_1.Variable(this.toString() + '.box_cell_align_bottom');
        this._box_cell_align_left = new solver_1.Variable(this.toString() + '.box_cell_align_left');
        this._box_cell_align_right = new solver_1.Variable(this.toString() + '.box_cell_align_right');
    }
    Box.define({
        children: [
            p.Array,
            []
        ]
    });
    Box.internal({
        spacing: [
            p.Number,
            6
        ]
    });
    Box.prototype.get_layoutable_children = function () {
        return this.children;
    };
    Box.prototype.get_constrained_variables = function () {
        return object_1.extend({}, Box.__super__.get_constrained_variables.call(this), {
            box_equal_size_top: this._box_equal_size_top,
            box_equal_size_bottom: this._box_equal_size_bottom,
            box_equal_size_left: this._box_equal_size_left,
            box_equal_size_right: this._box_equal_size_right,
            box_cell_align_top: this._box_cell_align_top,
            box_cell_align_bottom: this._box_cell_align_bottom,
            box_cell_align_left: this._box_cell_align_left,
            box_cell_align_right: this._box_cell_align_right
        });
    };
    Box.prototype.get_constraints = function () {
        var child, children, constraints, i, j, k, last, len, next, rect, ref, vars;
        constraints = [];
        children = this.get_layoutable_children();
        if (children.length === 0) {
            return constraints;
        }
        for (j = 0, len = children.length; j < len; j++) {
            child = children[j];
            vars = child.get_constrained_variables();
            rect = this._child_rect(vars);
            if (this._horizontal) {
                if (vars.height != null) {
                    constraints.push(solver_1.EQ(rect.height, [
                        -1,
                        this._height
                    ]));
                }
            } else {
                if (vars.width != null) {
                    constraints.push(solver_1.EQ(rect.width, [
                        -1,
                        this._width
                    ]));
                }
            }
            if (this._horizontal) {
                if (vars.box_equal_size_left != null && vars.box_equal_size_right != null && vars.width != null) {
                    constraints.push(solver_1.EQ([
                        -1,
                        vars.box_equal_size_left
                    ], [
                        -1,
                        vars.box_equal_size_right
                    ], vars.width, this._child_equal_size_width));
                }
            } else {
                if (vars.box_equal_size_top != null && vars.box_equal_size_bottom != null && vars.height != null) {
                    constraints.push(solver_1.EQ([
                        -1,
                        vars.box_equal_size_top
                    ], [
                        -1,
                        vars.box_equal_size_bottom
                    ], vars.height, this._child_equal_size_height));
                }
            }
        }
        last = this._info(children[0].get_constrained_variables());
        constraints.push(solver_1.EQ(last.span.start, 0));
        for (i = k = 1, ref = children.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
            next = this._info(children[i].get_constrained_variables());
            if (last.span.size) {
                constraints.push(solver_1.EQ(last.span.start, last.span.size, [
                    -1,
                    next.span.start
                ]));
            }
            constraints.push(solver_1.WEAK_EQ(last.whitespace.after, next.whitespace.before, 0 - this.spacing));
            constraints.push(solver_1.GE(last.whitespace.after, next.whitespace.before, 0 - this.spacing));
            last = next;
        }
        if (this._horizontal) {
            if (vars.width != null) {
                constraints.push(solver_1.EQ(last.span.start, last.span.size, [
                    -1,
                    this._width
                ]));
            }
        } else {
            if (vars.height != null) {
                constraints.push(solver_1.EQ(last.span.start, last.span.size, [
                    -1,
                    this._height
                ]));
            }
        }
        constraints = constraints.concat(this._align_outer_edges_constraints(true), this._align_outer_edges_constraints(false), this._align_inner_cell_edges_constraints(), this._box_equal_size_bounds(true), this._box_equal_size_bounds(false), this._box_cell_align_bounds(true), this._box_cell_align_bounds(false), this._box_whitespace(true), this._box_whitespace(false));
        return constraints;
    };
    Box.prototype._child_rect = function (vars) {
        return {
            x: vars.origin_x,
            y: vars.origin_y,
            width: vars.width,
            height: vars.height
        };
    };
    Box.prototype._span = function (rect) {
        if (this._horizontal) {
            return {
                start: rect.x,
                size: rect.width
            };
        } else {
            return {
                start: rect.y,
                size: rect.height
            };
        }
    };
    Box.prototype._info = function (vars) {
        var span, whitespace;
        if (this._horizontal) {
            whitespace = {
                before: vars.whitespace_left,
                after: vars.whitespace_right
            };
        } else {
            whitespace = {
                before: vars.whitespace_top,
                after: vars.whitespace_bottom
            };
        }
        span = this._span(this._child_rect(vars));
        return {
            span: span,
            whitespace: whitespace
        };
    };
    Box.prototype._flatten_cell_edge_variables = function (horizontal) {
        var add_path, all_vars, arity, cell, cell_vars, child, children, direction, flattened, j, k, key, kind, len, len1, name, new_key, parsed, path, relevant_edges, variables;
        if (horizontal) {
            relevant_edges = Box._top_bottom_inner_cell_edge_variables;
        } else {
            relevant_edges = Box._left_right_inner_cell_edge_variables;
        }
        add_path = horizontal !== this._horizontal;
        children = this.get_layoutable_children();
        arity = children.length;
        flattened = {};
        cell = 0;
        for (j = 0, len = children.length; j < len; j++) {
            child = children[j];
            if (child instanceof Box) {
                cell_vars = child._flatten_cell_edge_variables(horizontal);
            } else {
                cell_vars = {};
            }
            all_vars = child.get_constrained_variables();
            for (k = 0, len1 = relevant_edges.length; k < len1; k++) {
                name = relevant_edges[k];
                if (name in all_vars) {
                    cell_vars[name] = [all_vars[name]];
                }
            }
            for (key in cell_vars) {
                variables = cell_vars[key];
                if (add_path) {
                    parsed = key.split(' ');
                    kind = parsed[0];
                    if (parsed.length > 1) {
                        path = parsed[1];
                    } else {
                        path = '';
                    }
                    if (this._horizontal) {
                        direction = 'row';
                    } else {
                        direction = 'col';
                    }
                    new_key = kind + ' ' + direction + '-' + arity + '-' + cell + '-' + path;
                } else {
                    new_key = key;
                }
                if (new_key in flattened) {
                    flattened[new_key] = flattened[new_key].concat(variables);
                } else {
                    flattened[new_key] = variables;
                }
            }
            cell = cell + 1;
        }
        return flattened;
    };
    Box.prototype._align_inner_cell_edges_constraints = function () {
        var constraints, flattened, i, j, key, last, ref, variables;
        constraints = [];
        if (this.document != null && indexOf.call(this.document.roots(), this) >= 0) {
            flattened = this._flatten_cell_edge_variables(this._horizontal);
            for (key in flattened) {
                variables = flattened[key];
                if (variables.length > 1) {
                    last = variables[0];
                    for (i = j = 1, ref = variables.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                        constraints.push(solver_1.EQ(variables[i], [
                            -1,
                            last
                        ]));
                    }
                }
            }
        }
        return constraints;
    };
    Box.prototype._find_edge_leaves = function (horizontal) {
        var child, child_leaves, children, end, j, leaves, len, start;
        children = this.get_layoutable_children();
        leaves = [
            [],
            []
        ];
        if (children.length > 0) {
            if (this._horizontal === horizontal) {
                start = children[0];
                end = children[children.length - 1];
                if (start instanceof Box) {
                    leaves[0] = leaves[0].concat(start._find_edge_leaves(horizontal)[0]);
                } else {
                    leaves[0].push(start);
                }
                if (end instanceof Box) {
                    leaves[1] = leaves[1].concat(end._find_edge_leaves(horizontal)[1]);
                } else {
                    leaves[1].push(end);
                }
            } else {
                for (j = 0, len = children.length; j < len; j++) {
                    child = children[j];
                    if (child instanceof Box) {
                        child_leaves = child._find_edge_leaves(horizontal);
                        leaves[0] = leaves[0].concat(child_leaves[0]);
                        leaves[1] = leaves[1].concat(child_leaves[1]);
                    } else {
                        leaves[0].push(child);
                        leaves[1].push(child);
                    }
                }
            }
        }
        return leaves;
    };
    Box.prototype._align_outer_edges_constraints = function (horizontal) {
        var add_all_equal, collect_vars, end_edges, end_leaves, end_variable, ref, result, start_edges, start_leaves, start_variable;
        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];
        if (horizontal) {
            start_variable = 'on_edge_align_left';
            end_variable = 'on_edge_align_right';
        } else {
            start_variable = 'on_edge_align_top';
            end_variable = 'on_edge_align_bottom';
        }
        collect_vars = function (leaves, name) {
            var edges, j, leaf, len, vars;
            edges = [];
            for (j = 0, len = leaves.length; j < len; j++) {
                leaf = leaves[j];
                vars = leaf.get_constrained_variables();
                if (name in vars) {
                    edges.push(vars[name]);
                }
            }
            return edges;
        };
        start_edges = collect_vars(start_leaves, start_variable);
        end_edges = collect_vars(end_leaves, end_variable);
        result = [];
        add_all_equal = function (edges) {
            var edge, first, i, j, ref1;
            if (edges.length > 1) {
                first = edges[0];
                for (i = j = 1, ref1 = edges.length; 1 <= ref1 ? j < ref1 : j > ref1; i = 1 <= ref1 ? ++j : --j) {
                    edge = edges[i];
                    result.push(solver_1.EQ([
                        -1,
                        first
                    ], edge));
                }
                return null;
            }
        };
        add_all_equal(start_edges);
        add_all_equal(end_edges);
        return result;
    };
    Box.prototype._box_insets_from_child_insets = function (horizontal, child_variable_prefix, our_variable_prefix, minimum) {
        var add_constraints, end_leaves, end_variable, our_end, our_start, ref, result, start_leaves, start_variable;
        ref = this._find_edge_leaves(horizontal), start_leaves = ref[0], end_leaves = ref[1];
        if (horizontal) {
            start_variable = child_variable_prefix + '_left';
            end_variable = child_variable_prefix + '_right';
            our_start = this[our_variable_prefix + '_left'];
            our_end = this[our_variable_prefix + '_right'];
        } else {
            start_variable = child_variable_prefix + '_top';
            end_variable = child_variable_prefix + '_bottom';
            our_start = this[our_variable_prefix + '_top'];
            our_end = this[our_variable_prefix + '_bottom'];
        }
        result = [];
        add_constraints = function (ours, leaves, name) {
            var edges, j, leaf, len, vars;
            edges = [];
            for (j = 0, len = leaves.length; j < len; j++) {
                leaf = leaves[j];
                vars = leaf.get_constrained_variables();
                if (name in vars) {
                    if (minimum) {
                        result.push(solver_1.GE([
                            -1,
                            ours
                        ], vars[name]));
                    } else {
                        result.push(solver_1.EQ([
                            -1,
                            ours
                        ], vars[name]));
                    }
                }
            }
            return null;
        };
        add_constraints(our_start, start_leaves, start_variable);
        add_constraints(our_end, end_leaves, end_variable);
        return result;
    };
    Box.prototype._box_equal_size_bounds = function (horizontal) {
        return this._box_insets_from_child_insets(horizontal, 'box_equal_size', '_box_equal_size', false);
    };
    Box.prototype._box_cell_align_bounds = function (horizontal) {
        return this._box_insets_from_child_insets(horizontal, 'box_cell_align', '_box_cell_align', false);
    };
    Box.prototype._box_whitespace = function (horizontal) {
        return this._box_insets_from_child_insets(horizontal, 'whitespace', '_whitespace', true);
    };
    Box._left_right_inner_cell_edge_variables = [
        'box_cell_align_left',
        'box_cell_align_right'
    ];
    Box._top_bottom_inner_cell_edge_variables = [
        'box_cell_align_top',
        'box_cell_align_bottom'
    ];
    return Box;
}(layout_dom_1.LayoutDOM);    
},
/* models/layouts/column */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var box_1 = require(131    /* ./box */);
exports.ColumnView = function (superClass) {
    extend(ColumnView, superClass);
    function ColumnView() {
        return ColumnView.__super__.constructor.apply(this, arguments);
    }
    ColumnView.prototype.className = 'bk-grid-column';
    return ColumnView;
}(box_1.BoxView);
exports.Column = function (superClass) {
    extend(Column, superClass);
    Column.prototype.type = 'Column';
    Column.prototype.default_view = exports.ColumnView;
    function Column(attrs, options) {
        Column.__super__.constructor.call(this, attrs, options);
        this._horizontal = false;
    }
    return Column;
}(box_1.Box);    
},
/* models/layouts/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var box_1 = require(131    /* ./box */);
exports.Box = box_1.Box;
var column_1 = require(132    /* ./column */);
exports.Column = column_1.Column;
var layout_dom_1 = require(134    /* ./layout_dom */);
exports.LayoutDOM = layout_dom_1.LayoutDOM;
var row_1 = require(135    /* ./row */);
exports.Row = row_1.Row;
var spacer_1 = require(136    /* ./spacer */);
exports.Spacer = spacer_1.Spacer;
var widget_box_1 = require(137    /* ./widget_box */);
exports.WidgetBox = widget_box_1.WidgetBox;    
},
/* models/layouts/layout_dom */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var layout_canvas_1 = require(9    /* core/layout/layout_canvas */);
var solver_1 = require(11    /* core/layout/solver */);
var build_views_1 = require(3    /* core/build_views */);
var dom_view_1 = require(5    /* core/dom_view */);
var logging_1 = require(12    /* core/logging */);
exports.LayoutDOMView = function (superClass) {
    extend1(LayoutDOMView, superClass);
    function LayoutDOMView() {
        return LayoutDOMView.__super__.constructor.apply(this, arguments);
    }
    LayoutDOMView.prototype.initialize = function (options) {
        LayoutDOMView.__super__.initialize.call(this, options);
        if (this.is_root) {
            this._solver = new solver_1.Solver();
        }
        this.child_views = {};
        this.build_child_views();
        return this.connect_signals();
    };
    LayoutDOMView.prototype.remove = function () {
        var _, ref, view;
        ref = this.child_views;
        for (_ in ref) {
            view = ref[_];
            view.remove();
        }
        this.child_views = {};
        return LayoutDOMView.__super__.remove.call(this);
    };
    LayoutDOMView.prototype.has_finished = function () {
        var _, child, ref;
        if (!LayoutDOMView.__super__.has_finished.call(this)) {
            return false;
        }
        ref = this.child_views;
        for (_ in ref) {
            child = ref[_];
            if (!child.has_finished()) {
                return false;
            }
        }
        return true;
    };
    LayoutDOMView.prototype.notify_finished = function () {
        if (!this.is_root) {
            return LayoutDOMView.__super__.notify_finished.call(this);
        } else {
            if (!this._idle_notified && this.has_finished()) {
                if (this.model.document != null) {
                    this._idle_notified = true;
                    return this.model.document.notify_idle(this.model);
                }
            }
        }
    };
    LayoutDOMView.prototype._calc_width_height = function () {
        var height, measuring, ref, width;
        measuring = this.el;
        while (true) {
            measuring = measuring.parentNode;
            if (measuring == null) {
                logging_1.logger.warn('detached element');
                width = height = null;
                break;
            }
            ref = measuring.getBoundingClientRect(), width = ref.width, height = ref.height;
            if (height !== 0) {
                break;
            }
        }
        return [
            width,
            height
        ];
    };
    LayoutDOMView.prototype._init_solver = function () {
        var constraint, constraints, edit_variable, editables, i, j, len, len1, variables;
        this._root_width = new solver_1.Variable(this.toString() + '.root_width');
        this._root_height = new solver_1.Variable(this.toString() + '.root_height');
        this._solver.add_edit_variable(this._root_width);
        this._solver.add_edit_variable(this._root_height);
        editables = this.model.get_all_editables();
        for (i = 0, len = editables.length; i < len; i++) {
            edit_variable = editables[i];
            this._solver.add_edit_variable(edit_variable, solver_1.Strength.strong);
        }
        constraints = this.model.get_all_constraints();
        for (j = 0, len1 = constraints.length; j < len1; j++) {
            constraint = constraints[j];
            this._solver.add_constraint(constraint);
        }
        variables = this.model.get_constrained_variables();
        if (variables.width != null) {
            this._solver.add_constraint(solver_1.EQ(variables.width, this._root_width));
        }
        if (variables.height != null) {
            this._solver.add_constraint(solver_1.EQ(variables.height, this._root_height));
        }
        return this._solver.update_variables();
    };
    LayoutDOMView.prototype._suggest_dims = function (width, height) {
        var ref, variables;
        variables = this.model.get_constrained_variables();
        if (variables.width != null || variables.height != null) {
            if (width === null || height === null) {
                ref = this._calc_width_height(), width = ref[0], height = ref[1];
            }
            if (variables.width != null && width != null) {
                this._solver.suggest_value(this._root_width, width);
            }
            if (variables.height != null && height != null) {
                this._solver.suggest_value(this._root_height, height);
            }
            return this._solver.update_variables();
        }
    };
    LayoutDOMView.prototype.resize = function (width, height) {
        if (width == null) {
            width = null;
        }
        if (height == null) {
            height = null;
        }
        if (!this.is_root) {
            return this.root.resize(width, height);
        } else {
            return this._do_layout(false, width, height);
        }
    };
    LayoutDOMView.prototype.layout = function (full) {
        if (full == null) {
            full = true;
        }
        if (!this.is_root) {
            return this.root.layout(full);
        } else {
            return this._do_layout(full);
        }
    };
    LayoutDOMView.prototype._do_layout = function (full, width, height) {
        if (width == null) {
            width = null;
        }
        if (height == null) {
            height = null;
        }
        if (full) {
            this._solver.clear();
            this._init_solver();
        }
        this._suggest_dims(width, height);
        this._layout();
        this._layout();
        this._layout(true);
        return this.notify_finished();
    };
    LayoutDOMView.prototype._layout = function (final) {
        var child, child_view, i, len, ref;
        if (final == null) {
            final = false;
        }
        ref = this.model.get_layoutable_children();
        for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            child_view = this.child_views[child.id];
            if (child_view._layout != null) {
                child_view._layout(final);
            }
        }
        this.render();
        if (final) {
            return this._has_finished = true;
        }
    };
    LayoutDOMView.prototype.rebuild_child_views = function () {
        this.solver.clear();
        this.build_child_views();
        return this.layout();
    };
    LayoutDOMView.prototype.build_child_views = function () {
        var child, child_view, children, i, len, results;
        children = this.model.get_layoutable_children();
        build_views_1.build_views(this.child_views, children, { parent: this });
        dom_1.empty(this.el);
        results = [];
        for (i = 0, len = children.length; i < len; i++) {
            child = children[i];
            child_view = this.child_views[child.id];
            results.push(this.el.appendChild(child_view.el));
        }
        return results;
    };
    LayoutDOMView.prototype.connect_signals = function () {
        LayoutDOMView.__super__.connect_signals.call(this);
        if (this.is_root) {
            window.addEventListener('resize', function (_this) {
                return function () {
                    return _this.resize();
                };
            }(this));
        }
        return this.connect(this.model.properties.sizing_mode.change, function (_this) {
            return function () {
                return _this.layout();
            };
        }(this));
    };
    LayoutDOMView.prototype._render_classes = function () {
        var cls, i, len, ref, results;
        this.el.className = '';
        if (this.className != null) {
            this.el.classList.add(this.className);
        }
        if (this.model.sizing_mode != null) {
            this.el.classList.add('bk-layout-' + this.model.sizing_mode);
        }
        if (this.model.css_classes != null) {
            ref = this.model.css_classes;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                cls = ref[i];
                results.push(this.el.classList.add(cls));
            }
            return results;
        }
    };
    LayoutDOMView.prototype.render = function () {
        var height, width;
        this._render_classes();
        switch (this.model.sizing_mode) {
        case 'fixed':
            if (this.model.width != null) {
                width = this.model.width;
            } else {
                width = this.get_width();
                this.model.setv({ width: width }, { silent: true });
            }
            if (this.model.height != null) {
                height = this.model.height;
            } else {
                height = this.get_height();
                this.model.setv({ height: height }, { silent: true });
            }
            this.solver.suggest_value(this.model._width, width);
            this.solver.suggest_value(this.model._height, height);
            this.solver.update_variables();
            this.el.style.position = 'relative';
            this.el.style.left = '';
            this.el.style.top = '';
            this.el.style.width = width + 'px';
            return this.el.style.height = height + 'px';
        case 'scale_width':
            height = this.get_height();
            this.solver.suggest_value(this.model._height, height);
            this.solver.update_variables();
            this.el.style.position = 'relative';
            this.el.style.left = '';
            this.el.style.top = '';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        case 'scale_height':
            width = this.get_width();
            this.solver.suggest_value(this.model._width, width);
            this.solver.update_variables();
            this.el.style.position = 'relative';
            this.el.style.left = '';
            this.el.style.top = '';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        case 'stretch_both':
            this.el.style.position = 'absolute';
            this.el.style.left = this.model._dom_left.value + 'px';
            this.el.style.top = this.model._dom_top.value + 'px';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        }
    };
    LayoutDOMView.prototype.get_height = function () {
        return null;
    };
    LayoutDOMView.prototype.get_width = function () {
        return null;
    };
    return LayoutDOMView;
}(dom_view_1.DOMView);
exports.LayoutDOM = function (superClass) {
    extend1(LayoutDOM, superClass);
    function LayoutDOM() {
        return LayoutDOM.__super__.constructor.apply(this, arguments);
    }
    LayoutDOM.prototype.type = 'LayoutDOM';
    LayoutDOM.prototype.initialize = function (attrs, options) {
        LayoutDOM.__super__.initialize.call(this, attrs, options);
        this._width = new solver_1.Variable(this.toString() + '.width');
        this._height = new solver_1.Variable(this.toString() + '.height');
        this._left = new solver_1.Variable(this.toString() + '.left');
        this._right = new solver_1.Variable(this.toString() + '.right');
        this._top = new solver_1.Variable(this.toString() + '.top');
        this._bottom = new solver_1.Variable(this.toString() + '.bottom');
        this._dom_top = new solver_1.Variable(this.toString() + '.dom_top');
        this._dom_left = new solver_1.Variable(this.toString() + '.dom_left');
        this._width_minus_right = new solver_1.Variable(this.toString() + '.width_minus_right');
        this._height_minus_bottom = new solver_1.Variable(this.toString() + '.height_minus_bottom');
        this._whitespace_top = new solver_1.Variable(this.toString() + '.whitespace_top');
        this._whitespace_bottom = new solver_1.Variable(this.toString() + '.whitespace_bottom');
        this._whitespace_left = new solver_1.Variable(this.toString() + '.whitespace_left');
        return this._whitespace_right = new solver_1.Variable(this.toString() + '.whitespace_right');
    };
    LayoutDOM.getters({
        layout_bbox: function () {
            return {
                top: this._top.value,
                left: this._left.value,
                width: this._width.value,
                height: this._height.value,
                right: this._right.value,
                bottom: this._bottom.value,
                dom_top: this._dom_top.value,
                dom_left: this._dom_left.value
            };
        }
    });
    LayoutDOM.prototype.dump_layout = function () {
        var child, i, len, ref, results;
        console.log(this.toString(), this.layout_bbox);
        ref = this.get_layoutable_children();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            results.push(child.dump_layout());
        }
        return results;
    };
    LayoutDOM.prototype.get_all_constraints = function () {
        var child, constraints, i, len, ref;
        constraints = this.get_constraints();
        ref = this.get_layoutable_children();
        for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child instanceof layout_canvas_1.LayoutCanvas) {
                constraints = constraints.concat(child.get_constraints());
            } else {
                constraints = constraints.concat(child.get_all_constraints());
            }
        }
        return constraints;
    };
    LayoutDOM.prototype.get_all_editables = function () {
        var child, editables, i, len, ref;
        editables = this.get_editables();
        ref = this.get_layoutable_children();
        for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child instanceof layout_canvas_1.LayoutCanvas) {
                editables = editables.concat(child.get_editables());
            } else {
                editables = editables.concat(child.get_all_editables());
            }
        }
        return editables;
    };
    LayoutDOM.prototype.get_constraints = function () {
        return [
            solver_1.GE(this._dom_left),
            solver_1.GE(this._dom_top),
            solver_1.GE(this._left),
            solver_1.GE(this._width, [
                -1,
                this._right
            ]),
            solver_1.GE(this._top),
            solver_1.GE(this._height, [
                -1,
                this._bottom
            ]),
            solver_1.EQ(this._width_minus_right, [
                -1,
                this._width
            ], this._right),
            solver_1.EQ(this._height_minus_bottom, [
                -1,
                this._height
            ], this._bottom)
        ];
    };
    LayoutDOM.prototype.get_layoutable_children = function () {
        return [];
    };
    LayoutDOM.prototype.get_editables = function () {
        switch (this.sizing_mode) {
        case 'fixed':
            return [
                this._height,
                this._width
            ];
        case 'scale_width':
            return [this._height];
        case 'scale_height':
            return [this._width];
        default:
            return [];
        }
    };
    LayoutDOM.prototype.get_constrained_variables = function () {
        var vars;
        vars = {
            origin_x: this._dom_left,
            origin_y: this._dom_top,
            whitespace_top: this._whitespace_top,
            whitespace_bottom: this._whitespace_bottom,
            whitespace_left: this._whitespace_left,
            whitespace_right: this._whitespace_right
        };
        switch (this.sizing_mode) {
        case 'stretch_both':
            vars.width = this._width;
            vars.height = this._height;
            break;
        case 'scale_width':
            vars.width = this._width;
            break;
        case 'scale_height':
            vars.height = this._height;
        }
        return vars;
    };
    LayoutDOM.define({
        height: [p.Number],
        width: [p.Number],
        disabled: [
            p.Bool,
            false
        ],
        sizing_mode: [
            p.SizingMode,
            'fixed'
        ],
        css_classes: [p.Array]
    });
    return LayoutDOM;
}(model_1.Model);    
},
/* models/layouts/row */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var box_1 = require(131    /* ./box */);
exports.RowView = function (superClass) {
    extend(RowView, superClass);
    function RowView() {
        return RowView.__super__.constructor.apply(this, arguments);
    }
    RowView.prototype.className = 'bk-grid-row';
    return RowView;
}(box_1.BoxView);
exports.Row = function (superClass) {
    extend(Row, superClass);
    Row.prototype.type = 'Row';
    Row.prototype.default_view = exports.RowView;
    function Row(attrs, options) {
        Row.__super__.constructor.call(this, attrs, options);
        this._horizontal = true;
    }
    return Row;
}(box_1.Box);    
},
/* models/layouts/spacer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var layout_dom_1 = require(134    /* ./layout_dom */);
var object_1 = require(28    /* core/util/object */);
exports.SpacerView = function (superClass) {
    extend1(SpacerView, superClass);
    function SpacerView() {
        return SpacerView.__super__.constructor.apply(this, arguments);
    }
    SpacerView.prototype.className = 'bk-spacer-box';
    SpacerView.prototype.render = function () {
        SpacerView.__super__.render.call(this);
        if (this.sizing_mode === 'fixed') {
            this.el.style.width = this.model.width + 'px';
            return this.el.style.height = this.model.height + 'px';
        }
    };
    SpacerView.prototype.get_height = function () {
        return 1;
    };
    return SpacerView;
}(layout_dom_1.LayoutDOMView);
exports.Spacer = function (superClass) {
    extend1(Spacer, superClass);
    function Spacer() {
        return Spacer.__super__.constructor.apply(this, arguments);
    }
    Spacer.prototype.type = 'Spacer';
    Spacer.prototype.default_view = exports.SpacerView;
    Spacer.prototype.get_constrained_variables = function () {
        return object_1.extend({}, Spacer.__super__.get_constrained_variables.call(this), {
            on_edge_align_top: this._top,
            on_edge_align_bottom: this._height_minus_bottom,
            on_edge_align_left: this._left,
            on_edge_align_right: this._width_minus_right,
            box_cell_align_top: this._top,
            box_cell_align_bottom: this._height_minus_bottom,
            box_cell_align_left: this._left,
            box_cell_align_right: this._width_minus_right,
            box_equal_size_top: this._top,
            box_equal_size_bottom: this._height_minus_bottom,
            box_equal_size_left: this._left,
            box_equal_size_right: this._width_minus_right
        });
    };
    return Spacer;
}(layout_dom_1.LayoutDOM);    
},
/* models/layouts/widget_box */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
var layout_dom_1 = require(134    /* ../layouts/layout_dom */);
exports.WidgetBoxView = function (superClass) {
    extend1(WidgetBoxView, superClass);
    function WidgetBoxView() {
        return WidgetBoxView.__super__.constructor.apply(this, arguments);
    }
    WidgetBoxView.prototype.className = 'bk-widget-box';
    WidgetBoxView.prototype.connect_signals = function () {
        WidgetBoxView.__super__.connect_signals.call(this);
        return this.connect(this.model.properties.children.change, function (_this) {
            return function () {
                return _this.rebuild_child_views();
            };
        }(this));
    };
    WidgetBoxView.prototype.render = function () {
        var css_width, height, width;
        this._render_classes();
        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_height') {
            width = this.get_width();
            if (this.model._width.value !== width) {
                this.solver.suggest_value(this.model._width, width);
            }
        }
        if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_width') {
            height = this.get_height();
            if (this.model._height.value !== height) {
                this.solver.suggest_value(this.model._height, height);
            }
        }
        this.solver.update_variables();
        if (this.model.sizing_mode === 'stretch_both') {
            this.el.style.position = 'absolute';
            this.el.style.left = this.model._dom_left.value + 'px';
            this.el.style.top = this.model._dom_top.value + 'px';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        } else {
            if (this.model._width.value - 20 > 0) {
                css_width = this.model._width.value - 20 + 'px';
            } else {
                css_width = '100%';
            }
            return this.el.style.width = css_width;
        }
    };
    WidgetBoxView.prototype.get_height = function () {
        var child_view, height, key, ref;
        height = 0;
        ref = this.child_views;
        for (key in ref) {
            if (!hasProp.call(ref, key))
                continue;
            child_view = ref[key];
            height += child_view.el.scrollHeight;
        }
        return height + 20;
    };
    WidgetBoxView.prototype.get_width = function () {
        var child_view, child_width, key, ref, width;
        if (this.model.width != null) {
            return this.model.width;
        } else {
            width = this.el.scrollWidth + 20;
            ref = this.child_views;
            for (key in ref) {
                if (!hasProp.call(ref, key))
                    continue;
                child_view = ref[key];
                child_width = child_view.el.scrollWidth;
                if (child_width > width) {
                    width = child_width;
                }
            }
            return width;
        }
    };
    return WidgetBoxView;
}(layout_dom_1.LayoutDOMView);
exports.WidgetBox = function (superClass) {
    extend1(WidgetBox, superClass);
    function WidgetBox() {
        return WidgetBox.__super__.constructor.apply(this, arguments);
    }
    WidgetBox.prototype.type = 'WidgetBox';
    WidgetBox.prototype.default_view = exports.WidgetBoxView;
    WidgetBox.prototype.initialize = function (options) {
        WidgetBox.__super__.initialize.call(this, options);
        if (this.sizing_mode === 'fixed' && this.width === null) {
            this.width = 300;
            logging_1.logger.info('WidgetBox mode is fixed, but no width specified. Using default of 300.');
        }
        if (this.sizing_mode === 'scale_height') {
            return logging_1.logger.warn('sizing_mode `scale_height` is not experimental for WidgetBox. Please report your results to the bokeh dev team so we can improve.');
        }
    };
    WidgetBox.prototype.get_constrained_variables = function () {
        var vars;
        vars = object_1.extend({}, WidgetBox.__super__.get_constrained_variables.call(this), {
            on_edge_align_top: this._top,
            on_edge_align_bottom: this._height_minus_bottom,
            on_edge_align_left: this._left,
            on_edge_align_right: this._width_minus_right,
            box_cell_align_top: this._top,
            box_cell_align_bottom: this._height_minus_bottom,
            box_cell_align_left: this._left,
            box_cell_align_right: this._width_minus_right,
            box_equal_size_top: this._top,
            box_equal_size_bottom: this._height_minus_bottom
        });
        if (this.sizing_mode !== 'fixed') {
            vars.box_equal_size_left = this._left;
            vars.box_equal_size_right = this._width_minus_right;
        }
        return vars;
    };
    WidgetBox.prototype.get_layoutable_children = function () {
        return this.children;
    };
    WidgetBox.define({
        children: [
            p.Array,
            []
        ]
    });
    return WidgetBox;
}(layout_dom_1.LayoutDOM);    
},
/* models/mappers/categorical_color_mapper */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _equals, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var color_mapper_1 = require(139    /* ./color_mapper */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
_equals = function (a, b) {
    var i, j, ref;
    if (a.length !== b.length) {
        return false;
    }
    for (i = j = 0, ref = a.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};
exports.CategoricalColorMapper = function (superClass) {
    extend(CategoricalColorMapper, superClass);
    function CategoricalColorMapper() {
        return CategoricalColorMapper.__super__.constructor.apply(this, arguments);
    }
    CategoricalColorMapper.prototype.type = 'CategoricalColorMapper';
    CategoricalColorMapper.define({
        factors: [p.Array],
        start: [
            p.Number,
            0
        ],
        end: [p.Number]
    });
    CategoricalColorMapper.prototype._get_values = function (data, palette) {
        var color, d, j, key, len, values;
        values = [];
        for (j = 0, len = data.length; j < len; j++) {
            d = data[j];
            if (types_1.isString(d)) {
                key = this.factors.indexOf(d);
            } else {
                if (this.start != null) {
                    if (this.end != null) {
                        d = d.slice(this.start, this.end);
                    } else {
                        d = d.slice(this.start);
                    }
                } else if (this.end != null) {
                    d = d.slice(0, this.end);
                }
                if (d.length === 1) {
                    key = this.factors.indexOf(d[0]);
                } else {
                    key = array_1.findIndex(this.factors, function (x) {
                        return _equals(x, d);
                    });
                }
            }
            if (key < 0 || key >= palette.length) {
                color = this.nan_color;
            } else {
                color = palette[key];
            }
            values.push(color);
        }
        return values;
    };
    return CategoricalColorMapper;
}(color_mapper_1.ColorMapper);    
},
/* models/mappers/color_mapper */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var transform_1 = require(238    /* ../transforms/transform */);
var types_1 = require(40    /* core/util/types */);
exports.ColorMapper = function (superClass) {
    extend(ColorMapper, superClass);
    function ColorMapper() {
        return ColorMapper.__super__.constructor.apply(this, arguments);
    }
    ColorMapper.prototype.type = 'ColorMapper';
    ColorMapper.define({
        palette: [p.Any],
        nan_color: [
            p.Color,
            'gray'
        ]
    });
    ColorMapper.prototype.initialize = function (attrs, options) {
        ColorMapper.__super__.initialize.call(this, attrs, options);
        this._little_endian = this._is_little_endian();
        this._palette = this._build_palette(this.palette);
        return this.connect(this.change, function () {
            return this._palette = this._build_palette(this.palette);
        });
    };
    ColorMapper.prototype.v_map_screen = function (data, image_glyph) {
        var buf, color, i, ind, j, k, ref, ref1, value, values;
        if (image_glyph == null) {
            image_glyph = false;
        }
        values = this._get_values(data, this._palette, image_glyph);
        buf = new ArrayBuffer(data.length * 4);
        if (this._little_endian) {
            color = new Uint8Array(buf);
            for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                value = values[i];
                ind = i * 4;
                color[ind] = Math.floor(value / 4278190080 * 255);
                color[ind + 1] = (value & 16711680) >> 16;
                color[ind + 2] = (value & 65280) >> 8;
                color[ind + 3] = value & 255;
            }
        } else {
            color = new Uint32Array(buf);
            for (i = k = 0, ref1 = data.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                value = values[i];
                color[i] = value << 8 | 255;
            }
        }
        return buf;
    };
    ColorMapper.prototype.compute = function (x) {
        return null;
    };
    ColorMapper.prototype.v_compute = function (xs) {
        var values;
        values = this._get_values(xs, this.palette);
        return values;
    };
    ColorMapper.prototype._get_values = function (data, palette, image_glyph) {
        if (image_glyph == null) {
            image_glyph = false;
        }
        return [];
    };
    ColorMapper.prototype._is_little_endian = function () {
        var buf, buf32, buf8, little_endian;
        buf = new ArrayBuffer(4);
        buf8 = new Uint8Array(buf);
        buf32 = new Uint32Array(buf);
        buf32[1] = 168496141;
        little_endian = true;
        if (buf8[4] === 10 && buf8[5] === 11 && buf8[6] === 12 && buf8[7] === 13) {
            little_endian = false;
        }
        return little_endian;
    };
    ColorMapper.prototype._build_palette = function (palette) {
        var _convert, i, j, new_palette, ref;
        new_palette = new Uint32Array(palette.length);
        _convert = function (value) {
            if (types_1.isNumber(value)) {
                return value;
            } else {
                if (value.length !== 9) {
                    value = value + 'ff';
                }
                return parseInt(value.slice(1), 16);
            }
        };
        for (i = j = 0, ref = palette.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            new_palette[i] = _convert(palette[i]);
        }
        return new_palette;
    };
    return ColorMapper;
}(transform_1.Transform);    
},
/* models/mappers/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var categorical_color_mapper_1 = require(138    /* ./categorical_color_mapper */);
exports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;
var color_mapper_1 = require(139    /* ./color_mapper */);
exports.ColorMapper = color_mapper_1.ColorMapper;
var linear_color_mapper_1 = require(141    /* ./linear_color_mapper */);
exports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;
var log_color_mapper_1 = require(142    /* ./log_color_mapper */);
exports.LogColorMapper = log_color_mapper_1.LogColorMapper;    
},
/* models/mappers/linear_color_mapper */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var color_1 = require(24    /* core/util/color */);
var array_1 = require(20    /* core/util/array */);
var color_mapper_1 = require(139    /* ./color_mapper */);
exports.LinearColorMapper = function (superClass) {
    extend(LinearColorMapper, superClass);
    function LinearColorMapper() {
        return LinearColorMapper.__super__.constructor.apply(this, arguments);
    }
    LinearColorMapper.prototype.type = 'LinearColorMapper';
    LinearColorMapper.define({
        high: [p.Number],
        low: [p.Number],
        high_color: [p.Color],
        low_color: [p.Color]
    });
    LinearColorMapper.prototype.initialize = function (attrs, options) {
        LinearColorMapper.__super__.initialize.call(this, attrs, options);
        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];
        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;
        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;
    };
    LinearColorMapper.prototype._get_values = function (data, palette, image_glyph) {
        var d, high, high_color, i, key, len, low, low_color, max_key, nan_color, norm_factor, normed_d, normed_interval, ref, ref1, values;
        if (image_glyph == null) {
            image_glyph = false;
        }
        low = (ref = this.low) != null ? ref : array_1.min(data);
        high = (ref1 = this.high) != null ? ref1 : array_1.max(data);
        max_key = palette.length - 1;
        values = [];
        nan_color = image_glyph ? this._nan_color : this.nan_color;
        low_color = image_glyph ? this._low_color : this.low_color;
        high_color = image_glyph ? this._high_color : this.high_color;
        norm_factor = 1 / (high - low);
        normed_interval = 1 / palette.length;
        for (i = 0, len = data.length; i < len; i++) {
            d = data[i];
            if (isNaN(d)) {
                values.push(nan_color);
                continue;
            }
            if (d === high) {
                values.push(palette[max_key]);
                continue;
            }
            normed_d = (d - low) * norm_factor;
            key = Math.floor(normed_d / normed_interval);
            if (key < 0) {
                if (this.low_color != null) {
                    values.push(low_color);
                } else {
                    values.push(palette[0]);
                }
            } else if (key > max_key) {
                if (this.high_color != null) {
                    values.push(high_color);
                } else {
                    values.push(palette[max_key]);
                }
            } else {
                values.push(palette[key]);
            }
        }
        return values;
    };
    return LinearColorMapper;
}(color_mapper_1.ColorMapper);    
},
/* models/mappers/log_color_mapper */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var log1p, ref, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var color_1 = require(24    /* core/util/color */);
var array_1 = require(20    /* core/util/array */);
var color_mapper_1 = require(139    /* ./color_mapper */);
log1p = (ref = Math.log1p) != null ? ref : function (x) {
    return Math.log(1 + x);
};
exports.LogColorMapper = function (superClass) {
    extend(LogColorMapper, superClass);
    function LogColorMapper() {
        return LogColorMapper.__super__.constructor.apply(this, arguments);
    }
    LogColorMapper.prototype.type = 'LogColorMapper';
    LogColorMapper.define({
        high: [p.Number],
        low: [p.Number],
        high_color: [p.Color],
        low_color: [p.Color]
    });
    LogColorMapper.prototype.initialize = function (attrs, options) {
        LogColorMapper.__super__.initialize.call(this, attrs, options);
        this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];
        this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;
        return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;
    };
    LogColorMapper.prototype._get_values = function (data, palette, image_glyph) {
        var d, high, high_color, i, key, len, log, low, low_color, max_key, n, nan_color, ref1, ref2, scale, values;
        if (image_glyph == null) {
            image_glyph = false;
        }
        n = palette.length;
        low = (ref1 = this.low) != null ? ref1 : array_1.min(data);
        high = (ref2 = this.high) != null ? ref2 : array_1.max(data);
        scale = n / (log1p(high) - log1p(low));
        max_key = palette.length - 1;
        values = [];
        nan_color = image_glyph ? this._nan_color : this.nan_color;
        high_color = image_glyph ? this._high_color : this.high_color;
        low_color = image_glyph ? this._low_color : this.low_color;
        for (i = 0, len = data.length; i < len; i++) {
            d = data[i];
            if (isNaN(d)) {
                values.push(nan_color);
                continue;
            }
            if (d > high) {
                if (this.high_color != null) {
                    values.push(high_color);
                } else {
                    values.push(palette[max_key]);
                }
                continue;
            }
            if (d === high) {
                values.push(palette[max_key]);
                continue;
            }
            if (d < low) {
                if (this.low_color != null) {
                    values.push(low_color);
                } else {
                    values.push(palette[0]);
                }
                continue;
            }
            log = log1p(d) - log1p(low);
            key = Math.floor(log * scale);
            if (key > max_key) {
                key = max_key;
            }
            values.push(palette[key]);
        }
        return values;
    };
    return LogColorMapper;
}(color_mapper_1.ColorMapper);    
},
/* models/markers/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var SQ3, _mk_model, _one_cross, _one_diamond, _one_tri, _one_x, asterisk, circle_cross, circle_x, cross, diamond, diamond_cross, inverted_triangle, square, square_cross, square_x, triangle, x, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var marker_1 = require(144    /* ./marker */);
SQ3 = Math.sqrt(3);
_one_x = function (ctx, r) {
    ctx.moveTo(-r, r);
    ctx.lineTo(r, -r);
    ctx.moveTo(-r, -r);
    return ctx.lineTo(r, r);
};
_one_cross = function (ctx, r) {
    ctx.moveTo(0, r);
    ctx.lineTo(0, -r);
    ctx.moveTo(-r, 0);
    return ctx.lineTo(r, 0);
};
_one_diamond = function (ctx, r) {
    ctx.moveTo(0, r);
    ctx.lineTo(r / 1.5, 0);
    ctx.lineTo(0, -r);
    ctx.lineTo(-r / 1.5, 0);
    return ctx.closePath();
};
_one_tri = function (ctx, r) {
    var a, h;
    h = r * SQ3;
    a = h / 3;
    ctx.moveTo(-r, a);
    ctx.lineTo(r, a);
    ctx.lineTo(0, a - h);
    return ctx.closePath();
};
asterisk = function (ctx, i, sx, sy, r, line, fill) {
    var r2;
    r2 = r * 0.65;
    _one_cross(ctx, r);
    _one_x(ctx, r2);
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
circle_cross = function (ctx, i, sx, sy, r, line, fill) {
    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        _one_cross(ctx, r);
        ctx.stroke();
    }
};
circle_x = function (ctx, i, sx, sy, r, line, fill) {
    ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        _one_x(ctx, r);
        ctx.stroke();
    }
};
cross = function (ctx, i, sx, sy, r, line, fill) {
    _one_cross(ctx, r);
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
diamond = function (ctx, i, sx, sy, r, line, fill) {
    _one_diamond(ctx, r);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
diamond_cross = function (ctx, i, sx, sy, r, line, fill) {
    _one_diamond(ctx, r);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        _one_cross(ctx, r);
        ctx.stroke();
    }
};
inverted_triangle = function (ctx, i, sx, sy, r, line, fill) {
    ctx.rotate(Math.PI);
    _one_tri(ctx, r);
    ctx.rotate(-Math.PI);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
square = function (ctx, i, sx, sy, r, line, fill) {
    var size;
    size = 2 * r;
    ctx.rect(-r, -r, size, size);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
square_cross = function (ctx, i, sx, sy, r, line, fill) {
    var size;
    size = 2 * r;
    ctx.rect(-r, -r, size, size);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        _one_cross(ctx, r);
        ctx.stroke();
    }
};
square_x = function (ctx, i, sx, sy, r, line, fill) {
    var size;
    size = 2 * r;
    ctx.rect(-r, -r, size, size);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        _one_x(ctx, r);
        ctx.stroke();
    }
};
triangle = function (ctx, i, sx, sy, r, line, fill) {
    _one_tri(ctx, r);
    if (fill.doit) {
        fill.set_vectorize(ctx, i);
        ctx.fill();
    }
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
x = function (ctx, i, sx, sy, r, line, fill) {
    _one_x(ctx, r);
    if (line.doit) {
        line.set_vectorize(ctx, i);
        ctx.stroke();
    }
};
_mk_model = function (type, f) {
    var model, view;
    view = function (superClass) {
        extend(view, superClass);
        function view() {
            return view.__super__.constructor.apply(this, arguments);
        }
        view.prototype._render_one = f;
        return view;
    }(marker_1.MarkerView);
    model = function (superClass) {
        extend(model, superClass);
        function model() {
            return model.__super__.constructor.apply(this, arguments);
        }
        model.prototype.default_view = view;
        model.prototype.type = type;
        return model;
    }(marker_1.Marker);
    return model;
};
exports.Asterisk = _mk_model('Asterisk', asterisk);
exports.CircleCross = _mk_model('CircleCross', circle_cross);
exports.CircleX = _mk_model('CircleX', circle_x);
exports.Cross = _mk_model('Cross', cross);
exports.Diamond = _mk_model('Diamond', diamond);
exports.DiamondCross = _mk_model('DiamondCross', diamond_cross);
exports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle);
exports.Square = _mk_model('Square', square);
exports.SquareCross = _mk_model('SquareCross', square_cross);
exports.SquareX = _mk_model('SquareX', square_x);
exports.Triangle = _mk_model('Triangle', triangle);
exports.X = _mk_model('X', x);    
},
/* models/markers/marker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var xy_glyph_1 = require(123    /* ../glyphs/xy_glyph */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
exports.MarkerView = function (superClass) {
    extend(MarkerView, superClass);
    function MarkerView() {
        return MarkerView.__super__.constructor.apply(this, arguments);
    }
    MarkerView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
        var angle, data, indices, size, sx, sy;
        indices = [index];
        sx = {};
        sx[index] = (x0 + x1) / 2;
        sy = {};
        sy[index] = (y0 + y1) / 2;
        size = {};
        size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
        angle = {};
        angle[index] = this._angle[index];
        data = {
            sx: sx,
            sy: sy,
            _size: size,
            _angle: angle
        };
        return this._render(ctx, indices, data);
    };
    MarkerView.prototype._render = function (ctx, indices, arg) {
        var _angle, _size, i, j, len, r, results, sx, sy;
        sx = arg.sx, sy = arg.sy, _size = arg._size, _angle = arg._angle;
        results = [];
        for (j = 0, len = indices.length; j < len; j++) {
            i = indices[j];
            if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i])) {
                continue;
            }
            r = _size[i] / 2;
            ctx.beginPath();
            ctx.translate(sx[i], sy[i]);
            if (_angle[i]) {
                ctx.rotate(_angle[i]);
            }
            this._render_one(ctx, i, sx[i], sy[i], r, this.visuals.line, this.visuals.fill);
            if (_angle[i]) {
                ctx.rotate(-_angle[i]);
            }
            results.push(ctx.translate(-sx[i], -sy[i]));
        }
        return results;
    };
    MarkerView.prototype._mask_data = function (all_indices) {
        var bbox, hr, ref, ref1, vr, vx0, vx1, vy0, vy1, x0, x1, y0, y1;
        hr = this.renderer.plot_view.frame.h_range;
        vx0 = hr.start - this.max_size;
        vx1 = hr.end + this.max_size;
        ref = this.renderer.xscale.v_invert([
            vx0,
            vx1
        ]), x0 = ref[0], x1 = ref[1];
        vr = this.renderer.plot_view.frame.v_range;
        vy0 = vr.start - this.max_size;
        vy1 = vr.end + this.max_size;
        ref1 = this.renderer.yscale.v_invert([
            vy0,
            vy1
        ]), y0 = ref1[0], y1 = ref1[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        return this.index.indices(bbox);
    };
    MarkerView.prototype._hit_point = function (geometry) {
        var bbox, candidates, dist, hits, i, j, len, ref, ref1, ref2, s2, sx, sy, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
        vx0 = vx - this.max_size;
        vx1 = vx + this.max_size;
        ref1 = this.renderer.xscale.v_invert([
            vx0,
            vx1
        ]), x0 = ref1[0], x1 = ref1[1];
        vy0 = vy - this.max_size;
        vy1 = vy + this.max_size;
        ref2 = this.renderer.yscale.v_invert([
            vy0,
            vy1
        ]), y0 = ref2[0], y1 = ref2[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        candidates = this.index.indices(bbox);
        hits = [];
        for (j = 0, len = candidates.length; j < len; j++) {
            i = candidates[j];
            s2 = this._size[i] / 2;
            dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);
            if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {
                hits.push([
                    i,
                    dist
                ]);
            }
        }
        return hittest.create_1d_hit_test_result(hits);
    };
    MarkerView.prototype._hit_span = function (geometry) {
        var bbox, hits, maxX, maxY, minX, minY, ms, ref, ref1, ref2, ref3, result, vx, vx0, vx1, vy, vy0, vy1, x0, x1, y0, y1;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        ref1 = this.bounds(), minX = ref1.minX, minY = ref1.minY, maxX = ref1.maxX, maxY = ref1.maxY;
        result = hittest.create_hit_test_result();
        if (geometry.direction === 'h') {
            y0 = minY;
            y1 = maxY;
            ms = this.max_size / 2;
            vx0 = vx - ms;
            vx1 = vx + ms;
            ref2 = this.renderer.xscale.v_invert([
                vx0,
                vx1
            ]), x0 = ref2[0], x1 = ref2[1];
        } else {
            x0 = minX;
            x1 = maxX;
            ms = this.max_size / 2;
            vy0 = vy - ms;
            vy1 = vy + ms;
            ref3 = this.renderer.yscale.v_invert([
                vy0,
                vy1
            ]), y0 = ref3[0], y1 = ref3[1];
        }
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        hits = this.index.indices(bbox);
        result['1d'].indices = hits;
        return result;
    };
    MarkerView.prototype._hit_rect = function (geometry) {
        var bbox, ref, ref1, result, x0, x1, y0, y1;
        ref = this.renderer.xscale.v_invert([
            geometry.vx0,
            geometry.vx1
        ]), x0 = ref[0], x1 = ref[1];
        ref1 = this.renderer.yscale.v_invert([
            geometry.vy0,
            geometry.vy1
        ]), y0 = ref1[0], y1 = ref1[1];
        bbox = hittest.validate_bbox_coords([
            x0,
            x1
        ], [
            y0,
            y1
        ]);
        result = hittest.create_hit_test_result();
        result['1d'].indices = this.index.indices(bbox);
        return result;
    };
    MarkerView.prototype._hit_poly = function (geometry) {
        var candidates, hits, i, idx, j, k, ref, ref1, ref2, result, results, sx, sy, vx, vy;
        ref = [
            geometry.vx,
            geometry.vy
        ], vx = ref[0], vy = ref[1];
        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);
        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);
        candidates = function () {
            results = [];
            for (var j = 0, ref1 = this.sx.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {
                results.push(j);
            }
            return results;
        }.apply(this);
        hits = [];
        for (i = k = 0, ref2 = candidates.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
            idx = candidates[i];
            if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                hits.push(idx);
            }
        }
        result = hittest.create_hit_test_result();
        result['1d'].indices = hits;
        return result;
    };
    return MarkerView;
}(xy_glyph_1.XYGlyphView);
exports.Marker = function (superClass) {
    extend(Marker, superClass);
    function Marker() {
        return Marker.__super__.constructor.apply(this, arguments);
    }
    Marker.mixins([
        'line',
        'fill'
    ]);
    Marker.define({
        size: [
            p.DistanceSpec,
            {
                units: 'screen',
                value: 4
            }
        ],
        angle: [
            p.AngleSpec,
            0
        ]
    });
    return Marker;
}(xy_glyph_1.XYGlyph);    
},
/* models/plots/gmap_plot */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var logging_1 = require(12    /* core/logging */);
var gmap_plot_canvas_1 = require(146    /* ./gmap_plot_canvas */);
var plot_1 = require(148    /* ./plot */);
var p = require(13    /* core/properties */);
var model_1 = require(48    /* ../../model */);
exports.MapOptions = function (superClass) {
    extend(MapOptions, superClass);
    function MapOptions() {
        return MapOptions.__super__.constructor.apply(this, arguments);
    }
    MapOptions.prototype.type = 'MapOptions';
    MapOptions.define({
        lat: [p.Number],
        lng: [p.Number],
        zoom: [
            p.Number,
            12
        ]
    });
    return MapOptions;
}(model_1.Model);
exports.GMapOptions = function (superClass) {
    extend(GMapOptions, superClass);
    function GMapOptions() {
        return GMapOptions.__super__.constructor.apply(this, arguments);
    }
    GMapOptions.prototype.type = 'GMapOptions';
    GMapOptions.define({
        map_type: [
            p.String,
            'roadmap'
        ],
        scale_control: [
            p.Bool,
            false
        ],
        styles: [p.String]
    });
    return GMapOptions;
}(exports.MapOptions);
exports.GMapPlotView = function (superClass) {
    extend(GMapPlotView, superClass);
    function GMapPlotView() {
        return GMapPlotView.__super__.constructor.apply(this, arguments);
    }
    return GMapPlotView;
}(plot_1.PlotView);
exports.GMapPlot = function (superClass) {
    extend(GMapPlot, superClass);
    function GMapPlot() {
        return GMapPlot.__super__.constructor.apply(this, arguments);
    }
    GMapPlot.prototype.type = 'GMapPlot';
    GMapPlot.prototype.default_view = exports.GMapPlotView;
    GMapPlot.prototype.initialize = function (options) {
        GMapPlot.__super__.initialize.call(this, options);
        if (!this.api_key) {
            return logging_1.logger.error('api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.');
        }
    };
    GMapPlot.prototype._init_plot_canvas = function () {
        return new gmap_plot_canvas_1.GMapPlotCanvas({ plot: this });
    };
    GMapPlot.define({
        map_options: [p.Instance],
        api_key: [p.String]
    });
    return GMapPlot;
}(plot_1.Plot);    
},
/* models/plots/gmap_plot_canvas */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var gmaps_ready, load_google_api, bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    }, extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var proj4_1 = require(29    /* core/util/proj4 */);
var plot_canvas_1 = require(149    /* ./plot_canvas */);
var signaling_1 = require(18    /* core/signaling */);
gmaps_ready = new signaling_1.Signal(this, 'gmaps_ready');
load_google_api = function (api_key) {
    var script;
    window._bokeh_gmaps_callback = function () {
        return gmaps_ready.emit();
    };
    script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = 'https://maps.googleapis.com/maps/api/js?key=' + api_key + '&callback=_bokeh_gmaps_callback';
    return document.body.appendChild(script);
};
exports.GMapPlotCanvasView = function (superClass) {
    extend1(GMapPlotCanvasView, superClass);
    function GMapPlotCanvasView() {
        this._set_bokeh_ranges = bind(this._set_bokeh_ranges, this);
        this._get_projected_bounds = bind(this._get_projected_bounds, this);
        this._get_latlon_bounds = bind(this._get_latlon_bounds, this);
        return GMapPlotCanvasView.__super__.constructor.apply(this, arguments);
    }
    GMapPlotCanvasView.prototype.initialize = function (options) {
        var mo, ref;
        this.pause();
        GMapPlotCanvasView.__super__.initialize.call(this, options);
        this._tiles_loaded = false;
        this.zoom_count = 0;
        mo = this.model.plot.map_options;
        this.initial_zoom = mo.zoom;
        this.initial_lat = mo.lat;
        this.initial_lng = mo.lng;
        this.canvas_view.map_el.style.position = 'absolute';
        if (((ref = window.google) != null ? ref.maps : void 0) == null) {
            if (window._bokeh_gmaps_callback == null) {
                load_google_api(this.model.plot.api_key);
            }
            gmaps_ready.connect(function (_this) {
                return function () {
                    return _this.request_render();
                };
            }(this));
        }
        return this.unpause();
    };
    GMapPlotCanvasView.prototype.update_range = function (range_info) {
        var mo, new_map_zoom, old_map_zoom, proj_xend, proj_xstart, proj_yend, proj_ystart, ref, zoom_change;
        if (range_info == null) {
            mo = this.model.plot.map_options;
            this.map.setCenter({
                lat: this.initial_lat,
                lng: this.initial_lng
            });
            this.map.setOptions({ zoom: this.initial_zoom });
            GMapPlotCanvasView.__super__.update_range.call(this, null);
        } else if (range_info.sdx != null || range_info.sdy != null) {
            this.map.panBy(range_info.sdx, range_info.sdy);
            GMapPlotCanvasView.__super__.update_range.call(this, range_info);
        } else if (range_info.factor != null) {
            if (this.zoom_count !== 10) {
                this.zoom_count += 1;
                return;
            }
            this.zoom_count = 0;
            this.pause();
            GMapPlotCanvasView.__super__.update_range.call(this, range_info);
            if (range_info.factor < 0) {
                zoom_change = -1;
            } else {
                zoom_change = 1;
            }
            old_map_zoom = this.map.getZoom();
            new_map_zoom = old_map_zoom + zoom_change;
            if (new_map_zoom >= 2) {
                this.map.setZoom(new_map_zoom);
                ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];
                if (proj_xend - proj_xstart < 0) {
                    this.map.setZoom(old_map_zoom);
                }
            }
            this.unpause();
        }
        return this._set_bokeh_ranges();
    };
    GMapPlotCanvasView.prototype._build_map = function () {
        var map_options, maps, mo;
        maps = window.google.maps;
        this.map_types = {
            satellite: maps.MapTypeId.SATELLITE,
            terrain: maps.MapTypeId.TERRAIN,
            roadmap: maps.MapTypeId.ROADMAP,
            hybrid: maps.MapTypeId.HYBRID
        };
        mo = this.model.plot.map_options;
        map_options = {
            center: new maps.LatLng(mo.lat, mo.lng),
            zoom: mo.zoom,
            disableDefaultUI: true,
            mapTypeId: this.map_types[mo.map_type],
            scaleControl: mo.scale_control
        };
        if (mo.styles != null) {
            map_options.styles = JSON.parse(mo.styles);
        }
        this.map = new maps.Map(this.canvas_view.map_el, map_options);
        maps.event.addListener(this.map, 'idle', function (_this) {
            return function () {
                return _this._set_bokeh_ranges();
            };
        }(this));
        maps.event.addListener(this.map, 'bounds_changed', function (_this) {
            return function () {
                return _this._set_bokeh_ranges();
            };
        }(this));
        maps.event.addListenerOnce(this.map, 'tilesloaded', function (_this) {
            return function () {
                return _this._render_finished();
            };
        }(this));
        this.connect(this.model.plot.properties.map_options.change, function (_this) {
            return function () {
                return _this._update_options();
            };
        }(this));
        this.connect(this.model.plot.map_options.properties.styles.change, function (_this) {
            return function () {
                return _this._update_styles();
            };
        }(this));
        this.connect(this.model.plot.map_options.properties.lat.change, function (_this) {
            return function () {
                return _this._update_center('lat');
            };
        }(this));
        this.connect(this.model.plot.map_options.properties.lng.change, function (_this) {
            return function () {
                return _this._update_center('lng');
            };
        }(this));
        this.connect(this.model.plot.map_options.properties.zoom.change, function (_this) {
            return function () {
                return _this._update_zoom();
            };
        }(this));
        this.connect(this.model.plot.map_options.properties.map_type.change, function (_this) {
            return function () {
                return _this._update_map_type();
            };
        }(this));
        return this.connect(this.model.plot.map_options.properties.scale_control.change, function (_this) {
            return function () {
                return _this._update_scale_control();
            };
        }(this));
    };
    GMapPlotCanvasView.prototype._render_finished = function () {
        this._tiles_loaded = true;
        return this.notify_finished();
    };
    GMapPlotCanvasView.prototype.has_finished = function () {
        return GMapPlotCanvasView.__super__.has_finished.call(this) && this._tiles_loaded === true;
    };
    GMapPlotCanvasView.prototype._get_latlon_bounds = function () {
        var bottom_left, bounds, top_right, xend, xstart, yend, ystart;
        bounds = this.map.getBounds();
        top_right = bounds.getNorthEast();
        bottom_left = bounds.getSouthWest();
        xstart = bottom_left.lng();
        xend = top_right.lng();
        ystart = bottom_left.lat();
        yend = top_right.lat();
        return [
            xstart,
            xend,
            ystart,
            yend
        ];
    };
    GMapPlotCanvasView.prototype._get_projected_bounds = function () {
        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref, ref1, ref2, xend, xstart, yend, ystart;
        ref = this._get_latlon_bounds(), xstart = ref[0], xend = ref[1], ystart = ref[2], yend = ref[3];
        ref1 = proj4_1.proj4(proj4_1.mercator, [
            xstart,
            ystart
        ]), proj_xstart = ref1[0], proj_ystart = ref1[1];
        ref2 = proj4_1.proj4(proj4_1.mercator, [
            xend,
            yend
        ]), proj_xend = ref2[0], proj_yend = ref2[1];
        return [
            proj_xstart,
            proj_xend,
            proj_ystart,
            proj_yend
        ];
    };
    GMapPlotCanvasView.prototype._set_bokeh_ranges = function () {
        var proj_xend, proj_xstart, proj_yend, proj_ystart, ref;
        ref = this._get_projected_bounds(), proj_xstart = ref[0], proj_xend = ref[1], proj_ystart = ref[2], proj_yend = ref[3];
        this.frame.x_range.setv({
            start: proj_xstart,
            end: proj_xend
        });
        return this.frame.y_range.setv({
            start: proj_ystart,
            end: proj_yend
        });
    };
    GMapPlotCanvasView.prototype._update_center = function (fld) {
        var c;
        c = this.map.getCenter().toJSON();
        c[fld] = this.model.plot.map_options[fld];
        this.map.setCenter(c);
        return this._set_bokeh_ranges();
    };
    GMapPlotCanvasView.prototype._update_map_type = function () {
        var maps;
        maps = window.google.maps;
        return this.map.setOptions({ mapTypeId: this.map_types[this.model.plot.map_options.map_type] });
    };
    GMapPlotCanvasView.prototype._update_scale_control = function () {
        var maps;
        maps = window.google.maps;
        return this.map.setOptions({ scaleControl: this.model.plot.map_options.scale_control });
    };
    GMapPlotCanvasView.prototype._update_options = function () {
        this._update_styles();
        this._update_center('lat');
        this._update_center('lng');
        this._update_zoom();
        return this._update_map_type();
    };
    GMapPlotCanvasView.prototype._update_styles = function () {
        return this.map.setOptions({ styles: JSON.parse(this.model.plot.map_options.styles) });
    };
    GMapPlotCanvasView.prototype._update_zoom = function () {
        this.map.setOptions({ zoom: this.model.plot.map_options.zoom });
        return this._set_bokeh_ranges();
    };
    GMapPlotCanvasView.prototype._map_hook = function (ctx, frame_box) {
        var height, left, ref, top, width;
        left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];
        this.canvas_view.map_el.style.top = top + 'px';
        this.canvas_view.map_el.style.left = left + 'px';
        this.canvas_view.map_el.style.width = width + 'px';
        this.canvas_view.map_el.style.height = height + 'px';
        if (this.map == null && ((ref = window.google) != null ? ref.maps : void 0) != null) {
            return this._build_map();
        }
    };
    GMapPlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {
        var ih, iw, left, oh, ow, top;
        ow = this.canvas._width.value;
        oh = this.canvas._height.value;
        left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];
        ctx.clearRect(0, 0, ow, oh);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, oh);
        ctx.lineTo(ow, oh);
        ctx.lineTo(ow, 0);
        ctx.lineTo(0, 0);
        ctx.moveTo(left, top);
        ctx.lineTo(left + iw, top);
        ctx.lineTo(left + iw, top + ih);
        ctx.lineTo(left, top + ih);
        ctx.lineTo(left, top);
        ctx.closePath();
        ctx.fillStyle = this.model.plot.border_fill_color;
        return ctx.fill();
    };
    return GMapPlotCanvasView;
}(plot_canvas_1.PlotCanvasView);
exports.GMapPlotCanvas = function (superClass) {
    extend1(GMapPlotCanvas, superClass);
    function GMapPlotCanvas() {
        return GMapPlotCanvas.__super__.constructor.apply(this, arguments);
    }
    GMapPlotCanvas.prototype.type = 'GMapPlotCanvas';
    GMapPlotCanvas.prototype.default_view = exports.GMapPlotCanvasView;
    GMapPlotCanvas.prototype.initialize = function (attrs, options) {
        this.use_map = true;
        return GMapPlotCanvas.__super__.initialize.call(this, attrs, options);
    };
    return GMapPlotCanvas;
}(plot_canvas_1.PlotCanvas);    
},
/* models/plots/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var gmap_plot_1 = require(145    /* ./gmap_plot */);
exports.MapOptions = gmap_plot_1.MapOptions;
var gmap_plot_2 = require(145    /* ./gmap_plot */);
exports.GMapOptions = gmap_plot_2.GMapOptions;
var gmap_plot_3 = require(145    /* ./gmap_plot */);
exports.GMapPlot = gmap_plot_3.GMapPlot;
var gmap_plot_canvas_1 = require(146    /* ./gmap_plot_canvas */);
exports.GMapPlotCanvas = gmap_plot_canvas_1.GMapPlotCanvas;
var plot_1 = require(148    /* ./plot */);
exports.Plot = plot_1.Plot;
var plot_canvas_1 = require(149    /* ./plot_canvas */);
exports.PlotCanvas = plot_canvas_1.PlotCanvas;    
},
/* models/plots/plot */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var solver_1 = require(11    /* core/layout/solver */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
var types_1 = require(40    /* core/util/types */);
var layout_dom_1 = require(134    /* ../layouts/layout_dom */);
var title_1 = require(63    /* ../annotations/title */);
var linear_scale_1 = require(163    /* ../scales/linear_scale */);
var toolbar_1 = require(228    /* ../tools/toolbar */);
var plot_canvas_1 = require(149    /* ./plot_canvas */);
var column_data_source_1 = require(168    /* ../sources/column_data_source */);
var glyph_renderer_1 = require(156    /* ../renderers/glyph_renderer */);
var bokeh_events_1 = require(2    /* core/bokeh_events */);
exports.PlotView = function (superClass) {
    extend1(PlotView, superClass);
    function PlotView() {
        return PlotView.__super__.constructor.apply(this, arguments);
    }
    PlotView.prototype.className = 'bk-plot-layout';
    PlotView.prototype.connect_signals = function () {
        var title_msg;
        PlotView.__super__.connect_signals.call(this);
        title_msg = 'Title object cannot be replaced. Try changing properties on title to update it after initialization.';
        return this.connect(this.model.properties.title.change, function (_this) {
            return function () {
                return logging_1.logger.warn(title_msg);
            };
        }(this));
    };
    PlotView.prototype.render = function () {
        var height, ref, width;
        PlotView.__super__.render.call(this);
        if (this.model.sizing_mode === 'scale_both') {
            ref = this.get_width_height(), width = ref[0], height = ref[1];
            this.solver.suggest_value(this.model._width, width);
            this.solver.suggest_value(this.model._height, height);
            this.solver.update_variables();
            this.el.style.position = 'absolute';
            this.el.style.left = this.model._dom_left.value + 'px';
            this.el.style.top = this.model._dom_top.value + 'px';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        }
    };
    PlotView.prototype.get_width_height = function () {
        var ar, height, new_height_1, new_height_2, new_width_1, new_width_2, parent_height, parent_width, width;
        parent_height = this.el.parentNode.clientHeight;
        parent_width = this.el.parentNode.clientWidth;
        ar = this.model.get_aspect_ratio();
        new_width_1 = parent_width;
        new_height_1 = parent_width / ar;
        new_width_2 = parent_height * ar;
        new_height_2 = parent_height;
        if (new_width_1 < new_width_2) {
            width = new_width_1;
            height = new_height_1;
        } else {
            width = new_width_2;
            height = new_height_2;
        }
        return [
            width,
            height
        ];
    };
    PlotView.prototype.get_height = function () {
        return this.model._width.value / this.model.get_aspect_ratio();
    };
    PlotView.prototype.get_width = function () {
        return this.model._height.value * this.model.get_aspect_ratio();
    };
    PlotView.prototype.save = function (name) {
        return this.plot_canvas_view.save(name);
    };
    PlotView.getters({
        plot_canvas_view: function () {
            var view;
            return function () {
                var i, len, ref, results;
                ref = object_1.values(this.child_views);
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    view = ref[i];
                    if (view instanceof plot_canvas_1.PlotCanvasView) {
                        results.push(view);
                    }
                }
                return results;
            }.call(this)[0];
        }
    });
    return PlotView;
}(layout_dom_1.LayoutDOMView);
exports.Plot = function (superClass) {
    extend1(Plot, superClass);
    function Plot() {
        return Plot.__super__.constructor.apply(this, arguments);
    }
    Plot.prototype.type = 'Plot';
    Plot.prototype.default_view = exports.PlotView;
    Plot.prototype.initialize = function (options) {
        var _set_sizeable, i, j, k, l, layout_renderers, len, len1, len2, len3, plots, ref, ref1, ref2, ref3, renderer, side, title, xr, yr;
        Plot.__super__.initialize.call(this, options);
        ref = object_1.values(this.extra_x_ranges).concat(this.x_range);
        for (i = 0, len = ref.length; i < len; i++) {
            xr = ref[i];
            plots = xr.plots;
            if (types_1.isArray(plots)) {
                plots = plots.concat(this);
                xr.setv('plots', plots, { silent: true });
            }
        }
        ref1 = object_1.values(this.extra_y_ranges).concat(this.y_range);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
            yr = ref1[j];
            plots = yr.plots;
            if (types_1.isArray(plots)) {
                plots = plots.concat(this);
                yr.setv('plots', plots, { silent: true });
            }
        }
        this._horizontal = (ref2 = this.toolbar_location) === 'left' || ref2 === 'right';
        if (this.min_border != null) {
            if (this.min_border_top == null) {
                this.min_border_top = this.min_border;
            }
            if (this.min_border_bottom == null) {
                this.min_border_bottom = this.min_border;
            }
            if (this.min_border_left == null) {
                this.min_border_left = this.min_border;
            }
            if (this.min_border_right == null) {
                this.min_border_right = this.min_border;
            }
        }
        if (this.title != null) {
            title = types_1.isString(this.title) ? new title_1.Title({ text: this.title }) : this.title;
            this.add_layout(title, this.title_location);
        }
        this._plot_canvas = this._init_plot_canvas();
        this.toolbar.toolbar_location = this.toolbar_location;
        this.toolbar.toolbar_sticky = this.toolbar_sticky;
        this.plot_canvas.toolbar = this.toolbar;
        if (this.width == null) {
            this.width = this.plot_width;
        }
        if (this.height == null) {
            this.height = this.plot_height;
        }
        ref3 = [
            'above',
            'below',
            'left',
            'right'
        ];
        for (k = 0, len2 = ref3.length; k < len2; k++) {
            side = ref3[k];
            layout_renderers = this.getv(side);
            for (l = 0, len3 = layout_renderers.length; l < len3; l++) {
                renderer = layout_renderers[l];
                renderer.add_panel(side);
            }
        }
        _set_sizeable = function (_this) {
            return function (model) {
                return model._sizeable = !_this._horizontal ? model._height : model._width;
            };
        }(this);
        _set_sizeable(this);
        return _set_sizeable(this.plot_canvas);
    };
    Plot.prototype._init_plot_canvas = function () {
        return new plot_canvas_1.PlotCanvas({ plot: this });
    };
    Plot.getters({
        plot_canvas: function () {
            return this._plot_canvas;
        }
    });
    Plot.prototype._doc_attached = function () {
        this.plot_canvas.attach_document(this.document);
        return Plot.__super__._doc_attached.call(this);
    };
    Plot.prototype.add_renderers = function () {
        var new_renderers, renderers;
        new_renderers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        renderers = this.renderers;
        renderers = renderers.concat(new_renderers);
        return this.renderers = renderers;
    };
    Plot.prototype.add_layout = function (renderer, side) {
        var side_renderers;
        if (side == null) {
            side = 'center';
        }
        if (renderer.props.plot != null) {
            renderer.plot = this;
        }
        if (side !== 'center') {
            side_renderers = this.getv(side);
            side_renderers.push(renderer);
            renderer.add_panel(side);
        }
        return this.add_renderers(renderer);
    };
    Plot.prototype.add_glyph = function (glyph, source, attrs) {
        var renderer;
        if (attrs == null) {
            attrs = {};
        }
        if (source == null) {
            source = new column_data_source_1.ColumnDataSource();
        }
        attrs = object_1.extend({}, attrs, {
            data_source: source,
            glyph: glyph
        });
        renderer = new glyph_renderer_1.GlyphRenderer(attrs);
        this.add_renderers(renderer);
        return renderer;
    };
    Plot.prototype.add_tools = function () {
        var i, len, tool, tools;
        tools = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        for (i = 0, len = tools.length; i < len; i++) {
            tool = tools[i];
            if (tool.overlay != null) {
                this.add_renderers(tool.overlay);
            }
        }
        return this.toolbar.tools = this.toolbar.tools.concat(tools);
    };
    Plot.prototype.get_aspect_ratio = function () {
        return this.width / this.height;
    };
    Plot.prototype.get_layoutable_children = function () {
        var children;
        children = [this.plot_canvas];
        if (this.toolbar_location != null) {
            children = [
                this.toolbar,
                this.plot_canvas
            ];
        }
        return children;
    };
    Plot.prototype.get_editables = function () {
        var editables;
        editables = Plot.__super__.get_editables.call(this);
        if (this.sizing_mode === 'scale_both') {
            editables = editables.concat([
                this._width,
                this._height
            ]);
        }
        return editables;
    };
    Plot.prototype.get_constraints = function () {
        var constraints, ref, ref1, sticky_edge;
        constraints = Plot.__super__.get_constraints.call(this);
        if (this.toolbar_location != null) {
            if (this.toolbar_sticky) {
                constraints.push(solver_1.EQ(this._sizeable, [
                    -1,
                    this.plot_canvas._sizeable
                ]));
            } else {
                constraints.push(solver_1.EQ(this._sizeable, [
                    -1,
                    this.plot_canvas._sizeable
                ], [
                    -1,
                    this.toolbar._sizeable
                ]));
            }
            if (!this._horizontal) {
                constraints.push(solver_1.EQ(this._width, [
                    -1,
                    this.plot_canvas._width
                ]));
            } else {
                constraints.push(solver_1.EQ(this._height, [
                    -1,
                    this.plot_canvas._height
                ]));
            }
            if (this.toolbar_location === 'above') {
                sticky_edge = this.toolbar_sticky ? this.plot_canvas._top : this.plot_canvas._dom_top;
                constraints.push(solver_1.EQ(sticky_edge, [
                    -1,
                    this.toolbar._dom_top
                ], [
                    -1,
                    this.toolbar._height
                ]));
            }
            if (this.toolbar_location === 'below') {
                if (!this.toolbar_sticky) {
                    constraints.push(solver_1.EQ(this.toolbar._dom_top, [
                        -1,
                        this.plot_canvas._height
                    ], this.toolbar._bottom, [
                        -1,
                        this.toolbar._height
                    ]));
                } else {
                    constraints.push(solver_1.GE(this.plot_canvas.below_panel._height, [
                        -1,
                        this.toolbar._height
                    ]));
                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_top, [
                        -1,
                        this.plot_canvas._height
                    ], this.plot_canvas.below_panel._height));
                }
            }
            if (this.toolbar_location === 'left') {
                sticky_edge = this.toolbar_sticky ? this.plot_canvas._left : this.plot_canvas._dom_left;
                constraints.push(solver_1.EQ(sticky_edge, [
                    -1,
                    this.toolbar._dom_left
                ], [
                    -1,
                    this.toolbar._width
                ]));
            }
            if (this.toolbar_location === 'right') {
                if (!this.toolbar_sticky) {
                    constraints.push(solver_1.EQ(this.toolbar._dom_left, [
                        -1,
                        this.plot_canvas._width
                    ], this.toolbar._right, [
                        -1,
                        this.toolbar._width
                    ]));
                } else {
                    constraints.push(solver_1.GE(this.plot_canvas.right_panel._width, [
                        -1,
                        this.toolbar._width
                    ]));
                    constraints.push(solver_1.WEAK_EQ(this.toolbar._dom_left, [
                        -1,
                        this.plot_canvas._width
                    ], this.plot_canvas.right_panel._width));
                }
            }
            if ((ref = this.toolbar_location) === 'above' || ref === 'below') {
                constraints.push(solver_1.EQ(this._width, [
                    -1,
                    this.toolbar._width
                ], [
                    -1,
                    this.plot_canvas._width_minus_right
                ]));
            }
            if ((ref1 = this.toolbar_location) === 'left' || ref1 === 'right') {
                constraints.push(solver_1.EQ(this._height, [
                    -1,
                    this.toolbar._height
                ], [
                    -1,
                    this.plot_canvas.above_panel._height
                ]));
                constraints.push(solver_1.EQ(this.toolbar._dom_top, [
                    -1,
                    this.plot_canvas.above_panel._height
                ]));
            }
        }
        if (this.toolbar_location == null) {
            constraints.push(solver_1.EQ(this._width, [
                -1,
                this.plot_canvas._width
            ]));
            constraints.push(solver_1.EQ(this._height, [
                -1,
                this.plot_canvas._height
            ]));
        }
        return constraints;
    };
    Plot.prototype.get_constrained_variables = function () {
        var vars;
        vars = object_1.extend({}, Plot.__super__.get_constrained_variables.call(this), {
            on_edge_align_top: this.plot_canvas._top,
            on_edge_align_bottom: this.plot_canvas._height_minus_bottom,
            on_edge_align_left: this.plot_canvas._left,
            on_edge_align_right: this.plot_canvas._width_minus_right,
            box_cell_align_top: this.plot_canvas._top,
            box_cell_align_bottom: this.plot_canvas._height_minus_bottom,
            box_cell_align_left: this.plot_canvas._left,
            box_cell_align_right: this.plot_canvas._width_minus_right,
            box_equal_size_top: this.plot_canvas._top,
            box_equal_size_bottom: this.plot_canvas._height_minus_bottom
        });
        if (this.sizing_mode !== 'fixed') {
            vars.box_equal_size_left = this.plot_canvas._left;
            vars.box_equal_size_right = this.plot_canvas._width_minus_right;
        }
        return vars;
    };
    Plot.mixins([
        'line:outline_',
        'fill:background_',
        'fill:border_'
    ]);
    Plot.define({
        toolbar: [
            p.Instance,
            function () {
                return new toolbar_1.Toolbar();
            }
        ],
        toolbar_location: [
            p.Location,
            'right'
        ],
        toolbar_sticky: [
            p.Bool,
            true
        ],
        plot_width: [
            p.Number,
            600
        ],
        plot_height: [
            p.Number,
            600
        ],
        title: [
            p.Any,
            function () {
                return new title_1.Title({ text: '' });
            }
        ],
        title_location: [
            p.Location,
            'above'
        ],
        h_symmetry: [
            p.Bool,
            true
        ],
        v_symmetry: [
            p.Bool,
            false
        ],
        above: [
            p.Array,
            []
        ],
        below: [
            p.Array,
            []
        ],
        left: [
            p.Array,
            []
        ],
        right: [
            p.Array,
            []
        ],
        renderers: [
            p.Array,
            []
        ],
        x_range: [p.Instance],
        extra_x_ranges: [
            p.Any,
            {}
        ],
        y_range: [p.Instance],
        extra_y_ranges: [
            p.Any,
            {}
        ],
        x_scale: [
            p.Instance,
            function () {
                return new linear_scale_1.LinearScale();
            }
        ],
        y_scale: [
            p.Instance,
            function () {
                return new linear_scale_1.LinearScale();
            }
        ],
        lod_factor: [
            p.Number,
            10
        ],
        lod_interval: [
            p.Number,
            300
        ],
        lod_threshold: [
            p.Number,
            2000
        ],
        lod_timeout: [
            p.Number,
            500
        ],
        hidpi: [
            p.Bool,
            true
        ],
        output_backend: [
            p.OutputBackend,
            'canvas'
        ],
        min_border: [
            p.Number,
            5
        ],
        min_border_top: [
            p.Number,
            null
        ],
        min_border_left: [
            p.Number,
            null
        ],
        min_border_bottom: [
            p.Number,
            null
        ],
        min_border_right: [
            p.Number,
            null
        ],
        inner_width: [p.Number],
        inner_height: [p.Number],
        layout_width: [p.Number],
        layout_height: [p.Number],
        match_aspect: [
            p.Bool,
            false
        ],
        aspect_scale: [
            p.Number,
            1
        ]
    });
    Plot.override({
        outline_line_color: '#e5e5e5',
        border_fill_color: '#ffffff',
        background_fill_color: '#ffffff'
    });
    Plot.getters({
        all_renderers: function () {
            var i, len, ref, renderers, tool;
            renderers = this.renderers;
            ref = this.toolbar.tools;
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                renderers = renderers.concat(tool.synthetic_renderers);
            }
            return renderers;
        },
        x_mapper_type: function () {
            log.warning('x_mapper_type attr is deprecated, use x_scale');
            return this.x_scale;
        },
        y_mapper_type: function () {
            log.warning('y_mapper_type attr is deprecated, use y_scale');
            return this.y_scale;
        },
        webgl: function () {
            log.warning('webgl attr is deprecated, use output_backend');
            return this.output_backend === 'webgl';
        },
        tool_events: function () {
            log.warning('tool_events attr is deprecated, use SelectionGeometry Event');
            return null;
        }
    });
    return Plot;
}(layout_dom_1.LayoutDOM);
bokeh_events_1.register_with_event(bokeh_events_1.UIEvent, exports.Plot);    
},
/* models/plots/plot_canvas */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var AbovePanel, BelowPanel, LeftPanel, RightPanel, global_glcanvas, extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var canvas_1 = require(76    /* ../canvas/canvas */);
var cartesian_frame_1 = require(77    /* ../canvas/cartesian_frame */);
var data_range1d_1 = require(151    /* ../ranges/data_range1d */);
var glyph_renderer_1 = require(156    /* ../renderers/glyph_renderer */);
var layout_dom_1 = require(134    /* ../layouts/layout_dom */);
var signaling_1 = require(18    /* core/signaling */);
var build_views_1 = require(3    /* core/build_views */);
var ui_events_1 = require(19    /* core/ui_events */);
var bokeh_events_1 = require(2    /* core/bokeh_events */);
var layout_canvas_1 = require(9    /* core/layout/layout_canvas */);
var visuals_1 = require(44    /* core/visuals */);
var dom_view_1 = require(5    /* core/dom_view */);
var solver_1 = require(11    /* core/layout/solver */);
var logging_1 = require(12    /* core/logging */);
var enums = require(6    /* core/enums */);
var p = require(13    /* core/properties */);
var throttle_1 = require(39    /* core/util/throttle */);
var types_1 = require(40    /* core/util/types */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
var side_panel_1 = require(10    /* core/layout/side_panel */);
global_glcanvas = null;
exports.PlotCanvasView = function (superClass) {
    extend1(PlotCanvasView, superClass);
    function PlotCanvasView() {
        return PlotCanvasView.__super__.constructor.apply(this, arguments);
    }
    PlotCanvasView.prototype.className = 'bk-plot-wrapper';
    PlotCanvasView.prototype.state = {
        history: [],
        index: -1
    };
    PlotCanvasView.prototype.view_options = function () {
        return object_1.extend({
            plot_view: this,
            parent: this
        }, this.options);
    };
    PlotCanvasView.prototype.pause = function () {
        if (this._is_paused == null) {
            return this._is_paused = 1;
        } else {
            return this._is_paused += 1;
        }
    };
    PlotCanvasView.prototype.unpause = function (no_render) {
        if (no_render == null) {
            no_render = false;
        }
        this._is_paused -= 1;
        if (this._is_paused === 0 && !no_render) {
            return this.request_render();
        }
    };
    PlotCanvasView.prototype.request_render = function () {
        return this.request_paint();
    };
    PlotCanvasView.prototype.request_paint = function () {
        if (!this.is_paused) {
            this.throttled_paint();
        }
    };
    PlotCanvasView.prototype.remove = function () {
        build_views_1.remove_views(this.renderer_views);
        build_views_1.remove_views(this.tool_views);
        this.canvas_view.remove();
        this.canvas_view = null;
        return PlotCanvasView.__super__.remove.call(this);
    };
    PlotCanvasView.prototype.initialize = function (options) {
        var j, len, level, ref;
        this.pause();
        PlotCanvasView.__super__.initialize.call(this, options);
        this.force_paint = new signaling_1.Signal(this, 'force_paint');
        this.state_changed = new signaling_1.Signal(this, 'state_changed');
        this.lod_started = false;
        this.visuals = new visuals_1.Visuals(this.model.plot);
        this._initial_state_info = {
            range: null,
            selection: {},
            dimensions: {
                width: this.model.canvas._width.value,
                height: this.model.canvas._height.value
            }
        };
        this.frame = this.model.frame;
        this.canvas = this.model.canvas;
        this.canvas_view = new this.canvas.default_view({
            model: this.canvas,
            parent: this
        });
        this.el.appendChild(this.canvas_view.el);
        this.canvas_view.render();
        if (this.model.plot.output_backend === 'webgl') {
            this.init_webgl();
        }
        this.throttled_paint = throttle_1.throttle(function (_this) {
            return function () {
                return _this.force_paint.emit();
            };
        }(this), 15);
        this.ui_event_bus = new ui_events_1.UIEvents(this, this.model.toolbar, this.canvas_view.el, this.model.plot);
        this.levels = {};
        ref = enums.RenderLevel;
        for (j = 0, len = ref.length; j < len; j++) {
            level = ref[j];
            this.levels[level] = {};
        }
        this.renderer_views = {};
        this.tool_views = {};
        this.build_levels();
        this.build_tools();
        this.connect_signals();
        this.update_dataranges();
        this.unpause(true);
        logging_1.logger.debug('PlotView initialized');
        return this;
    };
    PlotCanvasView.prototype.set_cursor = function (cursor) {
        if (cursor == null) {
            cursor = 'default';
        }
        return this.canvas_view.el.style.cursor = cursor;
    };
    PlotCanvasView.getters({
        canvas_overlays: function () {
            return this.canvas_view.overlays_el;
        },
        is_paused: function () {
            return this._is_paused != null && this._is_paused !== 0;
        }
    });
    PlotCanvasView.prototype.init_webgl = function () {
        var ctx, glcanvas, opts;
        ctx = this.canvas_view.ctx;
        glcanvas = global_glcanvas;
        if (glcanvas == null) {
            global_glcanvas = glcanvas = document.createElement('canvas');
            opts = { 'premultipliedAlpha': true };
            glcanvas.gl = glcanvas.getContext('webgl', opts) || glcanvas.getContext('experimental-webgl', opts);
        }
        if (glcanvas.gl != null) {
            return ctx.glcanvas = glcanvas;
        } else {
            return logging_1.logger.warn('WebGL is not supported, falling back to 2D canvas.');
        }
    };
    PlotCanvasView.prototype.prepare_webgl = function (ratio, frame_box) {
        var canvas, ctx, flipped_top, gl;
        ctx = this.canvas_view.ctx;
        canvas = this.canvas_view.get_canvas_element();
        if (ctx.glcanvas) {
            ctx.glcanvas.width = canvas.width;
            ctx.glcanvas.height = canvas.height;
            gl = ctx.glcanvas.gl;
            gl.viewport(0, 0, ctx.glcanvas.width, ctx.glcanvas.height);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.SCISSOR_TEST);
            flipped_top = ctx.glcanvas.height - ratio * (frame_box[1] + frame_box[3]);
            gl.scissor(ratio * frame_box[0], flipped_top, ratio * frame_box[2], ratio * frame_box[3]);
            gl.enable(gl.BLEND);
            return gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE);
        }
    };
    PlotCanvasView.prototype.blit_webgl = function (ratio) {
        var ctx;
        ctx = this.canvas_view.ctx;
        if (ctx.glcanvas) {
            logging_1.logger.debug('drawing with WebGL');
            ctx.restore();
            ctx.drawImage(ctx.glcanvas, 0, 0);
            ctx.save();
            ctx.scale(ratio, ratio);
            return ctx.translate(0.5, 0.5);
        }
    };
    PlotCanvasView.prototype.update_dataranges = function () {
        var bds, bounds, bounds_to_use, calculate_log_bounds, follow_enabled, frame, has_bounds, height, j, k, l, len, len1, len2, len3, len4, log_bds, log_bounds, m, n, o, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, v, width, xcenter, xr, ycenter, yr;
        frame = this.model.frame;
        bounds = {};
        log_bounds = {};
        calculate_log_bounds = false;
        ref = object_1.values(frame.x_ranges).concat(object_1.values(frame.y_ranges));
        for (j = 0, len = ref.length; j < len; j++) {
            r = ref[j];
            if (r instanceof data_range1d_1.DataRange1d) {
                if (r.scale_hint === 'log') {
                    calculate_log_bounds = true;
                }
            }
        }
        ref1 = this.renderer_views;
        for (k in ref1) {
            v = ref1[k];
            bds = (ref2 = v.glyph) != null ? typeof ref2.bounds === 'function' ? ref2.bounds() : void 0 : void 0;
            if (bds != null) {
                bounds[k] = bds;
            }
            if (calculate_log_bounds) {
                log_bds = (ref3 = v.glyph) != null ? typeof ref3.log_bounds === 'function' ? ref3.log_bounds() : void 0 : void 0;
                if (log_bds != null) {
                    log_bounds[k] = log_bds;
                }
            }
        }
        follow_enabled = false;
        has_bounds = false;
        if (this.model.plot.match_aspect !== false && this.frame._width.value !== 0 && this.frame._height.value !== 0) {
            r = 1 / this.model.plot.aspect_scale * (this.frame._width.value / this.frame._height.value);
            for (k in bounds) {
                v = bounds[k];
                width = v.maxX - v.minX;
                if (width <= 0) {
                    width = 1;
                }
                height = v.maxY - v.minY;
                if (height <= 0) {
                    height = 1;
                }
                xcenter = 0.5 * (v.maxX + v.minX);
                ycenter = 0.5 * (v.maxY + v.minY);
                if (width < r * height) {
                    width = r * height;
                } else {
                    height = width / r;
                }
                bounds[k].maxX = xcenter + 0.5 * width;
                bounds[k].minX = xcenter - 0.5 * width;
                bounds[k].maxY = ycenter + 0.5 * height;
                bounds[k].minY = ycenter - 0.5 * height;
            }
        }
        ref4 = object_1.values(frame.x_ranges);
        for (l = 0, len1 = ref4.length; l < len1; l++) {
            xr = ref4[l];
            if (xr instanceof data_range1d_1.DataRange1d) {
                bounds_to_use = xr.scale_hint === 'log' ? log_bounds : bounds;
                xr.update(bounds_to_use, 0, this.model.id);
                if (xr.follow) {
                    follow_enabled = true;
                }
            }
            if (xr.bounds != null) {
                has_bounds = true;
            }
        }
        ref5 = object_1.values(frame.y_ranges);
        for (m = 0, len2 = ref5.length; m < len2; m++) {
            yr = ref5[m];
            if (yr instanceof data_range1d_1.DataRange1d) {
                bounds_to_use = yr.scale_hint === 'log' ? log_bounds : bounds;
                yr.update(bounds_to_use, 1, this.model.id);
                if (yr.follow) {
                    follow_enabled = true;
                }
            }
            if (yr.bounds != null) {
                has_bounds = true;
            }
        }
        if (follow_enabled && has_bounds) {
            logging_1.logger.warn('Follow enabled so bounds are unset.');
            ref6 = object_1.values(frame.x_ranges);
            for (n = 0, len3 = ref6.length; n < len3; n++) {
                xr = ref6[n];
                xr.bounds = null;
            }
            ref7 = object_1.values(frame.y_ranges);
            for (o = 0, len4 = ref7.length; o < len4; o++) {
                yr = ref7[o];
                yr.bounds = null;
            }
        }
        return this.range_update_timestamp = Date.now();
    };
    PlotCanvasView.prototype.map_to_screen = function (x, y, x_name, y_name) {
        if (x_name == null) {
            x_name = 'default';
        }
        if (y_name == null) {
            y_name = 'default';
        }
        return this.frame.map_to_screen(x, y, this.canvas, x_name, y_name);
    };
    PlotCanvasView.prototype.push_state = function (type, info) {
        var prev_info, ref;
        prev_info = ((ref = this.state.history[this.state.index]) != null ? ref.info : void 0) || {};
        info = object_1.extend({}, this._initial_state_info, prev_info, info);
        this.state.history.slice(0, this.state.index + 1);
        this.state.history.push({
            type: type,
            info: info
        });
        this.state.index = this.state.history.length - 1;
        return this.state_changed.emit();
    };
    PlotCanvasView.prototype.clear_state = function () {
        this.state = {
            history: [],
            index: -1
        };
        return this.state_changed.emit();
    };
    PlotCanvasView.prototype.can_undo = function () {
        return this.state.index >= 0;
    };
    PlotCanvasView.prototype.can_redo = function () {
        return this.state.index < this.state.history.length - 1;
    };
    PlotCanvasView.prototype.undo = function () {
        if (this.can_undo()) {
            this.state.index -= 1;
            this._do_state_change(this.state.index);
            return this.state_changed.emit();
        }
    };
    PlotCanvasView.prototype.redo = function () {
        if (this.can_redo()) {
            this.state.index += 1;
            this._do_state_change(this.state.index);
            return this.state_changed.emit();
        }
    };
    PlotCanvasView.prototype._do_state_change = function (index) {
        var info, ref;
        info = ((ref = this.state.history[index]) != null ? ref.info : void 0) || this._initial_state_info;
        if (info.range != null) {
            this.update_range(info.range);
        }
        if (info.selection != null) {
            this.update_selection(info.selection);
        }
        if (info.dimensions != null) {
            return this.canvas_view.set_dims([
                info.dimensions.width,
                info.dimensions.height
            ]);
        }
    };
    PlotCanvasView.prototype.reset_dimensions = function () {
        return this.update_dimensions(this.canvas.initial_width, this.canvas.initial_height);
    };
    PlotCanvasView.prototype.update_dimensions = function (width, height) {
        this.pause();
        this.model.plot.width = width;
        this.model.plot.height = height;
        this.parent.layout();
        return this.unpause();
    };
    PlotCanvasView.prototype.get_selection = function () {
        var j, len, ref, renderer, selected, selection;
        selection = [];
        ref = this.model.plot.renderers;
        for (j = 0, len = ref.length; j < len; j++) {
            renderer = ref[j];
            if (renderer instanceof glyph_renderer_1.GlyphRenderer) {
                selected = renderer.data_source.selected;
                selection[renderer.id] = selected;
            }
        }
        return selection;
    };
    PlotCanvasView.prototype.update_selection = function (selection) {
        var ds, j, len, ref, ref1, renderer, results;
        ref = this.model.plot.renderers;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
            renderer = ref[j];
            if (!(renderer instanceof glyph_renderer_1.GlyphRenderer)) {
                continue;
            }
            ds = renderer.data_source;
            if (selection != null) {
                if (ref1 = renderer.id, indexOf.call(selection, ref1) >= 0) {
                    results.push(ds.selected = selection[renderer.id]);
                } else {
                    results.push(void 0);
                }
            } else {
                results.push(ds.selection_manager.clear());
            }
        }
        return results;
    };
    PlotCanvasView.prototype.reset_selection = function () {
        return this.update_selection(null);
    };
    PlotCanvasView.prototype._update_ranges_together = function (range_info_iter) {
        var j, l, len, len1, range_info, ref, ref1, results, rng, weight;
        weight = 1;
        for (j = 0, len = range_info_iter.length; j < len; j++) {
            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];
            weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));
        }
        if (weight < 1) {
            results = [];
            for (l = 0, len1 = range_info_iter.length; l < len1; l++) {
                ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];
                range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;
                results.push(range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end);
            }
            return results;
        }
    };
    PlotCanvasView.prototype._update_ranges_individually = function (range_info_iter, is_panning, is_scrolling) {
        var hit_bound, j, l, len, len1, max, min, new_interval, range_info, ref, ref1, results, reversed, rng, weight;
        hit_bound = false;
        for (j = 0, len = range_info_iter.length; j < len; j++) {
            ref = range_info_iter[j], rng = ref[0], range_info = ref[1];
            reversed = rng.start > rng.end;
            if (!is_scrolling) {
                weight = this._get_weight_to_constrain_interval(rng, range_info);
                if (weight < 1) {
                    range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;
                    range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end;
                }
            }
            if (rng.bounds != null) {
                min = rng.bounds[0];
                max = rng.bounds[1];
                new_interval = Math.abs(range_info['end'] - range_info['start']);
                if (reversed) {
                    if (min != null) {
                        if (min >= range_info['end']) {
                            hit_bound = true;
                            range_info['end'] = min;
                            if (is_panning != null || is_scrolling != null) {
                                range_info['start'] = min + new_interval;
                            }
                        }
                    }
                    if (max != null) {
                        if (max <= range_info['start']) {
                            hit_bound = true;
                            range_info['start'] = max;
                            if (is_panning != null || is_scrolling != null) {
                                range_info['end'] = max - new_interval;
                            }
                        }
                    }
                } else {
                    if (min != null) {
                        if (min >= range_info['start']) {
                            hit_bound = true;
                            range_info['start'] = min;
                            if (is_panning != null || is_scrolling != null) {
                                range_info['end'] = min + new_interval;
                            }
                        }
                    }
                    if (max != null) {
                        if (max <= range_info['end']) {
                            hit_bound = true;
                            range_info['end'] = max;
                            if (is_panning != null || is_scrolling != null) {
                                range_info['start'] = max - new_interval;
                            }
                        }
                    }
                }
            }
        }
        if (is_scrolling && hit_bound) {
            return;
        }
        results = [];
        for (l = 0, len1 = range_info_iter.length; l < len1; l++) {
            ref1 = range_info_iter[l], rng = ref1[0], range_info = ref1[1];
            rng.have_updated_interactively = true;
            if (rng.start !== range_info['start'] || rng.end !== range_info['end']) {
                results.push(rng.setv(range_info));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    PlotCanvasView.prototype._get_weight_to_constrain_interval = function (rng, range_info) {
        var max, max_interval, max_interval2, min, min_interval, new_interval, old_interval, ref, weight;
        min_interval = rng.min_interval;
        max_interval = rng.max_interval;
        weight = 1;
        if (rng.bounds != null) {
            ref = rng.bounds, min = ref[0], max = ref[1];
            if (min != null && max != null) {
                max_interval2 = Math.abs(max - min);
                max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;
            }
        }
        if (min_interval != null || max_interval != null) {
            old_interval = Math.abs(rng.end - rng.start);
            new_interval = Math.abs(range_info['end'] - range_info['start']);
            if (min_interval > 0 && new_interval < min_interval) {
                weight = (old_interval - min_interval) / (old_interval - new_interval);
            }
            if (max_interval > 0 && new_interval > max_interval) {
                weight = (max_interval - old_interval) / (new_interval - old_interval);
            }
            weight = Math.max(0, Math.min(1, weight));
        }
        return weight;
    };
    PlotCanvasView.prototype.update_range = function (range_info, is_panning, is_scrolling) {
        var name, range_info_iter, ref, ref1, ref2, ref3, rng;
        this.pause();
        if (range_info == null) {
            ref = this.frame.x_ranges;
            for (name in ref) {
                rng = ref[name];
                rng.reset();
            }
            ref1 = this.frame.y_ranges;
            for (name in ref1) {
                rng = ref1[name];
                rng.reset();
            }
            this.update_dataranges();
        } else {
            range_info_iter = [];
            ref2 = this.frame.x_ranges;
            for (name in ref2) {
                rng = ref2[name];
                range_info_iter.push([
                    rng,
                    range_info.xrs[name]
                ]);
            }
            ref3 = this.frame.y_ranges;
            for (name in ref3) {
                rng = ref3[name];
                range_info_iter.push([
                    rng,
                    range_info.yrs[name]
                ]);
            }
            if (is_scrolling) {
                this._update_ranges_together(range_info_iter);
            }
            this._update_ranges_individually(range_info_iter, is_panning, is_scrolling);
        }
        return this.unpause();
    };
    PlotCanvasView.prototype.reset_range = function () {
        return this.update_range(null);
    };
    PlotCanvasView.prototype.build_levels = function () {
        var id_, j, l, len, len1, model, new_renderer_views, old_renderers, renderer_models, renderers_to_remove, view;
        renderer_models = this.model.plot.all_renderers;
        old_renderers = Object.keys(this.renderer_views);
        new_renderer_views = build_views_1.build_views(this.renderer_views, renderer_models, this.view_options());
        renderers_to_remove = array_1.difference(old_renderers, function () {
            var j, len, results;
            results = [];
            for (j = 0, len = renderer_models.length; j < len; j++) {
                model = renderer_models[j];
                results.push(model.id);
            }
            return results;
        }());
        for (j = 0, len = renderers_to_remove.length; j < len; j++) {
            id_ = renderers_to_remove[j];
            delete this.levels.glyph[id_];
        }
        for (l = 0, len1 = new_renderer_views.length; l < len1; l++) {
            view = new_renderer_views[l];
            this.levels[view.model.level][view.model.id] = view;
            view.connect_signals();
        }
        return this;
    };
    PlotCanvasView.prototype.get_renderer_views = function () {
        var j, len, r, ref, results;
        ref = this.model.plot.renderers;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
            r = ref[j];
            results.push(this.levels[r.level][r.id]);
        }
        return results;
    };
    PlotCanvasView.prototype.build_tools = function () {
        var j, len, new_tool_views, results, tool_models, tool_view;
        tool_models = this.model.plot.toolbar.tools;
        new_tool_views = build_views_1.build_views(this.tool_views, tool_models, this.view_options());
        results = [];
        for (j = 0, len = new_tool_views.length; j < len; j++) {
            tool_view = new_tool_views[j];
            tool_view.connect_signals();
            results.push(this.ui_event_bus.register_tool(tool_view));
        }
        return results;
    };
    PlotCanvasView.prototype.connect_signals = function () {
        var name, ref, ref1, rng;
        PlotCanvasView.__super__.connect_signals.call(this);
        this.connect(this.force_paint, function (_this) {
            return function () {
                return _this.paint();
            };
        }(this));
        ref = this.model.frame.x_ranges;
        for (name in ref) {
            rng = ref[name];
            this.connect(rng.change, function () {
                return this.request_render();
            });
        }
        ref1 = this.model.frame.y_ranges;
        for (name in ref1) {
            rng = ref1[name];
            this.connect(rng.change, function () {
                return this.request_render();
            });
        }
        this.connect(this.model.plot.properties.renderers.change, function (_this) {
            return function () {
                return _this.build_levels();
            };
        }(this));
        this.connect(this.model.plot.toolbar.properties.tools.change, function (_this) {
            return function () {
                _this.build_levels();
                return _this.build_tools();
            };
        }(this));
        return this.connect(this.model.plot.change, function () {
            return this.request_render();
        });
    };
    PlotCanvasView.prototype.set_initial_range = function () {
        var good_vals, name, ref, ref1, rng, xrs, yrs;
        good_vals = true;
        xrs = {};
        ref = this.frame.x_ranges;
        for (name in ref) {
            rng = ref[name];
            if (rng.start == null || rng.end == null || types_1.isStrictNaN(rng.start + rng.end)) {
                good_vals = false;
                break;
            }
            xrs[name] = {
                start: rng.start,
                end: rng.end
            };
        }
        if (good_vals) {
            yrs = {};
            ref1 = this.frame.y_ranges;
            for (name in ref1) {
                rng = ref1[name];
                if (rng.start == null || rng.end == null || types_1.isStrictNaN(rng.start + rng.end)) {
                    good_vals = false;
                    break;
                }
                yrs[name] = {
                    start: rng.start,
                    end: rng.end
                };
            }
        }
        if (good_vals) {
            this._initial_state_info.range = this.initial_range_info = {
                xrs: xrs,
                yrs: yrs
            };
            return logging_1.logger.debug('initial ranges set');
        } else {
            return logging_1.logger.warn('could not set initial ranges');
        }
    };
    PlotCanvasView.prototype.update_constraints = function () {
        var _, ref, view;
        this.solver.suggest_value(this.frame._width, this.canvas._width.value);
        this.solver.suggest_value(this.frame._height, this.canvas._height.value);
        ref = this.renderer_views;
        for (_ in ref) {
            view = ref[_];
            if (view.model.panel != null) {
                side_panel_1.update_panel_constraints(view);
            }
        }
        return this.solver.update_variables();
    };
    PlotCanvasView.prototype._layout = function (final) {
        if (final == null) {
            final = false;
        }
        this.render();
        if (final) {
            this.model.plot.setv({
                inner_width: Math.round(this.frame._width.value),
                inner_height: Math.round(this.frame._height.value),
                layout_width: Math.round(this.canvas._width.value),
                layout_height: Math.round(this.canvas._height.value)
            }, { no_change: true });
            return this.request_paint();
        }
    };
    PlotCanvasView.prototype.has_finished = function () {
        var _, ref, renderer_views, view;
        if (!PlotCanvasView.__super__.has_finished.call(this)) {
            return false;
        }
        ref = this.levels;
        for (_ in ref) {
            renderer_views = ref[_];
            for (_ in renderer_views) {
                view = renderer_views[_];
                if (!view.has_finished()) {
                    return false;
                }
            }
        }
        return true;
    };
    PlotCanvasView.prototype.render = function () {
        var height, width;
        width = this.model._width.value;
        height = this.model._height.value;
        this.canvas_view.set_dims([
            width,
            height
        ]);
        this.update_constraints();
        if (this.model.plot.match_aspect !== false && this.frame._width.value !== 0 && this.frame._height.value !== 0) {
            this.update_dataranges();
        }
        this.el.style.position = 'absolute';
        this.el.style.left = this.model._dom_left.value + 'px';
        this.el.style.top = this.model._dom_top.value + 'px';
        this.el.style.width = this.model._width.value + 'px';
        return this.el.style.height = this.model._height.value + 'px';
    };
    PlotCanvasView.prototype.paint = function () {
        var ctx, frame_box, h, k, lod_timeout, ratio, ref, v, w, x0, y0;
        if (this.is_paused) {
            return;
        }
        logging_1.logger.trace('PlotCanvas.render() for ' + this.model.id);
        this.canvas_view.prepare_canvas();
        if (Date.now() - this.interactive_timestamp < this.model.plot.lod_interval) {
            if (!this.lod_started) {
                this.model.plot.trigger_event(new bokeh_events_1.LODStart({}));
                this.lod_started = true;
            }
            this.interactive = true;
            lod_timeout = this.model.plot.lod_timeout;
            setTimeout(function (_this) {
                return function () {
                    if (_this.interactive && Date.now() - _this.interactive_timestamp > lod_timeout) {
                        _this.interactive = false;
                    }
                    return _this.request_render();
                };
            }(this), lod_timeout);
        } else {
            this.interactive = false;
            if (this.lod_started) {
                this.model.plot.trigger_event(new bokeh_events_1.LODEnd({}));
                this.lod_started = false;
            }
        }
        ref = this.renderer_views;
        for (k in ref) {
            v = ref[k];
            if (this.range_update_timestamp == null || v.set_data_timestamp > this.range_update_timestamp) {
                this.update_dataranges();
                break;
            }
        }
        this.model.frame._update_scales();
        ctx = this.canvas_view.ctx;
        ctx.pixel_ratio = ratio = this.canvas.pixel_ratio;
        ctx.save();
        ctx.scale(ratio, ratio);
        ctx.translate(0.5, 0.5);
        frame_box = [
            this.canvas.vx_to_sx(this.frame._left.value),
            this.canvas.vy_to_sy(this.frame._top.value),
            this.frame._width.value,
            this.frame._height.value
        ];
        this._map_hook(ctx, frame_box);
        this._paint_empty(ctx, frame_box);
        this.prepare_webgl(ratio, frame_box);
        ctx.save();
        if (this.visuals.outline_line.doit) {
            this.visuals.outline_line.set_value(ctx);
            x0 = frame_box[0], y0 = frame_box[1], w = frame_box[2], h = frame_box[3];
            if (x0 + w === this.canvas._width.value) {
                w -= 1;
            }
            if (y0 + h === this.canvas._height.value) {
                h -= 1;
            }
            ctx.strokeRect(x0, y0, w, h);
        }
        ctx.restore();
        this._paint_levels(ctx, [
            'image',
            'underlay',
            'glyph'
        ], frame_box);
        this.blit_webgl(ratio);
        this._paint_levels(ctx, ['annotation'], frame_box);
        this._paint_levels(ctx, ['overlay']);
        if (this.initial_range_info == null) {
            this.set_initial_range();
        }
        ctx.restore();
        if (!this._has_finished) {
            this._has_finished = true;
            return this.notify_finished();
        }
    };
    PlotCanvasView.prototype._paint_levels = function (ctx, levels, clip_region) {
        var i, indices, j, l, len, len1, len2, level, m, ref, renderer, renderer_view, renderer_views, sortKey;
        ctx.save();
        if (clip_region != null && this.model.plot.output_backend === 'canvas') {
            ctx.beginPath();
            ctx.rect.apply(ctx, clip_region);
            ctx.clip();
        }
        indices = {};
        ref = this.model.plot.renderers;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
            renderer = ref[i];
            indices[renderer.id] = i;
        }
        sortKey = function (renderer_view) {
            return indices[renderer_view.model.id];
        };
        for (l = 0, len1 = levels.length; l < len1; l++) {
            level = levels[l];
            renderer_views = array_1.sortBy(object_1.values(this.levels[level]), sortKey);
            for (m = 0, len2 = renderer_views.length; m < len2; m++) {
                renderer_view = renderer_views[m];
                renderer_view.render();
            }
        }
        return ctx.restore();
    };
    PlotCanvasView.prototype._map_hook = function (ctx, frame_box) {
    };
    PlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {
        ctx.clearRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);
        if (this.visuals.border_fill.doit) {
            this.visuals.border_fill.set_value(ctx);
            ctx.fillRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);
            ctx.clearRect.apply(ctx, frame_box);
        }
        if (this.visuals.background_fill.doit) {
            this.visuals.background_fill.set_value(ctx);
            return ctx.fillRect.apply(ctx, frame_box);
        }
    };
    PlotCanvasView.prototype.save = function (name) {
        var blob, canvas, downloadLink, link, ref, svg, svgblob;
        if ((ref = this.model.plot.output_backend) === 'canvas' || ref === 'webgl') {
            canvas = this.canvas_view.get_canvas_element();
            if (canvas.msToBlob != null) {
                blob = canvas.msToBlob();
                return window.navigator.msSaveBlob(blob, name);
            } else {
                link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = name + '.png';
                link.target = '_blank';
                return link.dispatchEvent(new MouseEvent('click'));
            }
        } else if (this.model.plot.output_backend === 'svg') {
            svg = this.canvas_view.ctx.getSerializedSvg(true);
            svgblob = new Blob([svg], { type: 'text/plain' });
            downloadLink = document.createElement('a');
            downloadLink.download = name + '.svg';
            downloadLink.innerHTML = 'Download svg';
            downloadLink.href = window.URL.createObjectURL(svgblob);
            downloadLink.onclick = function (event) {
                return document.body.removeChild(event.target);
            };
            downloadLink.style.display = 'none';
            document.body.appendChild(downloadLink);
            return downloadLink.click();
        }
    };
    return PlotCanvasView;
}(dom_view_1.DOMView);
AbovePanel = function (superClass) {
    extend1(AbovePanel, superClass);
    function AbovePanel() {
        return AbovePanel.__super__.constructor.apply(this, arguments);
    }
    AbovePanel.prototype.type = 'AbovePanel';
    return AbovePanel;
}(layout_canvas_1.LayoutCanvas);
BelowPanel = function (superClass) {
    extend1(BelowPanel, superClass);
    function BelowPanel() {
        return BelowPanel.__super__.constructor.apply(this, arguments);
    }
    BelowPanel.prototype.type = 'BelowPanel';
    return BelowPanel;
}(layout_canvas_1.LayoutCanvas);
LeftPanel = function (superClass) {
    extend1(LeftPanel, superClass);
    function LeftPanel() {
        return LeftPanel.__super__.constructor.apply(this, arguments);
    }
    LeftPanel.prototype.type = 'LeftPanel';
    return LeftPanel;
}(layout_canvas_1.LayoutCanvas);
RightPanel = function (superClass) {
    extend1(RightPanel, superClass);
    function RightPanel() {
        return RightPanel.__super__.constructor.apply(this, arguments);
    }
    RightPanel.prototype.type = 'RightPanel';
    return RightPanel;
}(layout_canvas_1.LayoutCanvas);
exports.PlotCanvas = function (superClass) {
    extend1(PlotCanvas, superClass);
    function PlotCanvas() {
        return PlotCanvas.__super__.constructor.apply(this, arguments);
    }
    PlotCanvas.prototype.type = 'PlotCanvas';
    PlotCanvas.prototype.default_view = exports.PlotCanvasView;
    PlotCanvas.prototype.initialize = function (attrs, options) {
        var ref;
        PlotCanvas.__super__.initialize.call(this, attrs, options);
        this.canvas = new canvas_1.Canvas({
            map: (ref = this.use_map) != null ? ref : false,
            initial_width: this.plot.plot_width,
            initial_height: this.plot.plot_height,
            use_hidpi: this.plot.hidpi,
            output_backend: this.plot.output_backend
        });
        this.frame = new cartesian_frame_1.CartesianFrame({
            x_range: this.plot.x_range,
            extra_x_ranges: this.plot.extra_x_ranges,
            x_scale: this.plot.x_scale,
            y_range: this.plot.y_range,
            extra_y_ranges: this.plot.extra_y_ranges,
            y_scale: this.plot.y_scale
        });
        this.above_panel = new AbovePanel();
        this.below_panel = new BelowPanel();
        this.left_panel = new LeftPanel();
        this.right_panel = new RightPanel();
        return logging_1.logger.debug('PlotCanvas initialized');
    };
    PlotCanvas.prototype._doc_attached = function () {
        this.canvas.attach_document(this.document);
        this.frame.attach_document(this.document);
        this.above_panel.attach_document(this.document);
        this.below_panel.attach_document(this.document);
        this.left_panel.attach_document(this.document);
        this.right_panel.attach_document(this.document);
        PlotCanvas.__super__._doc_attached.call(this);
        return logging_1.logger.debug('PlotCanvas attached to document');
    };
    PlotCanvas.override({ sizing_mode: 'stretch_both' });
    PlotCanvas.internal({
        plot: [p.Instance],
        toolbar: [p.Instance],
        canvas: [p.Instance],
        frame: [p.Instance]
    });
    PlotCanvas.prototype.get_layoutable_children = function () {
        var children, collect_panels;
        children = [
            this.above_panel,
            this.below_panel,
            this.left_panel,
            this.right_panel,
            this.canvas,
            this.frame
        ];
        collect_panels = function (layout_renderers) {
            var j, len, r, results;
            results = [];
            for (j = 0, len = layout_renderers.length; j < len; j++) {
                r = layout_renderers[j];
                if (r.panel != null) {
                    results.push(children.push(r.panel));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        collect_panels(this.plot.above);
        collect_panels(this.plot.below);
        collect_panels(this.plot.left);
        collect_panels(this.plot.right);
        return children;
    };
    PlotCanvas.prototype.get_constraints = function () {
        return PlotCanvas.__super__.get_constraints.call(this).concat(this._get_constant_constraints(), this._get_side_constraints());
    };
    PlotCanvas.prototype._get_constant_constraints = function () {
        return [
            solver_1.GE(this.above_panel._height, -this.plot.min_border_top),
            solver_1.GE(this.below_panel._height, -this.plot.min_border_bottom),
            solver_1.GE(this.left_panel._width, -this.plot.min_border_left),
            solver_1.GE(this.right_panel._width, -this.plot.min_border_right),
            solver_1.EQ(this.above_panel._top, [
                -1,
                this.canvas._top
            ]),
            solver_1.EQ(this.above_panel._bottom, [
                -1,
                this.frame._top
            ]),
            solver_1.EQ(this.below_panel._bottom, [
                -1,
                this.canvas._bottom
            ]),
            solver_1.EQ(this.below_panel._top, [
                -1,
                this.frame._bottom
            ]),
            solver_1.EQ(this.left_panel._left, [
                -1,
                this.canvas._left
            ]),
            solver_1.EQ(this.left_panel._right, [
                -1,
                this.frame._left
            ]),
            solver_1.EQ(this.right_panel._right, [
                -1,
                this.canvas._right
            ]),
            solver_1.EQ(this.right_panel._left, [
                -1,
                this.frame._right
            ]),
            solver_1.EQ(this.above_panel._height, [
                -1,
                this._top
            ]),
            solver_1.EQ(this.above_panel._height, [
                -1,
                this.canvas._top
            ], this.frame._top),
            solver_1.EQ(this.below_panel._height, [
                -1,
                this._height
            ], this._bottom),
            solver_1.EQ(this.below_panel._height, [
                -1,
                this.frame._bottom
            ]),
            solver_1.EQ(this.left_panel._width, [
                -1,
                this._left
            ]),
            solver_1.EQ(this.left_panel._width, [
                -1,
                this.frame._left
            ]),
            solver_1.EQ(this.right_panel._width, [
                -1,
                this._width
            ], this._right),
            solver_1.EQ(this.right_panel._width, [
                -1,
                this.canvas._right
            ], this.frame._right)
        ];
    };
    PlotCanvas.prototype._get_side_constraints = function () {
        var above, below, cabove, cbelow, cleft, constraints, cright, left, right;
        above = [this.frame].concat(this.plot.above);
        below = [this.frame].concat(this.plot.below);
        left = [this.frame].concat(this.plot.left);
        right = [this.frame].concat(this.plot.right);
        cabove = array_1.pairwise(above, function (prev, next) {
            return solver_1.EQ(prev.panel._top, [
                -1,
                next.panel._bottom
            ]);
        });
        cbelow = array_1.pairwise(below, function (prev, next) {
            return solver_1.EQ(prev.panel._bottom, [
                -1,
                next.panel._top
            ]);
        });
        cleft = array_1.pairwise(left, function (prev, next) {
            return solver_1.EQ(prev.panel._left, [
                -1,
                next.panel._right
            ]);
        });
        cright = array_1.pairwise(right, function (prev, next) {
            return solver_1.EQ(prev.panel._right, [
                -1,
                next.panel._left
            ]);
        });
        constraints = [].concat(cabove, cbelow, cleft, cright);
        if (this.plot.above.length > 0) {
            constraints.push(solver_1.EQ(array_1.last(this.plot.above).panel._top, [
                -1,
                this.above_panel._top
            ]));
        }
        if (this.plot.below.length > 0) {
            constraints.push(solver_1.EQ(array_1.last(this.plot.below).panel._bottom, [
                -1,
                this.below_panel._bottom
            ]));
        }
        if (this.plot.left.length > 0) {
            constraints.push(solver_1.EQ(array_1.last(this.plot.left).panel._left, [
                -1,
                this.left_panel._left
            ]));
        }
        if (this.plot.right.length > 0) {
            constraints.push(solver_1.EQ(array_1.last(this.plot.right).panel._right, [
                -1,
                this.right_panel._right
            ]));
        }
        return constraints;
    };
    return PlotCanvas;
}(layout_dom_1.LayoutDOM);    
},
/* models/ranges/data_range */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var range_1 = require(154    /* ./range */);
var p = require(13    /* core/properties */);
exports.DataRange = function (superClass) {
    extend(DataRange, superClass);
    function DataRange() {
        return DataRange.__super__.constructor.apply(this, arguments);
    }
    DataRange.prototype.type = 'DataRange';
    DataRange.define({
        names: [
            p.Array,
            []
        ],
        renderers: [
            p.Array,
            []
        ]
    });
    return DataRange;
}(range_1.Range);    
},
/* models/ranges/data_range1d */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var data_range_1 = require(150    /* ./data_range */);
var glyph_renderer_1 = require(156    /* ../renderers/glyph_renderer */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var bbox = require(21    /* core/util/bbox */);
exports.DataRange1d = function (superClass) {
    extend(DataRange1d, superClass);
    function DataRange1d() {
        return DataRange1d.__super__.constructor.apply(this, arguments);
    }
    DataRange1d.prototype.type = 'DataRange1d';
    DataRange1d.define({
        start: [p.Number],
        end: [p.Number],
        range_padding: [
            p.Number,
            0.1
        ],
        range_padding_units: [
            p.PaddingUnits,
            'percent'
        ],
        flipped: [
            p.Bool,
            false
        ],
        follow: [p.StartEnd],
        follow_interval: [p.Number],
        default_span: [
            p.Number,
            2
        ],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });
    DataRange1d.internal({
        scale_hint: [
            p.String,
            'auto'
        ]
    });
    DataRange1d.prototype.initialize = function (attrs, options) {
        DataRange1d.__super__.initialize.call(this, attrs, options);
        this.plot_bounds = {};
        this.have_updated_interactively = false;
        this._initial_start = this.start;
        this._initial_end = this.end;
        this._initial_range_padding = this.range_padding;
        this._initial_range_padding_units = this.range_padding_units;
        this._initial_follow = this.follow;
        this._initial_follow_interval = this.follow_interval;
        return this._initial_default_span = this.default_span;
    };
    DataRange1d.getters({
        min: function () {
            return Math.min(this.start, this.end);
        },
        max: function () {
            return Math.max(this.start, this.end);
        }
    });
    DataRange1d.prototype.computed_renderers = function () {
        var all_renderers, i, j, len, len1, names, plot, r, ref, renderers, rs;
        names = this.names;
        renderers = this.renderers;
        if (renderers.length === 0) {
            ref = this.plots;
            for (i = 0, len = ref.length; i < len; i++) {
                plot = ref[i];
                all_renderers = plot.renderers;
                rs = function () {
                    var j, len1, results;
                    results = [];
                    for (j = 0, len1 = all_renderers.length; j < len1; j++) {
                        r = all_renderers[j];
                        if (r instanceof glyph_renderer_1.GlyphRenderer) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
                renderers = renderers.concat(rs);
            }
        }
        if (names.length > 0) {
            renderers = function () {
                var j, len1, results;
                results = [];
                for (j = 0, len1 = renderers.length; j < len1; j++) {
                    r = renderers[j];
                    if (names.indexOf(r.name) >= 0) {
                        results.push(r);
                    }
                }
                return results;
            }();
        }
        logging_1.logger.debug('computed ' + renderers.length + ' renderers for DataRange1d ' + this.id);
        for (j = 0, len1 = renderers.length; j < len1; j++) {
            r = renderers[j];
            logging_1.logger.trace(' - ' + r.type + ' ' + r.id);
        }
        return renderers;
    };
    DataRange1d.prototype._compute_plot_bounds = function (renderers, bounds) {
        var i, len, r, result;
        result = bbox.empty();
        for (i = 0, len = renderers.length; i < len; i++) {
            r = renderers[i];
            if (bounds[r.id] != null) {
                result = bbox.union(result, bounds[r.id]);
            }
        }
        return result;
    };
    DataRange1d.prototype._compute_min_max = function (plot_bounds, dimension) {
        var k, max, min, overall, ref, ref1, v;
        overall = bbox.empty();
        for (k in plot_bounds) {
            v = plot_bounds[k];
            overall = bbox.union(overall, v);
        }
        if (dimension === 0) {
            ref = [
                overall.minX,
                overall.maxX
            ], min = ref[0], max = ref[1];
        } else {
            ref1 = [
                overall.minY,
                overall.maxY
            ], min = ref1[0], max = ref1[1];
        }
        return [
            min,
            max
        ];
    };
    DataRange1d.prototype._compute_range = function (min, max) {
        var center, end, follow_interval, follow_sign, log_max, log_min, range_padding, ref, ref1, ref2, ref3, span, start;
        range_padding = (ref = this.range_padding) != null ? ref : 0;
        if (this.scale_hint === 'log') {
            if (isNaN(min) || !isFinite(min) || min <= 0) {
                if (isNaN(max) || !isFinite(max) || max <= 0) {
                    min = 0.1;
                } else {
                    min = max / 100;
                }
                logging_1.logger.warn('could not determine minimum data value for log axis, DataRange1d using value ' + min);
            }
            if (isNaN(max) || !isFinite(max) || max <= 0) {
                if (isNaN(min) || !isFinite(min) || min <= 0) {
                    max = 10;
                } else {
                    max = min * 100;
                }
                logging_1.logger.warn('could not determine maximum data value for log axis, DataRange1d using value ' + max);
            }
            if (max === min) {
                span = this.default_span + 0.001;
                center = Math.log(min) / Math.log(10);
            } else {
                if (this.range_padding_units === 'percent') {
                    log_min = Math.log(min) / Math.log(10);
                    log_max = Math.log(max) / Math.log(10);
                    span = (log_max - log_min) * (1 + range_padding);
                } else {
                    log_min = Math.log(min - range_padding) / Math.log(10);
                    log_max = Math.log(max + range_padding) / Math.log(10);
                    span = log_max - log_min;
                }
                center = (log_min + log_max) / 2;
            }
            ref1 = [
                Math.pow(10, center - span / 2),
                Math.pow(10, center + span / 2)
            ], start = ref1[0], end = ref1[1];
        } else {
            if (max === min) {
                span = this.default_span;
            } else {
                if (this.range_padding_units === 'percent') {
                    span = (max - min) * (1 + range_padding);
                } else {
                    span = max - min + 2 * range_padding;
                }
            }
            center = (max + min) / 2;
            ref2 = [
                center - span / 2,
                center + span / 2
            ], start = ref2[0], end = ref2[1];
        }
        follow_sign = +1;
        if (this.flipped) {
            ref3 = [
                end,
                start
            ], start = ref3[0], end = ref3[1];
            follow_sign = -1;
        }
        follow_interval = this.follow_interval;
        if (follow_interval != null && Math.abs(start - end) > follow_interval) {
            if (this.follow === 'start') {
                end = start + follow_sign * follow_interval;
            } else if (this.follow === 'end') {
                start = end - follow_sign * follow_interval;
            }
        }
        return [
            start,
            end
        ];
    };
    DataRange1d.prototype.update = function (bounds, dimension, bounds_id) {
        var _end, _start, end, max, min, new_range, ref, ref1, ref2, renderers, start;
        if (this.have_updated_interactively) {
            return;
        }
        renderers = this.computed_renderers();
        this.plot_bounds[bounds_id] = this._compute_plot_bounds(renderers, bounds);
        ref = this._compute_min_max(this.plot_bounds, dimension), min = ref[0], max = ref[1];
        ref1 = this._compute_range(min, max), start = ref1[0], end = ref1[1];
        if (this._initial_start != null) {
            if (this.scale_hint === 'log') {
                if (this._initial_start > 0) {
                    start = this._initial_start;
                }
            } else {
                start = this._initial_start;
            }
        }
        if (this._initial_end != null) {
            if (this.scale_hint === 'log') {
                if (this._initial_end > 0) {
                    end = this._initial_end;
                }
            } else {
                end = this._initial_end;
            }
        }
        ref2 = [
            this.start,
            this.end
        ], _start = ref2[0], _end = ref2[1];
        if (start !== _start || end !== _end) {
            new_range = {};
            if (start !== _start) {
                new_range.start = start;
            }
            if (end !== _end) {
                new_range.end = end;
            }
            this.setv(new_range);
        }
        if (this.bounds === 'auto') {
            this.setv({
                bounds: [
                    start,
                    end
                ]
            }, { silent: true });
        }
        return this.change.emit();
    };
    DataRange1d.prototype.reset = function () {
        this.have_updated_interactively = false;
        this.setv({
            range_padding: this._initial_range_padding,
            range_padding_units: this._initial_range_padding_units,
            follow: this._initial_follow,
            follow_interval: this._initial_follow_interval,
            default_span: this._initial_default_span
        }, { silent: true });
        return this.change.emit();
    };
    return DataRange1d;
}(data_range_1.DataRange);    
},
/* models/ranges/factor_range */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var range_1 = require(154    /* ./range */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
exports.map_one_level = function (factors, padding, offset) {
    var f, i, j, len, mapping;
    if (offset == null) {
        offset = 0;
    }
    mapping = {};
    for (i = j = 0, len = factors.length; j < len; i = ++j) {
        f = factors[i];
        if (f in mapping) {
            throw new Error('duplicate factor or subfactor ' + f);
        }
        mapping[f] = { value: 0.5 + i * (1 + padding) + offset };
    }
    return [
        mapping,
        (factors.length - 1) * padding
    ];
};
exports.map_two_levels = function (factors, outer_pad, factor_pad, offset) {
    var f0, f1, j, k, len, len1, mapping, n, ref, ref1, submap, suboffset, subpad, subtot, tops, tops_order, total_subpad;
    if (offset == null) {
        offset = 0;
    }
    mapping = {};
    tops = {};
    tops_order = [];
    for (j = 0, len = factors.length; j < len; j++) {
        ref = factors[j], f0 = ref[0], f1 = ref[1];
        if (!(f0 in tops)) {
            tops[f0] = [];
            tops_order.push(f0);
        }
        tops[f0].push(f1);
    }
    suboffset = offset;
    total_subpad = 0;
    for (k = 0, len1 = tops_order.length; k < len1; k++) {
        f0 = tops_order[k];
        n = tops[f0].length;
        ref1 = exports.map_one_level(tops[f0], factor_pad, suboffset), submap = ref1[0], subpad = ref1[1];
        total_subpad += subpad;
        subtot = array_1.sum(function () {
            var l, len2, ref2, results;
            ref2 = tops[f0];
            results = [];
            for (l = 0, len2 = ref2.length; l < len2; l++) {
                f1 = ref2[l];
                results.push(submap[f1].value);
            }
            return results;
        }());
        mapping[f0] = {
            value: subtot / n,
            mapping: submap
        };
        suboffset += n + outer_pad + subpad;
    }
    return [
        mapping,
        tops_order,
        (tops_order.length - 1) * outer_pad + total_subpad
    ];
};
exports.map_three_levels = function (factors, outer_pad, inner_pad, factor_pad, offset) {
    var f0, f1, f2, j, k, l, len, len1, len2, mapping, mids_order, n, ref, ref1, submap, submids_order, suboffset, subpad, subtot, tops, tops_order, total_subpad;
    if (offset == null) {
        offset = 0;
    }
    mapping = {};
    tops = {};
    tops_order = [];
    for (j = 0, len = factors.length; j < len; j++) {
        ref = factors[j], f0 = ref[0], f1 = ref[1], f2 = ref[2];
        if (!(f0 in tops)) {
            tops[f0] = [];
            tops_order.push(f0);
        }
        tops[f0].push([
            f1,
            f2
        ]);
    }
    mids_order = [];
    suboffset = offset;
    total_subpad = 0;
    for (k = 0, len1 = tops_order.length; k < len1; k++) {
        f0 = tops_order[k];
        n = tops[f0].length;
        ref1 = exports.map_two_levels(tops[f0], inner_pad, factor_pad, suboffset), submap = ref1[0], submids_order = ref1[1], subpad = ref1[2];
        for (l = 0, len2 = submids_order.length; l < len2; l++) {
            f1 = submids_order[l];
            mids_order.push([
                f0,
                f1
            ]);
        }
        total_subpad += subpad;
        subtot = array_1.sum(function () {
            var len3, m, ref2, ref3, results;
            ref2 = tops[f0];
            results = [];
            for (m = 0, len3 = ref2.length; m < len3; m++) {
                ref3 = ref2[m], f1 = ref3[0], f2 = ref3[1];
                results.push(submap[f1].value);
            }
            return results;
        }());
        mapping[f0] = {
            value: subtot / n,
            mapping: submap
        };
        suboffset += n + outer_pad + subpad;
    }
    return [
        mapping,
        tops_order,
        mids_order,
        (tops_order.length - 1) * outer_pad + total_subpad
    ];
};
exports.FactorRange = function (superClass) {
    extend(FactorRange, superClass);
    function FactorRange() {
        return FactorRange.__super__.constructor.apply(this, arguments);
    }
    FactorRange.prototype.type = 'FactorRange';
    FactorRange.define({
        factors: [
            p.Array,
            []
        ],
        factor_padding: [
            p.Number,
            0
        ],
        subgroup_padding: [
            p.Number,
            0.8
        ],
        group_padding: [
            p.Number,
            1.4
        ],
        range_padding: [
            p.Number,
            0
        ],
        range_padding_units: [
            p.PaddingUnits,
            'percent'
        ],
        start: [p.Number],
        end: [p.Number],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });
    FactorRange.getters({
        min: function () {
            return this.start;
        },
        max: function () {
            return this.end;
        }
    });
    FactorRange.internal({
        levels: [p.Number],
        mids: [p.Array],
        tops: [p.Array],
        tops_groups: [p.Array]
    });
    FactorRange.prototype.initialize = function (attrs, options) {
        FactorRange.__super__.initialize.call(this, attrs, options);
        this._init();
        this.connect(this.properties.factors.change, function () {
            return this._init();
        });
        this.connect(this.properties.factor_padding.change, function () {
            return this._init();
        });
        this.connect(this.properties.group_padding.change, function () {
            return this._init();
        });
        this.connect(this.properties.subgroup_padding.change, function () {
            return this._init();
        });
        this.connect(this.properties.range_padding.change, function () {
            return this._init();
        });
        return this.connect(this.properties.range_padding_units.change, function () {
            return this._init();
        });
    };
    FactorRange.prototype.reset = function () {
        this._init();
        return this.change.emit();
    };
    FactorRange.prototype.synthetic = function (x) {
        var offset;
        if (types_1.isNumber(x)) {
            return x;
        }
        if (types_1.isString(x)) {
            return this._lookup([x]);
        }
        offset = 0;
        if (types_1.isNumber(x[x.length - 1])) {
            offset = x[x.length - 1];
            x = x.slice(0, -1);
        }
        return this._lookup(x) + offset;
    };
    FactorRange.prototype.v_synthetic = function (xs) {
        var result, x;
        return result = function () {
            var j, len, results;
            results = [];
            for (j = 0, len = xs.length; j < len; j++) {
                x = xs[j];
                results.push(this.synthetic(x));
            }
            return results;
        }.call(this);
    };
    FactorRange.prototype._init = function () {
        var end, half_span, inside_padding, levels, ref, ref1, ref2, start;
        if (array_1.all(this.factors, types_1.isString)) {
            levels = 1;
            ref = exports.map_one_level(this.factors, this.factor_padding), this._mapping = ref[0], inside_padding = ref[1];
        } else if (array_1.all(this.factors, function (x) {
                return types_1.isArray(x) && x.length === 2 && types_1.isString(x[0]) && types_1.isString(x[1]);
            })) {
            levels = 2;
            ref1 = exports.map_two_levels(this.factors, this.group_padding, this.factor_padding), this._mapping = ref1[0], this.tops = ref1[1], inside_padding = ref1[2];
        } else if (array_1.all(this.factors, function (x) {
                return types_1.isArray(x) && x.length === 3 && types_1.isString(x[0]) && types_1.isString(x[1]) && types_1.isString(x[2]);
            })) {
            levels = 3;
            ref2 = exports.map_three_levels(this.factors, this.group_padding, this.subgroup_padding, this.factor_padding), this._mapping = ref2[0], this.tops = ref2[1], this.mids = ref2[2], inside_padding = ref2[3];
        } else {
            throw new Error('');
        }
        start = 0;
        end = this.factors.length + inside_padding;
        if (this.range_padding_units === 'percent') {
            half_span = (end - start) * this.range_padding / 2;
            start -= half_span;
            end += half_span;
        } else {
            start -= this.range_padding;
            end += this.range_padding;
        }
        this.setv({
            start: start,
            end: end,
            levels: levels
        }, { silent: true });
        if (this.bounds === 'auto') {
            return this.setv({
                bounds: [
                    start,
                    end
                ]
            }, { silent: true });
        }
    };
    FactorRange.prototype._lookup = function (x) {
        if (x.length === 1) {
            return this._mapping[x[0]].value;
        } else if (x.length === 2) {
            return this._mapping[x[0]].mapping[x[1]].value;
        } else if (x.length === 3) {
            return this._mapping[x[0]].mapping[x[1]].mapping[x[2]].value;
        }
    };
    return FactorRange;
}(range_1.Range);    
},
/* models/ranges/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var data_range_1 = require(150    /* ./data_range */);
exports.DataRange = data_range_1.DataRange;
var data_range1d_1 = require(151    /* ./data_range1d */);
exports.DataRange1d = data_range1d_1.DataRange1d;
var factor_range_1 = require(152    /* ./factor_range */);
exports.FactorRange = factor_range_1.FactorRange;
var range_1 = require(154    /* ./range */);
exports.Range = range_1.Range;
var range1d_1 = require(155    /* ./range1d */);
exports.Range1d = range1d_1.Range1d;    
},
/* models/ranges/range */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var p = require(13    /* core/properties */);
exports.Range = function (superClass) {
    extend(Range, superClass);
    function Range() {
        return Range.__super__.constructor.apply(this, arguments);
    }
    Range.prototype.type = 'Range';
    Range.prototype.initialize = function (options) {
        Range.__super__.initialize.call(this, options);
        return this.connect(this.change, function () {
            var ref;
            return (ref = this.callback) != null ? ref.execute(this) : void 0;
        });
    };
    Range.define({ callback: [p.Instance] });
    Range.internal({
        plots: [
            p.Array,
            []
        ]
    });
    Range.prototype.reset = function () {
        'This method should be reimplemented by subclasses and ensure that\nthe callback, if exists, is executed at completion.';
        return this.change.emit();
    };
    return Range;
}(model_1.Model);    
},
/* models/ranges/range1d */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var range_1 = require(154    /* ./range */);
var p = require(13    /* core/properties */);
exports.Range1d = function (superClass) {
    extend(Range1d, superClass);
    Range1d.prototype.type = 'Range1d';
    Range1d.define({
        start: [
            p.Number,
            0
        ],
        end: [
            p.Number,
            1
        ],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });
    Range1d.prototype._set_auto_bounds = function () {
        var max, min;
        if (this.bounds === 'auto') {
            min = Math.min(this._initial_start, this._initial_end);
            max = Math.max(this._initial_start, this._initial_end);
            return this.setv({
                bounds: [
                    min,
                    max
                ]
            }, { silent: true });
        }
    };
    function Range1d() {
        var end, start;
        if (this instanceof Range1d) {
            return Range1d.__super__.constructor.apply(this, arguments);
        } else {
            start = arguments[0], end = arguments[1];
            return new Range1d({
                start: start,
                end: end
            });
        }
    }
    Range1d.prototype.initialize = function (attrs, options) {
        Range1d.__super__.initialize.call(this, attrs, options);
        this._initial_start = this.start;
        this._initial_end = this.end;
        return this._set_auto_bounds();
    };
    Range1d.getters({
        min: function () {
            return Math.min(this.start, this.end);
        },
        max: function () {
            return Math.max(this.start, this.end);
        }
    });
    Range1d.prototype.reset = function () {
        this._set_auto_bounds();
        if (this.start !== this._initial_start || this.end !== this._initial_end) {
            return this.setv({
                start: this._initial_start,
                end: this._initial_end
            });
        } else {
            return this.change.emit();
        }
    };
    return Range1d;
}(range_1.Range);    
},
/* models/renderers/glyph_renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var renderer_1 = require(160    /* ./renderer */);
var line_1 = require(110    /* ../glyphs/line */);
var remote_data_source_1 = require(173    /* ../sources/remote_data_source */);
var cds_view_1 = require(167    /* ../sources/cds_view */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
exports.GlyphRendererView = function (superClass) {
    extend1(GlyphRendererView, superClass);
    function GlyphRendererView() {
        return GlyphRendererView.__super__.constructor.apply(this, arguments);
    }
    GlyphRendererView.prototype.initialize = function (options) {
        var base_glyph, decimated_glyph, glyph_attrs, has_fill, has_line, hover_glyph, mk_glyph, muted_glyph, nonselection_glyph, selection_glyph;
        GlyphRendererView.__super__.initialize.call(this, options);
        base_glyph = this.model.glyph;
        has_fill = indexOf.call(base_glyph.mixins, 'fill') >= 0;
        has_line = indexOf.call(base_glyph.mixins, 'line') >= 0;
        glyph_attrs = object_1.clone(base_glyph.attributes);
        delete glyph_attrs.id;
        mk_glyph = function (defaults) {
            var attrs;
            attrs = object_1.clone(glyph_attrs);
            if (has_fill) {
                object_1.extend(attrs, defaults.fill);
            }
            if (has_line) {
                object_1.extend(attrs, defaults.line);
            }
            return new base_glyph.constructor(attrs);
        };
        this.glyph = this.build_glyph_view(base_glyph);
        selection_glyph = this.model.selection_glyph;
        if (selection_glyph == null) {
            selection_glyph = mk_glyph({
                fill: {},
                line: {}
            });
        } else if (selection_glyph === 'auto') {
            selection_glyph = mk_glyph(this.model.selection_defaults);
        }
        this.selection_glyph = this.build_glyph_view(selection_glyph);
        nonselection_glyph = this.model.nonselection_glyph;
        if (nonselection_glyph == null) {
            nonselection_glyph = mk_glyph({
                fill: {},
                line: {}
            });
        } else if (nonselection_glyph === 'auto') {
            nonselection_glyph = mk_glyph(this.model.nonselection_defaults);
        }
        this.nonselection_glyph = this.build_glyph_view(nonselection_glyph);
        hover_glyph = this.model.hover_glyph;
        if (hover_glyph != null) {
            this.hover_glyph = this.build_glyph_view(hover_glyph);
        }
        muted_glyph = this.model.muted_glyph;
        if (muted_glyph != null) {
            this.muted_glyph = this.build_glyph_view(muted_glyph);
        }
        decimated_glyph = mk_glyph(this.model.decimated_defaults);
        this.decimated_glyph = this.build_glyph_view(decimated_glyph);
        this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];
        this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];
        this.set_data(false);
        if (this.model.data_source instanceof remote_data_source_1.RemoteDataSource) {
            return this.model.data_source.setup();
        }
    };
    GlyphRendererView.getters({
        xmapper: function () {
            log.warning('xmapper attr is deprecated, use xscale');
            return this.xscale;
        },
        ymapper: function () {
            log.warning('ymapper attr is deprecated, use yscale');
            return this.yscale;
        }
    });
    GlyphRendererView.prototype.build_glyph_view = function (model) {
        return new model.default_view({
            model: model,
            renderer: this,
            plot_view: this.plot_view,
            parent: this
        });
    };
    GlyphRendererView.prototype.connect_signals = function () {
        GlyphRendererView.__super__.connect_signals.call(this);
        this.connect(this.model.change, function () {
            return this.request_render();
        });
        this.connect(this.model.glyph.change, function () {
            return this.set_data();
        });
        this.connect(this.model.data_source.change, function () {
            return this.set_data();
        });
        this.connect(this.model.data_source.streaming, function () {
            return this.set_data();
        });
        this.connect(this.model.data_source.patching, function (indices) {
            return this.set_data(true, indices);
        });
        this.connect(this.model.data_source.select, function () {
            return this.request_render();
        });
        if (this.hover_glyph != null) {
            this.connect(this.model.data_source.inspect, function () {
                return this.request_render();
            });
        }
        this.connect(this.model.properties.view.change, function () {
            return this.set_data();
        });
        this.connect(this.model.view.change, function () {
            return this.set_data();
        });
        return this.connect(this.model.glyph.transformchange, function () {
            return this.set_data();
        });
    };
    GlyphRendererView.prototype.have_selection_glyphs = function () {
        return this.selection_glyph != null && this.nonselection_glyph != null;
    };
    GlyphRendererView.prototype.set_data = function (request_render, indices) {
        var dt, i, j, lod_factor, ref, source, t0;
        if (request_render == null) {
            request_render = true;
        }
        t0 = Date.now();
        source = this.model.data_source;
        this.all_indices = this.model.view.indices;
        this.glyph.model.setv({
            x_range_name: this.model.x_range_name,
            y_range_name: this.model.y_range_name
        }, { silent: true });
        this.glyph.set_data(source, this.all_indices, indices);
        this.glyph.set_visuals(source);
        this.decimated_glyph.set_visuals(source);
        if (this.have_selection_glyphs()) {
            this.selection_glyph.set_visuals(source);
            this.nonselection_glyph.set_visuals(source);
        }
        if (this.hover_glyph != null) {
            this.hover_glyph.set_visuals(source);
        }
        if (this.muted_glyph != null) {
            this.muted_glyph.set_visuals(source);
        }
        lod_factor = this.plot_model.plot.lod_factor;
        this.decimated = [];
        for (i = j = 0, ref = Math.floor(this.all_indices.length / lod_factor); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.decimated.push(this.all_indices[i * lod_factor]);
        }
        dt = Date.now() - t0;
        logging_1.logger.debug(this.glyph.model.type + ' GlyphRenderer (' + this.model.id + '): set_data finished in ' + dt + 'ms');
        this.set_data_timestamp = Date.now();
        if (request_render) {
            return this.request_render();
        }
    };
    GlyphRendererView.prototype.render = function () {
        var ctx, dtmap, dtmask, dtrender, dtselect, dttot, glsupport, glyph, i, indices, inspected, j, k, len, len1, lod_threshold, nonselected, nonselection_glyph, selected, selected_mask, selection_glyph, t0, tmap, tmask, trender, tselect;
        if (!this.model.visible) {
            return;
        }
        t0 = Date.now();
        glsupport = this.glyph.glglyph;
        tmap = Date.now();
        this.glyph.map_data();
        dtmap = Date.now() - t0;
        tmask = Date.now();
        indices = this.glyph.mask_data(this.all_indices);
        dtmask = Date.now() - tmask;
        ctx = this.plot_view.canvas_view.ctx;
        ctx.save();
        selected = this.model.data_source.selected;
        if (!selected || selected.length === 0) {
            selected = [];
        } else {
            if (selected['0d'].glyph) {
                if (this.glyph instanceof line_1.LineView) {
                    selected = indices;
                } else {
                    selected = this.model.view.convert_indices_from_subset(indices);
                }
            } else if (selected['1d'].indices.length > 0) {
                selected = selected['1d'].indices;
            } else {
                selected = function () {
                    var j, len, ref, results;
                    ref = Object.keys(selected['2d'].indices);
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        i = ref[j];
                        results.push(parseInt(i));
                    }
                    return results;
                }();
            }
        }
        inspected = this.model.data_source.inspected;
        if (!inspected || inspected.length === 0) {
            inspected = [];
        } else {
            if (inspected['0d'].glyph) {
                if (this.glyph instanceof line_1.LineView) {
                    inspected = indices;
                } else {
                    inspected = this.model.view.convert_indices_from_subset(indices);
                }
            } else if (inspected['1d'].indices.length > 0) {
                inspected = inspected['1d'].indices;
            } else {
                inspected = function () {
                    var j, len, ref, results;
                    ref = Object.keys(inspected['2d'].indices);
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        i = ref[j];
                        results.push(parseInt(i));
                    }
                    return results;
                }();
            }
        }
        inspected = function () {
            var j, len, ref, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (ref = this.all_indices[i], indexOf.call(inspected, ref) >= 0) {
                    results.push(i);
                }
            }
            return results;
        }.call(this);
        lod_threshold = this.plot_model.plot.lod_threshold;
        if (this.plot_view.interactive && !glsupport && lod_threshold != null && this.all_indices.length > lod_threshold) {
            indices = this.decimated;
            glyph = this.decimated_glyph;
            nonselection_glyph = this.decimated_glyph;
            selection_glyph = this.selection_glyph;
        } else {
            glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;
            nonselection_glyph = this.nonselection_glyph;
            selection_glyph = this.selection_glyph;
        }
        if (this.hover_glyph != null && inspected.length) {
            indices = array_1.difference(indices, inspected);
        }
        if (!(selected.length && this.have_selection_glyphs())) {
            trender = Date.now();
            glyph.render(ctx, indices, this.glyph);
            if (this.hover_glyph && inspected.length) {
                this.hover_glyph.render(ctx, inspected, this.glyph);
            }
            dtrender = Date.now() - trender;
        } else {
            tselect = Date.now();
            selected_mask = {};
            for (j = 0, len = selected.length; j < len; j++) {
                i = selected[j];
                selected_mask[i] = true;
            }
            selected = new Array();
            nonselected = new Array();
            for (k = 0, len1 = indices.length; k < len1; k++) {
                i = indices[k];
                if (this.glyph instanceof line_1.LineView) {
                    if (selected_mask[i] != null) {
                        selected.push(i);
                    } else {
                        nonselected.push(i);
                    }
                } else {
                    if (selected_mask[this.all_indices[i]] != null) {
                        selected.push(i);
                    } else {
                        nonselected.push(i);
                    }
                }
            }
            dtselect = Date.now() - tselect;
            trender = Date.now();
            nonselection_glyph.render(ctx, nonselected, this.glyph);
            selection_glyph.render(ctx, selected, this.glyph);
            if (this.hover_glyph != null) {
                this.hover_glyph.render(ctx, inspected, this.glyph);
            }
            dtrender = Date.now() - trender;
        }
        this.last_dtrender = dtrender;
        dttot = Date.now() - t0;
        logging_1.logger.debug(this.glyph.model.type + ' GlyphRenderer (' + this.model.id + '): render finished in ' + dttot + 'ms');
        logging_1.logger.trace(' - map_data finished in       : ' + dtmap + 'ms');
        if (dtmask != null) {
            logging_1.logger.trace(' - mask_data finished in      : ' + dtmask + 'ms');
        }
        if (dtselect != null) {
            logging_1.logger.trace(' - selection mask finished in : ' + dtselect + 'ms');
        }
        logging_1.logger.trace(' - glyph renders finished in  : ' + dtrender + 'ms');
        return ctx.restore();
    };
    GlyphRendererView.prototype.map_to_screen = function (x, y) {
        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);
    };
    GlyphRendererView.prototype.draw_legend = function (ctx, x0, x1, y0, y1, field, label) {
        var index;
        index = this.model.get_reference_point(field, label);
        return this.glyph.draw_legend_for_index(ctx, x0, x1, y0, y1, index);
    };
    GlyphRendererView.prototype.hit_test = function (geometry, final, append, mode) {
        if (mode == null) {
            mode = 'select';
        }
        return this.model.hit_test_helper(geometry, this, final, append, mode);
    };
    return GlyphRendererView;
}(renderer_1.RendererView);
exports.GlyphRenderer = function (superClass) {
    extend1(GlyphRenderer, superClass);
    function GlyphRenderer() {
        return GlyphRenderer.__super__.constructor.apply(this, arguments);
    }
    GlyphRenderer.prototype.default_view = exports.GlyphRendererView;
    GlyphRenderer.prototype.type = 'GlyphRenderer';
    GlyphRenderer.prototype.initialize = function (options) {
        GlyphRenderer.__super__.initialize.call(this, options);
        if (this.view.source == null) {
            this.view.source = this.data_source;
            return this.view.compute_indices();
        }
    };
    GlyphRenderer.prototype.get_reference_point = function (field, value) {
        var data, i, index;
        index = 0;
        if (field != null && this.data_source.get_column != null) {
            data = this.data_source.get_column(field);
            if (data) {
                i = data.indexOf(value);
                if (i > 0) {
                    index = i;
                }
            }
        }
        return index;
    };
    GlyphRenderer.prototype.hit_test_helper = function (geometry, renderer_view, final, append, mode) {
        var hit_test_result, indices, inspector, selector;
        if (!this.visible) {
            return false;
        }
        hit_test_result = renderer_view.glyph.hit_test(geometry);
        if (hit_test_result === null) {
            return false;
        }
        indices = this.view.convert_selection_from_subset(hit_test_result);
        if (mode === 'select') {
            selector = this.data_source.selection_manager.selector;
            selector.update(indices, final, append);
            this.data_source.selected = selector.indices;
            this.data_source.select.emit();
        } else {
            inspector = this.data_source.selection_manager.get_or_create_inspector(this);
            inspector.update(indices, true, false, true);
            this.data_source.setv({ inspected: inspector.indices }, { silent: true });
            this.data_source.inspect.emit([
                renderer_view,
                { geometry: geometry }
            ]);
        }
        return !indices.is_empty();
    };
    GlyphRenderer.prototype.get_selection_manager = function () {
        return this.data_source.selection_manager;
    };
    GlyphRenderer.define({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        data_source: [p.Instance],
        view: [
            p.Instance,
            function () {
                return new cds_view_1.CDSView();
            }
        ],
        glyph: [p.Instance],
        hover_glyph: [p.Instance],
        nonselection_glyph: [
            p.Any,
            'auto'
        ],
        selection_glyph: [
            p.Any,
            'auto'
        ],
        muted_glyph: [p.Instance],
        muted: [
            p.Bool,
            false
        ]
    });
    GlyphRenderer.override({ level: 'glyph' });
    GlyphRenderer.prototype.selection_defaults = {
        fill: {},
        line: {}
    };
    GlyphRenderer.prototype.decimated_defaults = {
        fill: {
            fill_alpha: 0.3,
            fill_color: 'grey'
        },
        line: {
            line_alpha: 0.3,
            line_color: 'grey'
        }
    };
    GlyphRenderer.prototype.nonselection_defaults = {
        fill: {
            fill_alpha: 0.2,
            line_alpha: 0.2
        },
        line: {}
    };
    return GlyphRenderer;
}(renderer_1.Renderer);    
},
/* models/renderers/graph_renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var renderer_1 = require(160    /* ../renderers/renderer */);
var graph_hit_test_policy_1 = require(124    /* ../graphs/graph_hit_test_policy */);
var p = require(13    /* core/properties */);
var build_views_1 = require(3    /* core/build_views */);
exports.GraphRendererView = function (superClass) {
    extend(GraphRendererView, superClass);
    function GraphRendererView() {
        return GraphRendererView.__super__.constructor.apply(this, arguments);
    }
    GraphRendererView.prototype.initialize = function (options) {
        var ref;
        GraphRendererView.__super__.initialize.call(this, options);
        this.xscale = this.plot_view.frame.xscales['default'];
        this.yscale = this.plot_view.frame.yscales['default'];
        this._renderer_views = {};
        ref = build_views_1.build_views(this._renderer_views, [
            this.model.node_renderer,
            this.model.edge_renderer
        ], this.plot_view.view_options()), this.node_view = ref[0], this.edge_view = ref[1];
        return this.set_data();
    };
    GraphRendererView.prototype.connect_signals = function () {
        GraphRendererView.__super__.connect_signals.call(this);
        this.connect(this.model.layout_provider.change, function () {
            return this.set_data();
        });
        this.connect(this.model.node_renderer.data_source.select, function () {
            return this.set_data();
        });
        this.connect(this.model.node_renderer.data_source.inspect, function () {
            return this.set_data();
        });
        this.connect(this.model.edge_renderer.data_source.select, function () {
            return this.set_data();
        });
        return this.connect(this.model.edge_renderer.data_source.inspect, function () {
            return this.set_data();
        });
    };
    GraphRendererView.prototype.set_data = function (request_render) {
        var ref, ref1;
        if (request_render == null) {
            request_render = true;
        }
        this.node_view.glyph.model.setv({
            x_range_name: this.model.x_range_name,
            y_range_name: this.model.y_range_name
        }, { silent: true });
        this.edge_view.glyph.model.setv({
            x_range_name: this.model.x_range_name,
            y_range_name: this.model.y_range_name
        }, { silent: true });
        ref = this.model.layout_provider.get_node_coordinates(this.model.node_renderer.data_source), this.node_view.glyph._x = ref[0], this.node_view.glyph._y = ref[1];
        ref1 = this.model.layout_provider.get_edge_coordinates(this.model.edge_renderer.data_source), this.edge_view.glyph._xs = ref1[0], this.edge_view.glyph._ys = ref1[1];
        this.node_view.glyph.index = this.node_view.glyph._index_data();
        this.edge_view.glyph.index = this.edge_view.glyph._index_data();
        if (request_render) {
            return this.request_render();
        }
    };
    GraphRendererView.prototype.render = function () {
        this.edge_view.render();
        return this.node_view.render();
    };
    GraphRendererView.prototype.hit_test = function (geometry, final, append, mode) {
        var did_hit, ref, ref1;
        if (mode == null) {
            mode = 'select';
        }
        if (!this.model.visible) {
            return false;
        }
        did_hit = false;
        if (mode === 'select') {
            did_hit = (ref = this.model.selection_policy) != null ? ref.do_selection(geometry, this, final, append) : void 0;
        } else {
            did_hit = (ref1 = this.model.inspection_policy) != null ? ref1.do_inspection(geometry, this, final, append) : void 0;
        }
        return did_hit;
    };
    return GraphRendererView;
}(renderer_1.RendererView);
exports.GraphRenderer = function (superClass) {
    extend(GraphRenderer, superClass);
    function GraphRenderer() {
        return GraphRenderer.__super__.constructor.apply(this, arguments);
    }
    GraphRenderer.prototype.default_view = exports.GraphRendererView;
    GraphRenderer.prototype.type = 'GraphRenderer';
    GraphRenderer.prototype.get_selection_manager = function () {
        return this.node_renderer.data_source.selection_manager;
    };
    GraphRenderer.define({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        layout_provider: [p.Instance],
        node_renderer: [p.Instance],
        edge_renderer: [p.Instance],
        selection_policy: [
            p.Instance,
            function () {
                return new graph_hit_test_policy_1.NodesOnly();
            }
        ],
        inspection_policy: [
            p.Instance,
            function () {
                return new graph_hit_test_policy_1.NodesOnly();
            }
        ]
    });
    GraphRenderer.override({ level: 'glyph' });
    return GraphRenderer;
}(renderer_1.Renderer);    
},
/* models/renderers/guide_renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var renderer_1 = require(160    /* ./renderer */);
var p = require(13    /* core/properties */);
exports.GuideRenderer = function (superClass) {
    extend(GuideRenderer, superClass);
    function GuideRenderer() {
        return GuideRenderer.__super__.constructor.apply(this, arguments);
    }
    GuideRenderer.prototype.type = 'GuideRenderer';
    GuideRenderer.define({ plot: [p.Instance] });
    GuideRenderer.override({ level: 'overlay' });
    return GuideRenderer;
}(renderer_1.Renderer);    
},
/* models/renderers/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var glyph_renderer_1 = require(156    /* ./glyph_renderer */);
exports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;
var graph_renderer_1 = require(157    /* ./graph_renderer */);
exports.GraphRenderer = graph_renderer_1.GraphRenderer;
var guide_renderer_1 = require(158    /* ./guide_renderer */);
exports.GuideRenderer = guide_renderer_1.GuideRenderer;
var renderer_1 = require(160    /* ./renderer */);
exports.Renderer = renderer_1.Renderer;    
},
/* models/renderers/renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend1 = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var dom_view_1 = require(5    /* core/dom_view */);
var visuals_1 = require(44    /* core/visuals */);
var p = require(13    /* core/properties */);
var proj = require(30    /* core/util/projections */);
var object_1 = require(28    /* core/util/object */);
var model_1 = require(48    /* ../../model */);
exports.RendererView = function (superClass) {
    extend1(RendererView, superClass);
    function RendererView() {
        return RendererView.__super__.constructor.apply(this, arguments);
    }
    RendererView.prototype.initialize = function (options) {
        RendererView.__super__.initialize.call(this, options);
        this.plot_view = options.plot_view;
        this.visuals = new visuals_1.Visuals(this.model);
        return this._has_finished = true;
    };
    RendererView.getters({
        plot_model: function () {
            return this.plot_view.model;
        }
    });
    RendererView.prototype.request_render = function () {
        return this.plot_view.request_render();
    };
    RendererView.prototype.set_data = function (source) {
        var data, ref, ref1;
        data = this.model.materialize_dataspecs(source);
        object_1.extend(this, data);
        if (this.plot_model.use_map) {
            if (this._x != null) {
                ref = proj.project_xy(this._x, this._y), this._x = ref[0], this._y = ref[1];
            }
            if (this._xs != null) {
                return ref1 = proj.project_xsys(this._xs, this._ys), this._xs = ref1[0], this._ys = ref1[1], ref1;
            }
        }
    };
    RendererView.prototype.map_to_screen = function (x, y) {
        return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);
    };
    return RendererView;
}(dom_view_1.DOMView);
exports.Renderer = function (superClass) {
    extend1(Renderer, superClass);
    function Renderer() {
        return Renderer.__super__.constructor.apply(this, arguments);
    }
    Renderer.prototype.type = 'Renderer';
    Renderer.define({
        level: [
            p.RenderLevel,
            null
        ],
        visible: [
            p.Bool,
            true
        ]
    });
    return Renderer;
}(model_1.Model);    
},
/* models/scales/categorical_scale */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var linear_scale_1 = require(163    /* ./linear_scale */);
exports.CategoricalScale = function (superClass) {
    extend(CategoricalScale, superClass);
    function CategoricalScale() {
        return CategoricalScale.__super__.constructor.apply(this, arguments);
    }
    CategoricalScale.prototype.type = 'CategoricalScale';
    CategoricalScale.prototype.compute = function (x) {
        return CategoricalScale.__super__.compute.call(this, this.source_range.synthetic(x));
    };
    CategoricalScale.prototype.v_compute = function (xs) {
        return CategoricalScale.__super__.v_compute.call(this, this.source_range.v_synthetic(xs));
    };
    return CategoricalScale;
}(linear_scale_1.LinearScale);    
},
/* models/scales/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var categorical_scale_1 = require(161    /* ./categorical_scale */);
exports.CategoricalScale = categorical_scale_1.CategoricalScale;
var linear_scale_1 = require(163    /* ./linear_scale */);
exports.LinearScale = linear_scale_1.LinearScale;
var log_scale_1 = require(164    /* ./log_scale */);
exports.LogScale = log_scale_1.LogScale;
var scale_1 = require(165    /* ./scale */);
exports.Scale = scale_1.Scale;    
},
/* models/scales/linear_scale */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var scale_1 = require(165    /* ./scale */);
exports.LinearScale = function (superClass) {
    extend(LinearScale, superClass);
    function LinearScale() {
        return LinearScale.__super__.constructor.apply(this, arguments);
    }
    LinearScale.prototype.type = 'LinearScale';
    LinearScale.prototype.compute = function (x) {
        var factor, offset, ref;
        ref = this._compute_state(), factor = ref[0], offset = ref[1];
        return factor * x + offset;
    };
    LinearScale.prototype.v_compute = function (xs) {
        var factor, i, idx, len, offset, ref, result, x;
        ref = this._compute_state(), factor = ref[0], offset = ref[1];
        result = new Float64Array(xs.length);
        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
            x = xs[idx];
            result[idx] = factor * x + offset;
        }
        return result;
    };
    LinearScale.prototype.invert = function (xprime) {
        var factor, offset, ref;
        ref = this._compute_state(), factor = ref[0], offset = ref[1];
        return (xprime - offset) / factor;
    };
    LinearScale.prototype.v_invert = function (xprimes) {
        var factor, i, idx, len, offset, ref, result, xprime;
        ref = this._compute_state(), factor = ref[0], offset = ref[1];
        result = new Float64Array(xprimes.length);
        for (idx = i = 0, len = xprimes.length; i < len; idx = ++i) {
            xprime = xprimes[idx];
            result[idx] = (xprime - offset) / factor;
        }
        return result;
    };
    LinearScale.prototype._compute_state = function () {
        var factor, offset, source_end, source_start, target_end, target_start;
        source_start = this.source_range.start;
        source_end = this.source_range.end;
        target_start = this.target_range.start;
        target_end = this.target_range.end;
        factor = (target_end - target_start) / (source_end - source_start);
        offset = -(factor * source_start) + target_start;
        return [
            factor,
            offset
        ];
    };
    return LinearScale;
}(scale_1.Scale);    
},
/* models/scales/log_scale */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var scale_1 = require(165    /* ./scale */);
exports.LogScale = function (superClass) {
    extend(LogScale, superClass);
    function LogScale() {
        return LogScale.__super__.constructor.apply(this, arguments);
    }
    LogScale.prototype.type = 'LogScale';
    LogScale.prototype.compute = function (x) {
        var _x, factor, inter_factor, inter_offset, offset, ref, value;
        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];
        if (inter_factor === 0) {
            value = 0;
        } else {
            _x = (Math.log(x) - inter_offset) / inter_factor;
            if (isFinite(_x)) {
                value = _x * factor + offset;
            } else {
                value = 0 / 0;
            }
        }
        return value;
    };
    LogScale.prototype.v_compute = function (xs) {
        var _x, factor, i, inter_factor, inter_offset, j, k, offset, ref, ref1, ref2, result, value;
        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];
        result = new Float64Array(xs.length);
        if (inter_factor === 0) {
            for (i = j = 0, ref1 = xs.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                result[i] = 0;
            }
        } else {
            for (i = k = 0, ref2 = xs.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
                _x = (Math.log(xs[i]) - inter_offset) / inter_factor;
                if (isFinite(_x)) {
                    value = _x * factor + offset;
                } else {
                    value = 0 / 0;
                }
                result[i] = value;
            }
        }
        return result;
    };
    LogScale.prototype.invert = function (xprime) {
        var factor, inter_factor, inter_offset, offset, ref, value;
        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];
        value = (xprime - offset) / factor;
        return Math.exp(inter_factor * value + inter_offset);
    };
    LogScale.prototype.v_invert = function (xprimes) {
        var factor, i, inter_factor, inter_offset, j, offset, ref, ref1, result, value;
        ref = this._compute_state(), factor = ref[0], offset = ref[1], inter_factor = ref[2], inter_offset = ref[3];
        result = new Float64Array(xprimes.length);
        for (i = j = 0, ref1 = xprimes.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            value = (xprimes[i] - offset) / factor;
            result[i] = Math.exp(inter_factor * value + inter_offset);
        }
        return result;
    };
    LogScale.prototype._get_safe_factor = function (orig_start, orig_end) {
        var end, log_val, ref, start;
        if (orig_start < 0) {
            start = 0;
        } else {
            start = orig_start;
        }
        if (orig_end < 0) {
            end = 0;
        } else {
            end = orig_end;
        }
        if (start === end) {
            if (start === 0) {
                ref = [
                    1,
                    10
                ], start = ref[0], end = ref[1];
            } else {
                log_val = Math.log(start) / Math.log(10);
                start = Math.pow(10, Math.floor(log_val));
                if (Math.ceil(log_val) !== Math.floor(log_val)) {
                    end = Math.pow(10, Math.ceil(log_val));
                } else {
                    end = Math.pow(10, Math.ceil(log_val) + 1);
                }
            }
        }
        return [
            start,
            end
        ];
    };
    LogScale.prototype._compute_state = function () {
        var end, factor, inter_factor, inter_offset, offset, ref, screen_range, source_end, source_start, start, target_end, target_start;
        source_start = this.source_range.start;
        source_end = this.source_range.end;
        target_start = this.target_range.start;
        target_end = this.target_range.end;
        screen_range = target_end - target_start;
        ref = this._get_safe_factor(source_start, source_end), start = ref[0], end = ref[1];
        if (start === 0) {
            inter_factor = Math.log(end);
            inter_offset = 0;
        } else {
            inter_factor = Math.log(end) - Math.log(start);
            inter_offset = Math.log(start);
        }
        factor = screen_range;
        offset = target_start;
        return [
            factor,
            offset,
            inter_factor,
            inter_offset
        ];
    };
    return LogScale;
}(scale_1.Scale);    
},
/* models/scales/scale */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var transforms_1 = require(233    /* ../transforms */);
var p = require(13    /* core/properties */);
exports.Scale = function (superClass) {
    extend(Scale, superClass);
    function Scale() {
        return Scale.__super__.constructor.apply(this, arguments);
    }
    Scale.internal({
        source_range: [p.Any],
        target_range: [p.Any]
    });
    Scale.prototype.map_to_target = function (x) {
        return this.compute(x);
    };
    Scale.prototype.v_map_to_target = function (xs) {
        return this.v_compute(xs);
    };
    Scale.prototype.map_from_target = function (xprime) {
        return this.invert(xprime);
    };
    Scale.prototype.v_map_from_target = function (xprimes) {
        return this.v_invert(xprimes);
    };
    return Scale;
}(transforms_1.Transform);    
},
/* models/sources/ajax_data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    }, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var remote_data_source_1 = require(173    /* ./remote_data_source */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.AjaxDataSource = function (superClass) {
    extend(AjaxDataSource, superClass);
    function AjaxDataSource() {
        this.get_data = bind(this.get_data, this);
        this.setup = bind(this.setup, this);
        this.destroy = bind(this.destroy, this);
        return AjaxDataSource.__super__.constructor.apply(this, arguments);
    }
    AjaxDataSource.prototype.type = 'AjaxDataSource';
    AjaxDataSource.define({
        mode: [
            p.String,
            'replace'
        ],
        content_type: [
            p.String,
            'application/json'
        ],
        http_headers: [
            p.Any,
            {}
        ],
        max_size: [p.Number],
        method: [
            p.String,
            'POST'
        ],
        if_modified: [
            p.Bool,
            false
        ]
    });
    AjaxDataSource.prototype.destroy = function () {
        if (this.interval != null) {
            return clearInterval(this.interval);
        }
    };
    AjaxDataSource.prototype.setup = function () {
        if (this.initialized == null) {
            this.initialized = true;
            this.get_data(this.mode);
            if (this.polling_interval) {
                return this.interval = setInterval(this.get_data, this.polling_interval, this.mode, this.max_size, this.if_modified);
            }
        }
    };
    AjaxDataSource.prototype.get_data = function (mode, max_size, if_modified) {
        var name, ref, value, xhr;
        if (max_size == null) {
            max_size = 0;
        }
        if (if_modified == null) {
            if_modified = false;
        }
        xhr = new XMLHttpRequest();
        xhr.open(this.method, this.data_url, true);
        xhr.withCredentials = false;
        xhr.setRequestHeader('Content-Type', this.content_type);
        ref = this.http_headers;
        for (name in ref) {
            value = ref[name];
            xhr.setRequestHeader(name, value);
        }
        xhr.addEventListener('load', function (_this) {
            return function () {
                var column, data, i, len, original_data, ref1;
                if (xhr.status === 200) {
                    data = JSON.parse(xhr.responseText);
                    switch (mode) {
                    case 'replace':
                        return _this.data = data;
                    case 'append':
                        original_data = _this.data;
                        ref1 = _this.columns();
                        for (i = 0, len = ref1.length; i < len; i++) {
                            column = ref1[i];
                            data[column] = original_data[column].concat(data[column]).slice(-max_size);
                        }
                        return _this.data = data;
                    }
                }
            };
        }(this));
        xhr.addEventListener('error', function (_this) {
            return function () {
                return logging_1.logger.error('Failed to fetch JSON from ' + _this.data_url + ' with code ' + xhr.status);
            };
        }(this));
        xhr.send();
        return null;
    };
    return AjaxDataSource;
}(remote_data_source_1.RemoteDataSource);    
},
/* models/sources/cds_view */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var columnar_data_source_1 = require(169    /* ./columnar_data_source */);
exports.CDSView = function (superClass) {
    extend(CDSView, superClass);
    function CDSView() {
        return CDSView.__super__.constructor.apply(this, arguments);
    }
    CDSView.prototype.type = 'CDSView';
    CDSView.prototype.initialize = function (options) {
        CDSView.__super__.initialize.call(this, options);
        return this.compute_indices();
    };
    CDSView.define({
        filters: [
            p.Array,
            []
        ],
        source: [p.Instance]
    });
    CDSView.internal({
        indices: [
            p.Array,
            []
        ],
        indices_map: [
            p.Any,
            {}
        ]
    });
    CDSView.prototype.connect_signals = function () {
        var ref, ref1, ref2;
        CDSView.__super__.connect_signals.call(this);
        this.connect(this.properties.filters.change, function () {
            this.compute_indices();
            return this.change.emit();
        });
        if (((ref = this.source) != null ? ref.change : void 0) != null) {
            this.connect(this.source.change, function () {
                return this.compute_indices();
            });
        }
        if (((ref1 = this.source) != null ? ref1.streaming : void 0) != null) {
            this.connect(this.source.streaming, function () {
                return this.compute_indices();
            });
        }
        if (((ref2 = this.source) != null ? ref2.patching : void 0) != null) {
            return this.connect(this.source.patching, function () {
                return this.compute_indices();
            });
        }
    };
    CDSView.prototype.compute_indices = function () {
        var filter, indices, inds, ref;
        indices = function () {
            var j, len, ref, results;
            ref = this.filters;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                filter = ref[j];
                results.push(filter.compute_indices(this.source));
            }
            return results;
        }.call(this);
        indices = function () {
            var j, len, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                inds = indices[j];
                if (inds != null) {
                    results.push(inds);
                }
            }
            return results;
        }();
        if (indices.length > 0) {
            this.indices = array_1.intersection.apply(this, indices);
        } else {
            if (this.source instanceof columnar_data_source_1.ColumnarDataSource) {
                this.indices = (ref = this.source) != null ? ref.get_indices() : void 0;
            }
        }
        return this.indices_map_to_subset();
    };
    CDSView.prototype.indices_map_to_subset = function () {
        var i, j, ref, results;
        this.indices_map = {};
        results = [];
        for (i = j = 0, ref = this.indices.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(this.indices_map[this.indices[i]] = i);
        }
        return results;
    };
    CDSView.prototype.convert_selection_from_subset = function (selection) {
        var i, indices_1d;
        indices_1d = function () {
            var j, len, ref, results;
            ref = selection['1d']['indices'];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                results.push(this.indices[i]);
            }
            return results;
        }.call(this);
        selection['1d']['indices'] = indices_1d;
        return selection;
    };
    CDSView.prototype.convert_selection_to_subset = function (selection) {
        var i, indices_1d;
        indices_1d = function () {
            var j, len, ref, results;
            ref = selection['1d']['indices'];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                results.push(this.indices_map[i]);
            }
            return results;
        }.call(this);
        selection['1d']['indices'] = indices_1d;
        return selection;
    };
    CDSView.prototype.convert_indices_from_subset = function (indices) {
        var i;
        return function () {
            var j, len, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                results.push(this.indices[i]);
            }
            return results;
        }.call(this);
    };
    return CDSView;
}(model_1.Model);    
},
/* models/sources/column_data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var columnar_data_source_1 = require(169    /* ./columnar_data_source */);
var has_props_1 = require(7    /* core/has_props */);
var p = require(13    /* core/properties */);
var data_structures_1 = require(25    /* core/util/data_structures */);
var serialization = require(33    /* core/util/serialization */);
var types_1 = require(40    /* core/util/types */);
exports.concat_typed_arrays = function (a, b) {
    var c;
    c = new a.constructor(a.length + b.length);
    c.set(a, 0);
    c.set(b, a.length);
    return c;
};
exports.stream_to_column = function (col, new_col, rollover) {
    var end, i, l, m, ref, ref1, ref2, start, tmp, total_len;
    if (col.concat != null) {
        col = col.concat(new_col);
        if (col.length > rollover) {
            col = col.slice(-rollover);
        }
        return col;
    }
    total_len = col.length + new_col.length;
    if (rollover != null && total_len > rollover) {
        start = total_len - rollover;
        end = col.length;
        if (col.length < rollover) {
            tmp = new col.constructor(rollover);
            tmp.set(col, 0);
            col = tmp;
        }
        for (i = l = ref = start, ref1 = end; ref <= ref1 ? l < ref1 : l > ref1; i = ref <= ref1 ? ++l : --l) {
            col[i - start] = col[i];
        }
        for (i = m = 0, ref2 = new_col.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
            col[i + (end - start)] = new_col[i];
        }
        return col;
    }
    tmp = new col.constructor(new_col);
    return exports.concat_typed_arrays(col, tmp);
};
exports.slice = function (ind, length) {
    var ref, ref1, ref2, ref3, start, step, stop;
    if (types_1.isObject(ind)) {
        return [
            (ref = ind.start) != null ? ref : 0,
            (ref1 = ind.stop) != null ? ref1 : length,
            (ref2 = ind.step) != null ? ref2 : 1
        ];
    }
    return ref3 = [
        ind,
        ind + 1,
        1
    ], start = ref3[0], stop = ref3[1], step = ref3[2], ref3;
};
exports.patch_to_column = function (col, patch, shapes) {
    var flat_index, i, ind, istart, istep, istop, item, j, jstart, jstep, jstop, l, len, m, n, patched, patched_range, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, shape, value;
    patched = new data_structures_1.Set();
    patched_range = false;
    for (l = 0, len = patch.length; l < len; l++) {
        ref = patch[l], ind = ref[0], value = ref[1];
        if (!types_1.isArray(ind)) {
            if (types_1.isNumber(ind)) {
                value = [value];
                patched.push(ind);
            } else {
                patched_range = true;
            }
            ind = [
                0,
                0,
                ind
            ];
            shape = [
                1,
                col.length
            ];
            item = col;
        } else {
            patched.push(ind[0]);
            shape = shapes[ind[0]];
            item = col[ind[0]];
        }
        if (ind.length === 2) {
            shape = [
                1,
                shape[0]
            ];
            ind = [
                ind[0],
                0,
                ind[1]
            ];
        }
        flat_index = 0;
        ref1 = exports.slice(ind[1], shape[0]), istart = ref1[0], istop = ref1[1], istep = ref1[2];
        ref2 = exports.slice(ind[2], shape[1]), jstart = ref2[0], jstop = ref2[1], jstep = ref2[2];
        for (i = m = ref3 = istart, ref4 = istop, ref5 = istep; ref5 > 0 ? m < ref4 : m > ref4; i = m += ref5) {
            for (j = n = ref6 = jstart, ref7 = jstop, ref8 = jstep; ref8 > 0 ? n < ref7 : n > ref7; j = n += ref8) {
                if (patched_range) {
                    patched.push(j);
                }
                item[i * shape[1] + j] = value[flat_index];
                flat_index++;
            }
        }
    }
    return patched;
};
exports.ColumnDataSource = function (superClass) {
    extend(ColumnDataSource, superClass);
    function ColumnDataSource() {
        return ColumnDataSource.__super__.constructor.apply(this, arguments);
    }
    ColumnDataSource.prototype.type = 'ColumnDataSource';
    ColumnDataSource.prototype.initialize = function (options) {
        var ref;
        ColumnDataSource.__super__.initialize.call(this, options);
        return ref = serialization.decode_column_data(this.data), this.data = ref[0], this._shapes = ref[1], ref;
    };
    ColumnDataSource.define({
        data: [
            p.Any,
            {}
        ]
    });
    ColumnDataSource.prototype.attributes_as_json = function (include_defaults, value_to_json) {
        var attrs, key, ref, value;
        if (include_defaults == null) {
            include_defaults = true;
        }
        if (value_to_json == null) {
            value_to_json = ColumnDataSource._value_to_json;
        }
        attrs = {};
        ref = this.serializable_attributes();
        for (key in ref) {
            if (!hasProp.call(ref, key))
                continue;
            value = ref[key];
            if (key === 'data') {
                value = serialization.encode_column_data(value, this._shapes);
            }
            if (include_defaults) {
                attrs[key] = value;
            } else if (key in this._set_after_defaults) {
                attrs[key] = value;
            }
        }
        return value_to_json('attributes', attrs, this);
    };
    ColumnDataSource._value_to_json = function (key, value, optional_parent_object) {
        if (types_1.isObject(value) && key === 'data') {
            return serialization.encode_column_data(value, optional_parent_object._shapes);
        } else {
            return has_props_1.HasProps._value_to_json(key, value, optional_parent_object);
        }
    };
    ColumnDataSource.prototype.stream = function (new_data, rollover) {
        var data, k, v;
        data = this.data;
        for (k in new_data) {
            v = new_data[k];
            data[k] = exports.stream_to_column(data[k], new_data[k], rollover);
        }
        this.setv('data', data, { silent: true });
        return this.streaming.emit();
    };
    ColumnDataSource.prototype.patch = function (patches) {
        var data, k, patch, patched;
        data = this.data;
        patched = new data_structures_1.Set();
        for (k in patches) {
            patch = patches[k];
            patched = patched.union(exports.patch_to_column(data[k], patch, this._shapes[k]));
        }
        this.setv('data', data, { silent: true });
        return this.patching.emit(patched.values);
    };
    return ColumnDataSource;
}(columnar_data_source_1.ColumnarDataSource);    
},
/* models/sources/columnar_data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var data_source_1 = require(170    /* ./data_source */);
var signaling_1 = require(18    /* core/signaling */);
var logging_1 = require(12    /* core/logging */);
var selection_manager_1 = require(15    /* core/selection_manager */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.ColumnarDataSource = function (superClass) {
    extend(ColumnarDataSource, superClass);
    function ColumnarDataSource() {
        return ColumnarDataSource.__super__.constructor.apply(this, arguments);
    }
    ColumnarDataSource.prototype.type = 'ColumnarDataSource';
    ColumnarDataSource.define({
        column_names: [
            p.Array,
            []
        ]
    });
    ColumnarDataSource.internal({
        selection_manager: [
            p.Instance,
            function (self) {
                return new selection_manager_1.SelectionManager({ source: self });
            }
        ],
        inspected: [p.Any],
        _shapes: [
            p.Any,
            {}
        ]
    });
    ColumnarDataSource.prototype.initialize = function (options) {
        ColumnarDataSource.__super__.initialize.call(this, options);
        this.select = new signaling_1.Signal(this, 'select');
        this.inspect = new signaling_1.Signal(this, 'inspect');
        this.streaming = new signaling_1.Signal(this, 'streaming');
        return this.patching = new signaling_1.Signal(this, 'patching');
    };
    ColumnarDataSource.prototype.get_column = function (colname) {
        var ref;
        return (ref = this.data[colname]) != null ? ref : null;
    };
    ColumnarDataSource.prototype.columns = function () {
        return Object.keys(this.data);
    };
    ColumnarDataSource.prototype.get_length = function (soft) {
        var _key, lengths, msg, val;
        if (soft == null) {
            soft = true;
        }
        lengths = array_1.uniq(function () {
            var ref, results;
            ref = this.data;
            results = [];
            for (_key in ref) {
                val = ref[_key];
                results.push(val.length);
            }
            return results;
        }.call(this));
        switch (lengths.length) {
        case 0:
            return null;
        case 1:
            return lengths[0];
        default:
            msg = 'data source has columns of inconsistent lengths';
            if (soft) {
                logging_1.logger.warn(msg);
                return lengths.sort()[0];
            } else {
                throw new Error(msg);
            }
        }
    };
    ColumnarDataSource.prototype.get_indices = function () {
        var i, length, results;
        length = this.get_length();
        if (length == null) {
            length = 1;
        }
        return function () {
            results = [];
            for (var i = 0; 0 <= length ? i < length : i > length; 0 <= length ? i++ : i--) {
                results.push(i);
            }
            return results;
        }.apply(this);
    };
    return ColumnarDataSource;
}(data_source_1.DataSource);    
},
/* models/sources/data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var hittest = require(8    /* core/hittest */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.DataSource = function (superClass) {
    extend(DataSource, superClass);
    function DataSource() {
        return DataSource.__super__.constructor.apply(this, arguments);
    }
    DataSource.prototype.type = 'DataSource';
    DataSource.define({
        selected: [
            p.Any,
            hittest.create_hit_test_result()
        ],
        callback: [p.Any]
    });
    DataSource.prototype.initialize = function (options) {
        DataSource.__super__.initialize.call(this, options);
        return this.connect(this.properties.selected.change, function (_this) {
            return function () {
                var callback;
                callback = _this.callback;
                if (callback != null) {
                    if (types_1.isFunction(callback)) {
                        return callback(_this);
                    } else {
                        return callback.execute(_this);
                    }
                }
            };
        }(this));
    };
    return DataSource;
}(model_1.Model);    
},
/* models/sources/geojson_data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var columnar_data_source_1 = require(169    /* ./columnar_data_source */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.GeoJSONDataSource = function (superClass) {
    extend(GeoJSONDataSource, superClass);
    function GeoJSONDataSource() {
        return GeoJSONDataSource.__super__.constructor.apply(this, arguments);
    }
    GeoJSONDataSource.prototype.type = 'GeoJSONDataSource';
    GeoJSONDataSource.define({ geojson: [p.Any] });
    GeoJSONDataSource.internal({
        data: [
            p.Any,
            {}
        ]
    });
    GeoJSONDataSource.prototype.initialize = function (options) {
        GeoJSONDataSource.__super__.initialize.call(this, options);
        this._update_data();
        return this.connect(this.properties.geojson.change, function (_this) {
            return function () {
                return _this._update_data();
            };
        }(this));
    };
    GeoJSONDataSource.prototype._update_data = function () {
        return this.data = this.geojson_to_column_data();
    };
    GeoJSONDataSource.prototype._get_new_list_array = function (length) {
        var i, k, ref, results;
        results = [];
        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            results.push([]);
        }
        return results;
    };
    GeoJSONDataSource.prototype._get_new_nan_array = function (length) {
        var i, k, ref, results;
        results = [];
        for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            results.push(0 / 0);
        }
        return results;
    };
    GeoJSONDataSource.prototype._flatten_function = function (accumulator, currentItem) {
        return accumulator.concat([[
                0 / 0,
                0 / 0,
                0 / 0
            ]]).concat(currentItem);
    };
    GeoJSONDataSource.prototype._add_properties = function (item, data, i, item_count) {
        var property, results;
        results = [];
        for (property in item.properties) {
            if (!data.hasOwnProperty(property)) {
                data[property] = this._get_new_nan_array(item_count);
            }
            results.push(data[property][i] = item.properties[property]);
        }
        return results;
    };
    GeoJSONDataSource.prototype._add_geometry = function (geometry, data, i) {
        var coord_list, coords, exterior_ring, exterior_rings, flattened_coord_list, j, k, l, len, len1, len2, len3, len4, m, n, o, polygon, ref, ref1, ref2, ref3, ref4, ref5, results, results1, results2, results3;
        switch (geometry.type) {
        case 'Point':
            coords = geometry.coordinates;
            data.x[i] = coords[0];
            data.y[i] = coords[1];
            return data.z[i] = (ref = coords[2]) != null ? ref : 0 / 0;
        case 'LineString':
            coord_list = geometry.coordinates;
            results = [];
            for (j = k = 0, len = coord_list.length; k < len; j = ++k) {
                coords = coord_list[j];
                data.xs[i][j] = coords[0];
                data.ys[i][j] = coords[1];
                results.push(data.zs[i][j] = (ref1 = coords[2]) != null ? ref1 : 0 / 0);
            }
            return results;
            break;
        case 'Polygon':
            if (geometry.coordinates.length > 1) {
                logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');
            }
            exterior_ring = geometry.coordinates[0];
            results1 = [];
            for (j = l = 0, len1 = exterior_ring.length; l < len1; j = ++l) {
                coords = exterior_ring[j];
                data.xs[i][j] = coords[0];
                data.ys[i][j] = coords[1];
                results1.push(data.zs[i][j] = (ref2 = coords[2]) != null ? ref2 : 0 / 0);
            }
            return results1;
            break;
        case 'MultiPoint':
            return logging_1.logger.warn('MultiPoint not supported in Bokeh');
        case 'MultiLineString':
            flattened_coord_list = geometry.coordinates.reduce(this._flatten_function);
            results2 = [];
            for (j = m = 0, len2 = flattened_coord_list.length; m < len2; j = ++m) {
                coords = flattened_coord_list[j];
                data.xs[i][j] = coords[0];
                data.ys[i][j] = coords[1];
                results2.push(data.zs[i][j] = (ref3 = coords[2]) != null ? ref3 : 0 / 0);
            }
            return results2;
            break;
        case 'MultiPolygon':
            exterior_rings = [];
            ref4 = geometry.coordinates;
            for (n = 0, len3 = ref4.length; n < len3; n++) {
                polygon = ref4[n];
                if (polygon.length > 1) {
                    logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');
                }
                exterior_rings.push(polygon[0]);
            }
            flattened_coord_list = exterior_rings.reduce(this._flatten_function);
            results3 = [];
            for (j = o = 0, len4 = flattened_coord_list.length; o < len4; j = ++o) {
                coords = flattened_coord_list[j];
                data.xs[i][j] = coords[0];
                data.ys[i][j] = coords[1];
                results3.push(data.zs[i][j] = (ref5 = coords[2]) != null ? ref5 : 0 / 0);
            }
            return results3;
            break;
        default:
            throw new Error('Invalid type ' + geometry.type);
        }
    };
    GeoJSONDataSource.prototype._get_items_length = function (items) {
        var count, g, geometry, i, item, j, k, l, len, len1, ref;
        count = 0;
        for (i = k = 0, len = items.length; k < len; i = ++k) {
            item = items[i];
            geometry = item.type === 'Feature' ? item.geometry : item;
            if (geometry.type === 'GeometryCollection') {
                ref = geometry.geometries;
                for (j = l = 0, len1 = ref.length; l < len1; j = ++l) {
                    g = ref[j];
                    count += 1;
                }
            } else {
                count += 1;
            }
        }
        return count;
    };
    GeoJSONDataSource.prototype.geojson_to_column_data = function () {
        var arr_index, data, g, geojson, geometry, i, item, item_count, items, j, k, l, len, len1, ref, ref1;
        geojson = JSON.parse(this.geojson);
        if ((ref = geojson.type) !== 'GeometryCollection' && ref !== 'FeatureCollection') {
            throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');
        }
        if (geojson.type === 'GeometryCollection') {
            if (geojson.geometries == null) {
                throw new Error('No geometries found in GeometryCollection');
            }
            if (geojson.geometries.length === 0) {
                throw new Error('geojson.geometries must have one or more items');
            }
            items = geojson.geometries;
        }
        if (geojson.type === 'FeatureCollection') {
            if (geojson.features == null) {
                throw new Error('No features found in FeaturesCollection');
            }
            if (geojson.features.length === 0) {
                throw new Error('geojson.features must have one or more items');
            }
            items = geojson.features;
        }
        item_count = this._get_items_length(items);
        data = {
            'x': this._get_new_nan_array(item_count),
            'y': this._get_new_nan_array(item_count),
            'z': this._get_new_nan_array(item_count),
            'xs': this._get_new_list_array(item_count),
            'ys': this._get_new_list_array(item_count),
            'zs': this._get_new_list_array(item_count)
        };
        arr_index = 0;
        for (i = k = 0, len = items.length; k < len; i = ++k) {
            item = items[i];
            geometry = item.type === 'Feature' ? item.geometry : item;
            if (geometry.type === 'GeometryCollection') {
                ref1 = geometry.geometries;
                for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {
                    g = ref1[j];
                    this._add_geometry(g, data, arr_index);
                    if (item.type === 'Feature') {
                        this._add_properties(item, data, arr_index, item_count);
                    }
                    arr_index += 1;
                }
            } else {
                this._add_geometry(geometry, data, arr_index);
                if (item.type === 'Feature') {
                    this._add_properties(item, data, arr_index, item_count);
                }
                arr_index += 1;
            }
        }
        return data;
    };
    return GeoJSONDataSource;
}(columnar_data_source_1.ColumnarDataSource);    
},
/* models/sources/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ajax_data_source_1 = require(166    /* ./ajax_data_source */);
exports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;
var column_data_source_1 = require(168    /* ./column_data_source */);
exports.ColumnDataSource = column_data_source_1.ColumnDataSource;
var columnar_data_source_1 = require(169    /* ./columnar_data_source */);
exports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;
var cds_view_1 = require(167    /* ./cds_view */);
exports.CDSView = cds_view_1.CDSView;
var data_source_1 = require(170    /* ./data_source */);
exports.DataSource = data_source_1.DataSource;
var geojson_data_source_1 = require(171    /* ./geojson_data_source */);
exports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;
var remote_data_source_1 = require(173    /* ./remote_data_source */);
exports.RemoteDataSource = remote_data_source_1.RemoteDataSource;    
},
/* models/sources/remote_data_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var column_data_source_1 = require(168    /* ./column_data_source */);
var p = require(13    /* core/properties */);
exports.RemoteDataSource = function (superClass) {
    extend(RemoteDataSource, superClass);
    function RemoteDataSource() {
        return RemoteDataSource.__super__.constructor.apply(this, arguments);
    }
    RemoteDataSource.prototype.type = 'RemoteDataSource';
    RemoteDataSource.define({
        data_url: [p.String],
        polling_interval: [p.Number]
    });
    return RemoteDataSource;
}(column_data_source_1.ColumnDataSource);    
},
/* models/tickers/adaptive_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var clamp, log, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var continuous_ticker_1 = require(178    /* ./continuous_ticker */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
clamp = function (x, min_val, max_val) {
    return Math.max(min_val, Math.min(max_val, x));
};
log = function (x, base) {
    if (base == null) {
        base = Math.E;
    }
    return Math.log(x) / Math.log(base);
};
exports.AdaptiveTicker = function (superClass) {
    extend(AdaptiveTicker, superClass);
    function AdaptiveTicker() {
        return AdaptiveTicker.__super__.constructor.apply(this, arguments);
    }
    AdaptiveTicker.prototype.type = 'AdaptiveTicker';
    AdaptiveTicker.define({
        base: [
            p.Number,
            10
        ],
        mantissas: [
            p.Array,
            [
                1,
                2,
                5
            ]
        ],
        min_interval: [
            p.Number,
            0
        ],
        max_interval: [p.Number]
    });
    AdaptiveTicker.prototype.initialize = function (attrs, options) {
        var prefix_mantissa, suffix_mantissa;
        AdaptiveTicker.__super__.initialize.call(this, attrs, options);
        prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;
        suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;
        this.extended_mantissas = [prefix_mantissa].concat(slice.call(this.mantissas), [suffix_mantissa]);
        return this.base_factor = this.get_min_interval() === 0 ? 1 : this.get_min_interval();
    };
    AdaptiveTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {
        var best_mantissa, candidate_mantissas, data_range, errors, ideal_interval, ideal_magnitude, ideal_mantissa, interval, interval_exponent;
        data_range = data_high - data_low;
        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
        interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));
        ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor;
        ideal_mantissa = ideal_interval / ideal_magnitude;
        candidate_mantissas = this.extended_mantissas;
        errors = candidate_mantissas.map(function (mantissa) {
            return Math.abs(desired_n_ticks - data_range / (mantissa * ideal_magnitude));
        });
        best_mantissa = candidate_mantissas[array_1.argmin(errors)];
        interval = best_mantissa * ideal_magnitude;
        return clamp(interval, this.get_min_interval(), this.get_max_interval());
    };
    return AdaptiveTicker;
}(continuous_ticker_1.ContinuousTicker);    
},
/* models/tickers/basic_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var adaptive_ticker_1 = require(174    /* ./adaptive_ticker */);
exports.BasicTicker = function (superClass) {
    extend(BasicTicker, superClass);
    function BasicTicker() {
        return BasicTicker.__super__.constructor.apply(this, arguments);
    }
    BasicTicker.prototype.type = 'BasicTicker';
    return BasicTicker;
}(adaptive_ticker_1.AdaptiveTicker);    
},
/* models/tickers/categorical_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var ticker_1 = require(187    /* ./ticker */);
exports.CategoricalTicker = function (superClass) {
    extend(CategoricalTicker, superClass);
    function CategoricalTicker() {
        return CategoricalTicker.__super__.constructor.apply(this, arguments);
    }
    CategoricalTicker.prototype.type = 'CategoricalTicker';
    CategoricalTicker.prototype.get_ticks = function (start, end, range, cross_loc, arg) {
        var desired_n_ticks, majors, mids, ref, ref1, tops;
        desired_n_ticks = arg.desired_n_ticks;
        majors = this._collect(range.factors, range, start, end);
        tops = this._collect((ref = range.tops) != null ? ref : [], range, start, end);
        mids = this._collect((ref1 = range.mids) != null ? ref1 : [], range, start, end);
        return {
            major: majors,
            tops: tops,
            mids: mids,
            minor: []
        };
    };
    CategoricalTicker.prototype._collect = function (factors, range, start, end) {
        var coord, f, i, len, result;
        result = [];
        for (i = 0, len = factors.length; i < len; i++) {
            f = factors[i];
            coord = range.synthetic(f);
            if (coord > start && coord < end) {
                result.push(f);
            }
        }
        return result;
    };
    return CategoricalTicker;
}(ticker_1.Ticker);    
},
/* models/tickers/composite_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var continuous_ticker_1 = require(178    /* ./continuous_ticker */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var object_1 = require(28    /* core/util/object */);
exports.CompositeTicker = function (superClass) {
    extend(CompositeTicker, superClass);
    function CompositeTicker() {
        return CompositeTicker.__super__.constructor.apply(this, arguments);
    }
    CompositeTicker.prototype.type = 'CompositeTicker';
    CompositeTicker.define({
        tickers: [
            p.Array,
            []
        ]
    });
    CompositeTicker.getters({
        min_intervals: function () {
            var i, len, ref, results, ticker;
            ref = this.tickers;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                ticker = ref[i];
                results.push(ticker.get_min_interval());
            }
            return results;
        },
        max_intervals: function () {
            var i, len, ref, results, ticker;
            ref = this.tickers;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                ticker = ref[i];
                results.push(ticker.get_max_interval());
            }
            return results;
        },
        min_interval: function () {
            return this.min_intervals[0];
        },
        max_interval: function () {
            return this.max_intervals[0];
        }
    });
    CompositeTicker.prototype.get_best_ticker = function (data_low, data_high, desired_n_ticks) {
        var best_index, best_ticker, best_ticker_ndx, data_range, errors, ideal_interval, intervals, ticker_ndxs;
        data_range = data_high - data_low;
        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
        ticker_ndxs = [
            array_1.sortedIndex(this.min_intervals, ideal_interval) - 1,
            array_1.sortedIndex(this.max_intervals, ideal_interval)
        ];
        intervals = [
            this.min_intervals[ticker_ndxs[0]],
            this.max_intervals[ticker_ndxs[1]]
        ];
        errors = intervals.map(function (interval) {
            return Math.abs(desired_n_ticks - data_range / interval);
        });
        if (object_1.isEmpty(errors.filter(function (e) {
                return !isNaN(e);
            }))) {
            best_ticker = this.tickers[0];
        } else {
            best_index = array_1.argmin(errors);
            best_ticker_ndx = ticker_ndxs[best_index];
            best_ticker = this.tickers[best_ticker_ndx];
        }
        return best_ticker;
    };
    CompositeTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {
        var best_ticker;
        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
        return best_ticker.get_interval(data_low, data_high, desired_n_ticks);
    };
    CompositeTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var best_ticker, ticks;
        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
        ticks = best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);
        return ticks;
    };
    return CompositeTicker;
}(continuous_ticker_1.ContinuousTicker);    
},
/* models/tickers/continuous_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var ticker_1 = require(187    /* ./ticker */);
var p = require(13    /* core/properties */);
exports.ContinuousTicker = function (superClass) {
    extend(ContinuousTicker, superClass);
    function ContinuousTicker() {
        return ContinuousTicker.__super__.constructor.apply(this, arguments);
    }
    ContinuousTicker.prototype.type = 'ContinuousTicker';
    ContinuousTicker.define({
        num_minor_ticks: [
            p.Number,
            5
        ],
        desired_num_ticks: [
            p.Number,
            6
        ]
    });
    ContinuousTicker.prototype.get_interval = void 0;
    ContinuousTicker.prototype.get_min_interval = function () {
        return this.min_interval;
    };
    ContinuousTicker.prototype.get_max_interval = function () {
        var ref;
        return (ref = this.max_interval) != null ? ref : 1e+400;
    };
    ContinuousTicker.prototype.get_ideal_interval = function (data_low, data_high, desired_n_ticks) {
        var data_range;
        data_range = data_high - data_low;
        return data_range / desired_n_ticks;
    };
    return ContinuousTicker;
}(ticker_1.Ticker);    
},
/* models/tickers/datetime_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ONE_HOUR, ONE_MILLI, ONE_MINUTE, ONE_MONTH, ONE_SECOND, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var array_1 = require(20    /* core/util/array */);
var adaptive_ticker_1 = require(174    /* ./adaptive_ticker */);
var composite_ticker_1 = require(177    /* ./composite_ticker */);
var days_ticker_1 = require(180    /* ./days_ticker */);
var months_ticker_1 = require(185    /* ./months_ticker */);
var years_ticker_1 = require(189    /* ./years_ticker */);
var util = require(188    /* ./util */);
ONE_MILLI = util.ONE_MILLI;
ONE_SECOND = util.ONE_SECOND;
ONE_MINUTE = util.ONE_MINUTE;
ONE_HOUR = util.ONE_HOUR;
ONE_MONTH = util.ONE_MONTH;
exports.DatetimeTicker = function (superClass) {
    extend(DatetimeTicker, superClass);
    function DatetimeTicker() {
        return DatetimeTicker.__super__.constructor.apply(this, arguments);
    }
    DatetimeTicker.prototype.type = 'DatetimeTicker';
    DatetimeTicker.override({
        num_minor_ticks: 0,
        tickers: function () {
            return [
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        5
                    ],
                    base: 10,
                    min_interval: 0,
                    max_interval: 500 * ONE_MILLI,
                    num_minor_ticks: 0
                }),
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        5,
                        10,
                        15,
                        20,
                        30
                    ],
                    base: 60,
                    min_interval: ONE_SECOND,
                    max_interval: 30 * ONE_MINUTE,
                    num_minor_ticks: 0
                }),
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        4,
                        6,
                        8,
                        12
                    ],
                    base: 24,
                    min_interval: ONE_HOUR,
                    max_interval: 12 * ONE_HOUR,
                    num_minor_ticks: 0
                }),
                new days_ticker_1.DaysTicker({ days: array_1.range(1, 32) }),
                new days_ticker_1.DaysTicker({ days: array_1.range(1, 31, 3) }),
                new days_ticker_1.DaysTicker({
                    days: [
                        1,
                        8,
                        15,
                        22
                    ]
                }),
                new days_ticker_1.DaysTicker({
                    days: [
                        1,
                        15
                    ]
                }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 1) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 2) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 4) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 6) }),
                new years_ticker_1.YearsTicker({})
            ];
        }
    });
    return DatetimeTicker;
}(composite_ticker_1.CompositeTicker);    
},
/* models/tickers/days_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ONE_DAY, copy_date, date_range_by_month, last_month_no_later_than, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var single_interval_ticker_1 = require(186    /* ./single_interval_ticker */);
var util = require(188    /* ./util */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
copy_date = util.copy_date;
last_month_no_later_than = util.last_month_no_later_than;
ONE_DAY = util.ONE_DAY;
date_range_by_month = function (start_time, end_time) {
    var date, dates, end_date, prev_end_date, start_date;
    start_date = last_month_no_later_than(new Date(start_time));
    end_date = last_month_no_later_than(new Date(end_time));
    prev_end_date = copy_date(end_date);
    end_date.setUTCMonth(end_date.getUTCMonth() + 1);
    dates = [];
    date = start_date;
    while (true) {
        dates.push(copy_date(date));
        date.setUTCMonth(date.getUTCMonth() + 1);
        if (date > end_date) {
            break;
        }
    }
    return dates;
};
exports.DaysTicker = function (superClass) {
    extend(DaysTicker, superClass);
    function DaysTicker() {
        return DaysTicker.__super__.constructor.apply(this, arguments);
    }
    DaysTicker.prototype.type = 'DaysTicker';
    DaysTicker.define({
        days: [
            p.Array,
            []
        ]
    });
    DaysTicker.prototype.initialize = function (attrs, options) {
        var days, interval;
        attrs.num_minor_ticks = 0;
        DaysTicker.__super__.initialize.call(this, attrs, options);
        days = this.days;
        interval = days.length > 1 ? (days[1] - days[0]) * ONE_DAY : 31 * ONE_DAY;
        return this.interval = interval;
    };
    DaysTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var all_ticks, date, day_date, day_dates, days, days_of_month, interval, month_dates, ticks_in_range;
        month_dates = date_range_by_month(data_low, data_high);
        days = this.days;
        days_of_month = function (_this) {
            return function (month_date, interval) {
                var dates, day, day_date, future_date, i, len;
                dates = [];
                for (i = 0, len = days.length; i < len; i++) {
                    day = days[i];
                    day_date = copy_date(month_date);
                    day_date.setUTCDate(day);
                    future_date = new Date(day_date.getTime() + interval / 2);
                    if (future_date.getUTCMonth() === month_date.getUTCMonth()) {
                        dates.push(day_date);
                    }
                }
                return dates;
            };
        }(this);
        interval = this.interval;
        day_dates = array_1.concat(function () {
            var i, len, results;
            results = [];
            for (i = 0, len = month_dates.length; i < len; i++) {
                date = month_dates[i];
                results.push(days_of_month(date, interval));
            }
            return results;
        }());
        all_ticks = function () {
            var i, len, results;
            results = [];
            for (i = 0, len = day_dates.length; i < len; i++) {
                day_date = day_dates[i];
                results.push(day_date.getTime());
            }
            return results;
        }();
        ticks_in_range = all_ticks.filter(function (tick) {
            return data_low <= tick && tick <= data_high;
        });
        return {
            'major': ticks_in_range,
            'minor': []
        };
    };
    return DaysTicker;
}(single_interval_ticker_1.SingleIntervalTicker);    
},
/* models/tickers/fixed_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var continuous_ticker_1 = require(178    /* ./continuous_ticker */);
var p = require(13    /* core/properties */);
exports.FixedTicker = function (superClass) {
    extend(FixedTicker, superClass);
    function FixedTicker() {
        return FixedTicker.__super__.constructor.apply(this, arguments);
    }
    FixedTicker.prototype.type = 'FixedTicker';
    FixedTicker.define({
        ticks: [
            p.Array,
            []
        ]
    });
    FixedTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        return {
            major: this.ticks,
            minor: []
        };
    };
    return FixedTicker;
}(continuous_ticker_1.ContinuousTicker);    
},
/* models/tickers/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var adaptive_ticker_1 = require(174    /* ./adaptive_ticker */);
exports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;
var basic_ticker_1 = require(175    /* ./basic_ticker */);
exports.BasicTicker = basic_ticker_1.BasicTicker;
var categorical_ticker_1 = require(176    /* ./categorical_ticker */);
exports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;
var composite_ticker_1 = require(177    /* ./composite_ticker */);
exports.CompositeTicker = composite_ticker_1.CompositeTicker;
var continuous_ticker_1 = require(178    /* ./continuous_ticker */);
exports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;
var datetime_ticker_1 = require(179    /* ./datetime_ticker */);
exports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;
var days_ticker_1 = require(180    /* ./days_ticker */);
exports.DaysTicker = days_ticker_1.DaysTicker;
var fixed_ticker_1 = require(181    /* ./fixed_ticker */);
exports.FixedTicker = fixed_ticker_1.FixedTicker;
var log_ticker_1 = require(183    /* ./log_ticker */);
exports.LogTicker = log_ticker_1.LogTicker;
var mercator_ticker_1 = require(184    /* ./mercator_ticker */);
exports.MercatorTicker = mercator_ticker_1.MercatorTicker;
var months_ticker_1 = require(185    /* ./months_ticker */);
exports.MonthsTicker = months_ticker_1.MonthsTicker;
var single_interval_ticker_1 = require(186    /* ./single_interval_ticker */);
exports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;
var ticker_1 = require(187    /* ./ticker */);
exports.Ticker = ticker_1.Ticker;
var years_ticker_1 = require(189    /* ./years_ticker */);
exports.YearsTicker = years_ticker_1.YearsTicker;    
},
/* models/tickers/log_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var array_1 = require(20    /* core/util/array */);
var adaptive_ticker_1 = require(174    /* ./adaptive_ticker */);
exports.LogTicker = function (superClass) {
    extend(LogTicker, superClass);
    function LogTicker() {
        return LogTicker.__super__.constructor.apply(this, arguments);
    }
    LogTicker.prototype.type = 'LogTicker';
    LogTicker.override({
        mantissas: [
            1,
            5
        ]
    });
    LogTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var base, end_factor, endlog, factor, factors, i, interval, j, k, l, len, len1, len2, len3, len4, len5, log_high, log_interval, log_low, m, minor_interval, minor_offsets, minor_ticks, n, num_minor_ticks, o, ref, start_factor, startlog, tick, ticks, x;
        num_minor_ticks = this.num_minor_ticks;
        minor_ticks = [];
        base = this.base;
        log_low = Math.log(data_low) / Math.log(base);
        log_high = Math.log(data_high) / Math.log(base);
        log_interval = log_high - log_low;
        if (!isFinite(log_interval)) {
            ticks = [];
        } else if (log_interval < 2) {
            interval = this.get_interval(data_low, data_high, desired_n_ticks);
            start_factor = Math.floor(data_low / interval);
            end_factor = Math.ceil(data_high / interval);
            factors = array_1.range(start_factor, end_factor + 1);
            ticks = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = factors.length; j < len; j++) {
                    factor = factors[j];
                    if (factor !== 0) {
                        results.push(factor * interval);
                    }
                }
                return results;
            }();
            ticks = ticks.filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            if (num_minor_ticks > 0 && ticks.length > 0) {
                minor_interval = interval / num_minor_ticks;
                minor_offsets = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = num_minor_ticks; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(i * minor_interval);
                    }
                    return results;
                }();
                ref = minor_offsets.slice(1, +minor_offsets.length + 1 || 9000000000);
                for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    minor_ticks.push(ticks[0] - x);
                }
                for (k = 0, len1 = ticks.length; k < len1; k++) {
                    tick = ticks[k];
                    for (l = 0, len2 = minor_offsets.length; l < len2; l++) {
                        x = minor_offsets[l];
                        minor_ticks.push(tick + x);
                    }
                }
            }
        } else {
            startlog = Math.ceil(log_low * 0.999999);
            endlog = Math.floor(log_high * 1.000001);
            interval = Math.ceil((endlog - startlog) / 9);
            ticks = array_1.range(startlog, endlog + 1, interval);
            ticks = ticks.map(function (i) {
                return Math.pow(base, i);
            });
            ticks = ticks.filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            if (num_minor_ticks > 0 && ticks.length > 0) {
                minor_interval = Math.pow(base, interval) / num_minor_ticks;
                minor_offsets = function () {
                    var m, ref1, results;
                    results = [];
                    for (i = m = 1, ref1 = num_minor_ticks; 1 <= ref1 ? m <= ref1 : m >= ref1; i = 1 <= ref1 ? ++m : --m) {
                        results.push(i * minor_interval);
                    }
                    return results;
                }();
                for (m = 0, len3 = minor_offsets.length; m < len3; m++) {
                    x = minor_offsets[m];
                    minor_ticks.push(ticks[0] / x);
                }
                minor_ticks.push(ticks[0]);
                for (n = 0, len4 = ticks.length; n < len4; n++) {
                    tick = ticks[n];
                    for (o = 0, len5 = minor_offsets.length; o < len5; o++) {
                        x = minor_offsets[o];
                        minor_ticks.push(tick * x);
                    }
                }
            }
        }
        return {
            major: ticks,
            minor: minor_ticks
        };
    };
    return LogTicker;
}(adaptive_ticker_1.AdaptiveTicker);    
},
/* models/tickers/mercator_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var basic_ticker_1 = require(175    /* ./basic_ticker */);
var p = require(13    /* core/properties */);
var proj4_1 = require(29    /* core/util/proj4 */);
exports.MercatorTicker = function (superClass) {
    extend(MercatorTicker, superClass);
    function MercatorTicker() {
        return MercatorTicker.__super__.constructor.apply(this, arguments);
    }
    MercatorTicker.prototype.type = 'MercatorTicker';
    MercatorTicker.define({ dimension: [p.LatLon] });
    MercatorTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var _, i, j, k, l, lat, len, len1, len2, len3, lon, proj_cross_loc, proj_high, proj_low, proj_ticks, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tick, ticks;
        if (this.dimension == null) {
            throw new Error('MercatorTicker.dimension not configured');
        }
        if (this.dimension === 'lon') {
            ref = proj4_1.proj4(proj4_1.mercator).inverse([
                data_low,
                cross_loc
            ]), proj_low = ref[0], proj_cross_loc = ref[1];
            ref1 = proj4_1.proj4(proj4_1.mercator).inverse([
                data_high,
                cross_loc
            ]), proj_high = ref1[0], proj_cross_loc = ref1[1];
        } else {
            ref2 = proj4_1.proj4(proj4_1.mercator).inverse([
                cross_loc,
                data_low
            ]), proj_cross_loc = ref2[0], proj_low = ref2[1];
            ref3 = proj4_1.proj4(proj4_1.mercator).inverse([
                cross_loc,
                data_high
            ]), proj_cross_loc = ref3[0], proj_high = ref3[1];
        }
        proj_ticks = MercatorTicker.__super__.get_ticks_no_defaults.call(this, proj_low, proj_high, cross_loc, desired_n_ticks);
        ticks = {
            major: [],
            minor: []
        };
        if (this.dimension === 'lon') {
            ref4 = proj_ticks.major;
            for (i = 0, len = ref4.length; i < len; i++) {
                tick = ref4[i];
                ref5 = proj4_1.proj4(proj4_1.mercator).forward([
                    tick,
                    proj_cross_loc
                ]), lon = ref5[0], _ = ref5[1];
                ticks.major.push(lon);
            }
            ref6 = proj_ticks.minor;
            for (j = 0, len1 = ref6.length; j < len1; j++) {
                tick = ref6[j];
                ref7 = proj4_1.proj4(proj4_1.mercator).forward([
                    tick,
                    proj_cross_loc
                ]), lon = ref7[0], _ = ref7[1];
                ticks.minor.push(lon);
            }
        } else {
            ref8 = proj_ticks.major;
            for (k = 0, len2 = ref8.length; k < len2; k++) {
                tick = ref8[k];
                ref9 = proj4_1.proj4(proj4_1.mercator).forward([
                    proj_cross_loc,
                    tick
                ]), _ = ref9[0], lat = ref9[1];
                ticks.major.push(lat);
            }
            ref10 = proj_ticks.minor;
            for (l = 0, len3 = ref10.length; l < len3; l++) {
                tick = ref10[l];
                ref11 = proj4_1.proj4(proj4_1.mercator).forward([
                    proj_cross_loc,
                    tick
                ]), _ = ref11[0], lat = ref11[1];
                ticks.minor.push(lat);
            }
        }
        return ticks;
    };
    return MercatorTicker;
}(basic_ticker_1.BasicTicker);    
},
/* models/tickers/months_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ONE_MONTH, copy_date, date_range_by_year, last_year_no_later_than, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var single_interval_ticker_1 = require(186    /* ./single_interval_ticker */);
var util = require(188    /* ./util */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
copy_date = util.copy_date;
last_year_no_later_than = util.last_year_no_later_than;
ONE_MONTH = util.ONE_MONTH;
date_range_by_year = function (start_time, end_time) {
    var date, dates, end_date, start_date;
    start_date = last_year_no_later_than(new Date(start_time));
    end_date = last_year_no_later_than(new Date(end_time));
    end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);
    dates = [];
    date = start_date;
    while (true) {
        dates.push(copy_date(date));
        date.setUTCFullYear(date.getUTCFullYear() + 1);
        if (date > end_date) {
            break;
        }
    }
    return dates;
};
exports.MonthsTicker = function (superClass) {
    extend(MonthsTicker, superClass);
    function MonthsTicker() {
        return MonthsTicker.__super__.constructor.apply(this, arguments);
    }
    MonthsTicker.prototype.type = 'MonthsTicker';
    MonthsTicker.define({
        months: [
            p.Array,
            []
        ]
    });
    MonthsTicker.prototype.initialize = function (attrs, options) {
        var interval, months;
        MonthsTicker.__super__.initialize.call(this, attrs, options);
        months = this.months;
        interval = months.length > 1 ? (months[1] - months[0]) * ONE_MONTH : 12 * ONE_MONTH;
        return this.interval = interval;
    };
    MonthsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var all_ticks, date, month_date, month_dates, months, months_of_year, ticks_in_range, year_dates;
        year_dates = date_range_by_year(data_low, data_high);
        months = this.months;
        months_of_year = function (year_date) {
            return months.map(function (month) {
                var month_date;
                month_date = copy_date(year_date);
                month_date.setUTCMonth(month);
                return month_date;
            });
        };
        month_dates = array_1.concat(function () {
            var i, len, results;
            results = [];
            for (i = 0, len = year_dates.length; i < len; i++) {
                date = year_dates[i];
                results.push(months_of_year(date));
            }
            return results;
        }());
        all_ticks = function () {
            var i, len, results;
            results = [];
            for (i = 0, len = month_dates.length; i < len; i++) {
                month_date = month_dates[i];
                results.push(month_date.getTime());
            }
            return results;
        }();
        ticks_in_range = all_ticks.filter(function (tick) {
            return data_low <= tick && tick <= data_high;
        });
        return {
            'major': ticks_in_range,
            'minor': []
        };
    };
    return MonthsTicker;
}(single_interval_ticker_1.SingleIntervalTicker);    
},
/* models/tickers/single_interval_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var continuous_ticker_1 = require(178    /* ./continuous_ticker */);
var p = require(13    /* core/properties */);
exports.SingleIntervalTicker = function (superClass) {
    extend(SingleIntervalTicker, superClass);
    function SingleIntervalTicker() {
        return SingleIntervalTicker.__super__.constructor.apply(this, arguments);
    }
    SingleIntervalTicker.prototype.type = 'SingleIntervalTicker';
    SingleIntervalTicker.define({ interval: [p.Number] });
    SingleIntervalTicker.getters({
        min_interval: function () {
            return this.interval;
        },
        max_interval: function () {
            return this.interval;
        }
    });
    SingleIntervalTicker.prototype.get_interval = function (data_low, data_high, n_desired_ticks) {
        return this.interval;
    };
    return SingleIntervalTicker;
}(continuous_ticker_1.ContinuousTicker);    
},
/* models/tickers/ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
var array_1 = require(20    /* core/util/array */);
var types_1 = require(40    /* core/util/types */);
exports.Ticker = function (superClass) {
    extend(Ticker, superClass);
    function Ticker() {
        return Ticker.__super__.constructor.apply(this, arguments);
    }
    Ticker.prototype.type = 'Ticker';
    Ticker.prototype.get_ticks = function (data_low, data_high, range, cross_loc, arg) {
        var desired_n_ticks;
        desired_n_ticks = arg.desired_n_ticks;
        return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);
    };
    Ticker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var end_factor, factor, factors, i, interval, j, k, l, len, len1, len2, minor_interval, minor_offsets, minor_ticks, num_minor_ticks, ref, start_factor, tick, ticks, x;
        interval = this.get_interval(data_low, data_high, desired_n_ticks);
        start_factor = Math.floor(data_low / interval);
        end_factor = Math.ceil(data_high / interval);
        if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor)) {
            factors = [];
        } else {
            factors = array_1.range(start_factor, end_factor + 1);
        }
        ticks = function () {
            var j, len, results;
            results = [];
            for (j = 0, len = factors.length; j < len; j++) {
                factor = factors[j];
                results.push(factor * interval);
            }
            return results;
        }();
        ticks = ticks.filter(function (tick) {
            return data_low <= tick && tick <= data_high;
        });
        num_minor_ticks = this.num_minor_ticks;
        minor_ticks = [];
        if (num_minor_ticks > 0 && ticks.length > 0) {
            minor_interval = interval / num_minor_ticks;
            minor_offsets = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = num_minor_ticks; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(i * minor_interval);
                }
                return results;
            }();
            ref = minor_offsets.slice(1, +minor_offsets.length + 1 || 9000000000);
            for (j = 0, len = ref.length; j < len; j++) {
                x = ref[j];
                minor_ticks.push(ticks[0] - x);
            }
            for (k = 0, len1 = ticks.length; k < len1; k++) {
                tick = ticks[k];
                for (l = 0, len2 = minor_offsets.length; l < len2; l++) {
                    x = minor_offsets[l];
                    minor_ticks.push(tick + x);
                }
            }
        }
        return {
            'major': ticks,
            'minor': minor_ticks
        };
    };
    return Ticker;
}(model_1.Model);    
},
/* models/tickers/util */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.ONE_MILLI = 1;
exports.ONE_SECOND = 1000;
exports.ONE_MINUTE = 60 * exports.ONE_SECOND;
exports.ONE_HOUR = 60 * exports.ONE_MINUTE;
exports.ONE_DAY = 24 * exports.ONE_HOUR;
exports.ONE_MONTH = 30 * exports.ONE_DAY;
exports.ONE_YEAR = 365 * exports.ONE_DAY;
exports.copy_date = function (date) {
    return new Date(date.getTime());
};
exports.last_month_no_later_than = function (date) {
    date = exports.copy_date(date);
    date.setUTCDate(1);
    date.setUTCHours(0);
    date.setUTCMinutes(0);
    date.setUTCSeconds(0);
    date.setUTCMilliseconds(0);
    return date;
};
exports.last_year_no_later_than = function (date) {
    date = exports.last_month_no_later_than(date);
    date.setUTCMonth(0);
    return date;
};    
},
/* models/tickers/years_ticker */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var ONE_YEAR, last_year_no_later_than, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var basic_ticker_1 = require(175    /* ./basic_ticker */);
var single_interval_ticker_1 = require(186    /* ./single_interval_ticker */);
var util = require(188    /* ./util */);
last_year_no_later_than = util.last_year_no_later_than;
ONE_YEAR = util.ONE_YEAR;
exports.YearsTicker = function (superClass) {
    extend(YearsTicker, superClass);
    function YearsTicker() {
        return YearsTicker.__super__.constructor.apply(this, arguments);
    }
    YearsTicker.prototype.type = 'YearsTicker';
    YearsTicker.prototype.initialize = function (attrs, options) {
        YearsTicker.__super__.initialize.call(this, attrs, options);
        this.interval = ONE_YEAR;
        return this.basic_ticker = new basic_ticker_1.BasicTicker({ num_minor_ticks: 0 });
    };
    YearsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
        var all_ticks, end_year, start_year, ticks_in_range, year, years;
        start_year = last_year_no_later_than(new Date(data_low)).getUTCFullYear();
        end_year = last_year_no_later_than(new Date(data_high)).getUTCFullYear();
        years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;
        all_ticks = function () {
            var i, len, results;
            results = [];
            for (i = 0, len = years.length; i < len; i++) {
                year = years[i];
                results.push(Date.UTC(year, 0, 1));
            }
            return results;
        }();
        ticks_in_range = all_ticks.filter(function (tick) {
            return data_low <= tick && tick <= data_high;
        });
        return {
            major: ticks_in_range,
            minor: []
        };
    };
    return YearsTicker;
}(single_interval_ticker_1.SingleIntervalTicker);    
},
/* models/tiles/bbox_tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var mercator_tile_source_1 = require(195    /* ./mercator_tile_source */);
var p = require(13    /* core/properties */);
exports.BBoxTileSource = function (superClass) {
    extend(BBoxTileSource, superClass);
    function BBoxTileSource() {
        return BBoxTileSource.__super__.constructor.apply(this, arguments);
    }
    BBoxTileSource.prototype.type = 'BBoxTileSource';
    BBoxTileSource.define({
        use_latlon: [
            p.Bool,
            false
        ]
    });
    BBoxTileSource.prototype.get_image_url = function (x, y, z) {
        var image_url, ref, ref1, xmax, xmin, ymax, ymin;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        if (this.use_latlon) {
            ref = this.get_tile_geographic_bounds(x, y, z), xmin = ref[0], ymin = ref[1], xmax = ref[2], ymax = ref[3];
        } else {
            ref1 = this.get_tile_meter_bounds(x, y, z), xmin = ref1[0], ymin = ref1[1], xmax = ref1[2], ymax = ref1[3];
        }
        return image_url.replace('{XMIN}', xmin).replace('{YMIN}', ymin).replace('{XMAX}', xmax).replace('{YMAX}', ymax);
    };
    return BBoxTileSource;
}(mercator_tile_source_1.MercatorTileSource);    
},
/* models/tiles/dynamic_image_renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    }, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var renderer_1 = require(160    /* ../renderers/renderer */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
exports.DynamicImageView = function (superClass) {
    extend(DynamicImageView, superClass);
    function DynamicImageView() {
        this._on_image_error = bind(this._on_image_error, this);
        this._on_image_load = bind(this._on_image_load, this);
        return DynamicImageView.__super__.constructor.apply(this, arguments);
    }
    DynamicImageView.prototype.connect_signals = function () {
        DynamicImageView.__super__.connect_signals.call(this);
        return this.connect(this.model.change, function () {
            return this.request_render();
        });
    };
    DynamicImageView.prototype.get_extent = function () {
        return [
            this.x_range.start,
            this.y_range.start,
            this.x_range.end,
            this.y_range.end
        ];
    };
    DynamicImageView.prototype._set_data = function () {
        this.map_plot = this.plot_view.model.plot;
        this.map_canvas = this.plot_view.canvas_view.ctx;
        this.map_frame = this.plot_view.frame;
        this.x_range = this.map_plot.x_range;
        this.y_range = this.map_plot.y_range;
        this.lastImage = void 0;
        return this.extent = this.get_extent();
    };
    DynamicImageView.prototype._map_data = function () {
        return this.initial_extent = this.get_extent();
    };
    DynamicImageView.prototype._on_image_load = function (e) {
        var image_data;
        image_data = e.target.image_data;
        image_data.img = e.target;
        image_data.loaded = true;
        this.lastImage = image_data;
        if (this.get_extent().join(':') === image_data.cache_key) {
            return this.request_render();
        }
    };
    DynamicImageView.prototype._on_image_error = function (e) {
        var image_data;
        logging_1.logger.error('Error loading image: ' + e.target.src);
        image_data = e.target.image_data;
        return this.model.image_source.remove_image(image_data);
    };
    DynamicImageView.prototype._create_image = function (bounds) {
        var image;
        image = new Image();
        image.onload = this._on_image_load;
        image.onerror = this._on_image_error;
        image.alt = '';
        image.image_data = {
            bounds: bounds,
            loaded: false,
            cache_key: bounds.join(':')
        };
        this.model.image_source.add_image(image.image_data);
        image.src = this.model.image_source.get_image_url(bounds[0], bounds[1], bounds[2], bounds[3], Math.ceil(this.map_frame._height.value), Math.ceil(this.map_frame._width.value));
        return image;
    };
    DynamicImageView.prototype.render = function (ctx, indices, args) {
        var extent, image_obj;
        if (this.map_initialized == null) {
            this._set_data();
            this._map_data();
            this.map_initialized = true;
        }
        extent = this.get_extent();
        if (this.render_timer) {
            clearTimeout(this.render_timer);
        }
        image_obj = this.model.image_source.images[extent.join(':')];
        if (image_obj != null && image_obj.loaded) {
            this._draw_image(extent.join(':'));
            return;
        }
        if (this.lastImage != null) {
            this._draw_image(this.lastImage.cache_key);
        }
        if (image_obj == null) {
            return this.render_timer = setTimeout(function (_this) {
                return function () {
                    return _this._create_image(extent);
                };
            }(this), 125);
        }
    };
    DynamicImageView.prototype._draw_image = function (image_key) {
        var image_obj, ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin;
        image_obj = this.model.image_source.images[image_key];
        if (image_obj != null) {
            this.map_canvas.save();
            this._set_rect();
            this.map_canvas.globalAlpha = this.model.alpha;
            ref = this.plot_view.frame.map_to_screen([image_obj.bounds[0]], [image_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];
            ref1 = this.plot_view.frame.map_to_screen([image_obj.bounds[2]], [image_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];
            sxmin = sxmin[0];
            symin = symin[0];
            sxmax = sxmax[0];
            symax = symax[0];
            sw = sxmax - sxmin;
            sh = symax - symin;
            sx = sxmin;
            sy = symin;
            this.map_canvas.drawImage(image_obj.img, sx, sy, sw, sh);
            return this.map_canvas.restore();
        }
    };
    DynamicImageView.prototype._set_rect = function () {
        var h, l, outline_width, t, w;
        outline_width = this.plot_model.plot.properties.outline_line_width.value();
        l = this.plot_view.canvas.vx_to_sx(this.map_frame._left.value) + outline_width / 2;
        t = this.plot_view.canvas.vy_to_sy(this.map_frame._top.value) + outline_width / 2;
        w = this.map_frame._width.value - outline_width;
        h = this.map_frame._height.value - outline_width;
        this.map_canvas.rect(l, t, w, h);
        return this.map_canvas.clip();
    };
    return DynamicImageView;
}(renderer_1.RendererView);
exports.DynamicImageRenderer = function (superClass) {
    extend(DynamicImageRenderer, superClass);
    function DynamicImageRenderer() {
        return DynamicImageRenderer.__super__.constructor.apply(this, arguments);
    }
    DynamicImageRenderer.prototype.default_view = exports.DynamicImageView;
    DynamicImageRenderer.prototype.type = 'DynamicImageRenderer';
    DynamicImageRenderer.define({
        alpha: [
            p.Number,
            1
        ],
        image_source: [p.Instance],
        render_parents: [
            p.Bool,
            true
        ]
    });
    DynamicImageRenderer.override({ level: 'underlay' });
    return DynamicImageRenderer;
}(renderer_1.Renderer);    
},
/* models/tiles/image_pool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.ImagePool = function () {
    function ImagePool() {
        this.images = [];
    }
    ImagePool.prototype.pop = function () {
        var img;
        img = this.images.pop();
        if (img != null) {
            return img;
        } else {
            return new Image();
        }
    };
    ImagePool.prototype.push = function (img) {
        if (this.images.length > 50) {
            return;
        }
        if (img.constructor === Array) {
            return Array.prototype.push.apply(this.images, img);
        } else {
            return this.images.push(img);
        }
    };
    return ImagePool;
}();    
},
/* models/tiles/image_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var model_1 = require(48    /* ../../model */);
exports.ImageSource = function (superClass) {
    extend(ImageSource, superClass);
    ImageSource.prototype.type = 'ImageSource';
    ImageSource.define({
        url: [
            p.String,
            ''
        ],
        extra_url_vars: [
            p.Any,
            {}
        ]
    });
    function ImageSource(options) {
        if (options == null) {
            options = {};
        }
        ImageSource.__super__.constructor.apply(this, arguments);
        this.images = {};
        this.normalize_case();
    }
    ImageSource.prototype.normalize_case = function () {
        'Note: should probably be refactored into subclasses.';
        var url;
        url = this.url;
        url = url.replace('{xmin}', '{XMIN}');
        url = url.replace('{ymin}', '{YMIN}');
        url = url.replace('{xmax}', '{XMAX}');
        url = url.replace('{ymax}', '{YMAX}');
        url = url.replace('{height}', '{HEIGHT}');
        url = url.replace('{width}', '{WIDTH}');
        return this.url = url;
    };
    ImageSource.prototype.string_lookup_replace = function (str, lookup) {
        var key, result_str, value;
        result_str = str;
        for (key in lookup) {
            value = lookup[key];
            result_str = result_str.replace('{' + key + '}', value.toString());
        }
        return result_str;
    };
    ImageSource.prototype.add_image = function (image_obj) {
        return this.images[image_obj.cache_key] = image_obj;
    };
    ImageSource.prototype.remove_image = function (image_obj) {
        return delete this.images[image_obj.cache_key];
    };
    ImageSource.prototype.get_image_url = function (xmin, ymin, xmax, ymax, height, width) {
        var image_url;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        return image_url.replace('{XMIN}', xmin).replace('{YMIN}', ymin).replace('{XMAX}', xmax).replace('{YMAX}', ymax).replace('{WIDTH}', width).replace('{HEIGHT}', height);
    };
    return ImageSource;
}(model_1.Model);    
},
/* models/tiles/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var bbox_tile_source_1 = require(190    /* ./bbox_tile_source */);
exports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;
var dynamic_image_renderer_1 = require(191    /* ./dynamic_image_renderer */);
exports.DynamicImageRenderer = dynamic_image_renderer_1.DynamicImageRenderer;
var image_source_1 = require(193    /* ./image_source */);
exports.ImageSource = image_source_1.ImageSource;
var mercator_tile_source_1 = require(195    /* ./mercator_tile_source */);
exports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;
var quadkey_tile_source_1 = require(196    /* ./quadkey_tile_source */);
exports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;
var tile_renderer_1 = require(197    /* ./tile_renderer */);
exports.TileRenderer = tile_renderer_1.TileRenderer;
var tile_source_1 = require(198    /* ./tile_source */);
exports.TileSource = tile_source_1.TileSource;
var tms_tile_source_1 = require(200    /* ./tms_tile_source */);
exports.TMSTileSource = tms_tile_source_1.TMSTileSource;
var wmts_tile_source_1 = require(201    /* ./wmts_tile_source */);
exports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;    
},
/* models/tiles/mercator_tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var tile_source_1 = require(198    /* ./tile_source */);
var p = require(13    /* core/properties */);
exports.MercatorTileSource = function (superClass) {
    extend(MercatorTileSource, superClass);
    function MercatorTileSource() {
        return MercatorTileSource.__super__.constructor.apply(this, arguments);
    }
    MercatorTileSource.prototype.type = 'MercatorTileSource';
    MercatorTileSource.define({
        wrap_around: [
            p.Bool,
            true
        ]
    });
    MercatorTileSource.override({
        x_origin_offset: 20037508.34,
        y_origin_offset: 20037508.34,
        initial_resolution: 156543.03392804097
    });
    MercatorTileSource.prototype.initialize = function (options) {
        var z;
        MercatorTileSource.__super__.initialize.call(this, options);
        return this._resolutions = function () {
            var j, ref, ref1, results;
            results = [];
            for (z = j = ref = this.min_zoom, ref1 = this.max_zoom; ref <= ref1 ? j <= ref1 : j >= ref1; z = ref <= ref1 ? ++j : --j) {
                results.push(this.get_resolution(z));
            }
            return results;
        }.call(this);
    };
    MercatorTileSource.prototype._computed_initial_resolution = function () {
        if (this.initial_resolution != null) {
            return this.initial_resolution;
        } else {
            return 2 * Math.PI * 6378137 / this.tile_size;
        }
    };
    MercatorTileSource.prototype.is_valid_tile = function (x, y, z) {
        if (!this.wrap_around) {
            if (x < 0 || x >= Math.pow(2, z)) {
                return false;
            }
        }
        if (y < 0 || y >= Math.pow(2, z)) {
            return false;
        }
        return true;
    };
    MercatorTileSource.prototype.retain_children = function (reference_tile) {
        var key, max_zoom, min_zoom, quadkey, ref, results, tile;
        quadkey = reference_tile.quadkey;
        min_zoom = quadkey.length;
        max_zoom = min_zoom + 3;
        ref = this.tiles;
        results = [];
        for (key in ref) {
            tile = ref[key];
            if (tile.quadkey.indexOf(quadkey) === 0 && tile.quadkey.length > min_zoom && tile.quadkey.length <= max_zoom) {
                results.push(tile.retain = true);
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    MercatorTileSource.prototype.retain_neighbors = function (reference_tile) {
        var key, neighbor_radius, neighbor_x, neighbor_y, ref, ref1, ref2, ref3, results, tile, tx, ty, tz, x, y;
        neighbor_radius = 4;
        ref = reference_tile.tile_coords, tx = ref[0], ty = ref[1], tz = ref[2];
        neighbor_x = function () {
            var j, ref1, ref2, results;
            results = [];
            for (x = j = ref1 = tx - neighbor_radius, ref2 = tx + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; x = ref1 <= ref2 ? ++j : --j) {
                results.push(x);
            }
            return results;
        }();
        neighbor_y = function () {
            var j, ref1, ref2, results;
            results = [];
            for (y = j = ref1 = ty - neighbor_radius, ref2 = ty + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; y = ref1 <= ref2 ? ++j : --j) {
                results.push(y);
            }
            return results;
        }();
        ref1 = this.tiles;
        results = [];
        for (key in ref1) {
            tile = ref1[key];
            if (tile.tile_coords[2] === tz && (ref2 = tile.tile_coords[0], indexOf.call(neighbor_x, ref2) >= 0) && (ref3 = tile.tile_coords[1], indexOf.call(neighbor_y, ref3) >= 0)) {
                results.push(tile.retain = true);
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    MercatorTileSource.prototype.retain_parents = function (reference_tile) {
        var key, quadkey, ref, results, tile;
        quadkey = reference_tile.quadkey;
        ref = this.tiles;
        results = [];
        for (key in ref) {
            tile = ref[key];
            results.push(tile.retain = quadkey.indexOf(tile.quadkey) === 0);
        }
        return results;
    };
    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {
        var b, child_tile_xyz, i, j, quad_key, ref, ref1, ref2, world_x;
        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);
        if (world_x !== 0) {
            ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];
        }
        quad_key = this.tile_xyz_to_quadkey(x, y, z);
        child_tile_xyz = [];
        for (i = j = 0; j <= 3; i = j += 1) {
            ref1 = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref1[0], y = ref1[1], z = ref1[2];
            if (world_x !== 0) {
                ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];
            }
            b = this.get_tile_meter_bounds(x, y, z);
            if (b != null) {
                child_tile_xyz.push([
                    x,
                    y,
                    z,
                    b
                ]);
            }
        }
        return child_tile_xyz;
    };
    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {
        var parent_quad_key, quad_key;
        quad_key = this.tile_xyz_to_quadkey(x, y, z);
        parent_quad_key = quad_key.substring(0, quad_key.length - 1);
        return this.quadkey_to_tile_xyz(parent_quad_key);
    };
    MercatorTileSource.prototype.get_resolution = function (level) {
        return this._computed_initial_resolution() / Math.pow(2, level);
    };
    MercatorTileSource.prototype.get_resolution_by_extent = function (extent, height, width) {
        var x_rs, y_rs;
        x_rs = (extent[2] - extent[0]) / width;
        y_rs = (extent[3] - extent[1]) / height;
        return [
            x_rs,
            y_rs
        ];
    };
    MercatorTileSource.prototype.get_level_by_extent = function (extent, height, width) {
        var i, j, len, r, ref, resolution, x_rs, y_rs;
        x_rs = (extent[2] - extent[0]) / width;
        y_rs = (extent[3] - extent[1]) / height;
        resolution = Math.max(x_rs, y_rs);
        i = 0;
        ref = this._resolutions;
        for (j = 0, len = ref.length; j < len; j++) {
            r = ref[j];
            if (resolution > r) {
                if (i === 0) {
                    return 0;
                }
                if (i > 0) {
                    return i - 1;
                }
            }
            i += 1;
        }
    };
    MercatorTileSource.prototype.get_closest_level_by_extent = function (extent, height, width) {
        var closest, resolution, ress, x_rs, y_rs;
        x_rs = (extent[2] - extent[0]) / width;
        y_rs = (extent[3] - extent[1]) / height;
        resolution = Math.max(x_rs, y_rs);
        ress = this._resolutions;
        closest = this._resolutions.reduce(function (previous, current) {
            if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {
                return current;
            }
            return previous;
        });
        return this._resolutions.indexOf(closest);
    };
    MercatorTileSource.prototype.snap_to_zoom = function (extent, height, width, level) {
        var desired_res, desired_x_delta, desired_y_delta, x_adjust, xmax, xmin, y_adjust, ymax, ymin;
        desired_res = this._resolutions[level];
        desired_x_delta = width * desired_res;
        desired_y_delta = height * desired_res;
        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
        x_adjust = (desired_x_delta - (xmax - xmin)) / 2;
        y_adjust = (desired_y_delta - (ymax - ymin)) / 2;
        return [
            xmin - x_adjust,
            ymin - y_adjust,
            xmax + x_adjust,
            ymax + y_adjust
        ];
    };
    MercatorTileSource.prototype.tms_to_wmts = function (x, y, z) {
        'Note this works both ways';
        return [
            x,
            Math.pow(2, z) - 1 - y,
            z
        ];
    };
    MercatorTileSource.prototype.wmts_to_tms = function (x, y, z) {
        'Note this works both ways';
        return [
            x,
            Math.pow(2, z) - 1 - y,
            z
        ];
    };
    MercatorTileSource.prototype.pixels_to_meters = function (px, py, level) {
        var mx, my, res;
        res = this.get_resolution(level);
        mx = px * res - this.x_origin_offset;
        my = py * res - this.y_origin_offset;
        return [
            mx,
            my
        ];
    };
    MercatorTileSource.prototype.meters_to_pixels = function (mx, my, level) {
        var px, py, res;
        res = this.get_resolution(level);
        px = (mx + this.x_origin_offset) / res;
        py = (my + this.y_origin_offset) / res;
        return [
            px,
            py
        ];
    };
    MercatorTileSource.prototype.pixels_to_tile = function (px, py) {
        var tx, ty;
        tx = Math.ceil(px / parseFloat(this.tile_size));
        tx = tx === 0 ? tx : tx - 1;
        ty = Math.max(Math.ceil(py / parseFloat(this.tile_size)) - 1, 0);
        return [
            tx,
            ty
        ];
    };
    MercatorTileSource.prototype.pixels_to_raster = function (px, py, level) {
        var mapSize;
        mapSize = this.tile_size << level;
        return [
            px,
            mapSize - py
        ];
    };
    MercatorTileSource.prototype.meters_to_tile = function (mx, my, level) {
        var px, py, ref;
        ref = this.meters_to_pixels(mx, my, level), px = ref[0], py = ref[1];
        return this.pixels_to_tile(px, py);
    };
    MercatorTileSource.prototype.get_tile_meter_bounds = function (tx, ty, level) {
        var ref, ref1, xmax, xmin, ymax, ymin;
        ref = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level), xmin = ref[0], ymin = ref[1];
        ref1 = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level), xmax = ref1[0], ymax = ref1[1];
        if (xmin != null && ymin != null && xmax != null && ymax != null) {
            return [
                xmin,
                ymin,
                xmax,
                ymax
            ];
        } else {
            return void 0;
        }
    };
    MercatorTileSource.prototype.get_tile_geographic_bounds = function (tx, ty, level) {
        var bounds, maxLat, maxLon, minLat, minLon, ref;
        bounds = this.get_tile_meter_bounds(tx, ty, level);
        ref = this.utils.meters_extent_to_geographic(bounds), minLon = ref[0], minLat = ref[1], maxLon = ref[2], maxLat = ref[3];
        return [
            minLon,
            minLat,
            maxLon,
            maxLat
        ];
    };
    MercatorTileSource.prototype.get_tiles_by_extent = function (extent, level, tile_border) {
        var j, k, ref, ref1, ref2, ref3, ref4, ref5, tiles, tx, txmax, txmin, ty, tymax, tymin, xmax, xmin, ymax, ymin;
        if (tile_border == null) {
            tile_border = 1;
        }
        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
        ref = this.meters_to_tile(xmin, ymin, level), txmin = ref[0], tymin = ref[1];
        ref1 = this.meters_to_tile(xmax, ymax, level), txmax = ref1[0], tymax = ref1[1];
        txmin -= tile_border;
        tymin -= tile_border;
        txmax += tile_border;
        tymax += tile_border;
        tiles = [];
        for (ty = j = ref2 = tymax, ref3 = tymin; j >= ref3; ty = j += -1) {
            for (tx = k = ref4 = txmin, ref5 = txmax; k <= ref5; tx = k += 1) {
                if (this.is_valid_tile(tx, ty, level)) {
                    tiles.push([
                        tx,
                        ty,
                        level,
                        this.get_tile_meter_bounds(tx, ty, level)
                    ]);
                }
            }
        }
        tiles = this.sort_tiles_from_center(tiles, [
            txmin,
            tymin,
            txmax,
            tymax
        ]);
        return tiles;
    };
    MercatorTileSource.prototype.quadkey_to_tile_xyz = function (quadKey) {
        'Computes tile x, y and z values based on quadKey.';
        var i, j, mask, ref, tileX, tileY, tileZ, value;
        tileX = 0;
        tileY = 0;
        tileZ = quadKey.length;
        for (i = j = ref = tileZ; j > 0; i = j += -1) {
            value = quadKey.charAt(tileZ - i);
            mask = 1 << i - 1;
            switch (value) {
            case '0':
                continue;
            case '1':
                tileX |= mask;
                break;
            case '2':
                tileY |= mask;
                break;
            case '3':
                tileX |= mask;
                tileY |= mask;
                break;
            default:
                throw new TypeError('Invalid Quadkey: ' + quadKey);
            }
        }
        return [
            tileX,
            tileY,
            tileZ
        ];
    };
    MercatorTileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {
        'Computes quadkey value based on tile x, y and z values.';
        var digit, i, j, mask, quadKey, ref;
        quadKey = '';
        for (i = j = ref = z; j > 0; i = j += -1) {
            digit = 0;
            mask = 1 << i - 1;
            if ((x & mask) !== 0) {
                digit += 1;
            }
            if ((y & mask) !== 0) {
                digit += 2;
            }
            quadKey += digit.toString();
        }
        return quadKey;
    };
    MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {
        var b, child_tile_xyz, i, j, quad_key, ref;
        quad_key = this.tile_xyz_to_quadkey(x, y, z);
        child_tile_xyz = [];
        for (i = j = 0; j <= 3; i = j += 1) {
            ref = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref[0], y = ref[1], z = ref[2];
            b = this.get_tile_meter_bounds(x, y, z);
            if (b != null) {
                child_tile_xyz.push([
                    x,
                    y,
                    z,
                    b
                ]);
            }
        }
        return child_tile_xyz;
    };
    MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {
        var parent_quad_key, quad_key;
        quad_key = this.tile_xyz_to_quadkey(x, y, z);
        parent_quad_key = quad_key.substring(0, quad_key.length - 1);
        return this.quadkey_to_tile_xyz(parent_quad_key);
    };
    MercatorTileSource.prototype.get_closest_parent_by_tile_xyz = function (x, y, z) {
        var quad_key, ref, ref1, ref2, world_x;
        world_x = this.calculate_world_x_by_tile_xyz(x, y, z);
        ref = this.normalize_xyz(x, y, z), x = ref[0], y = ref[1], z = ref[2];
        quad_key = this.tile_xyz_to_quadkey(x, y, z);
        while (quad_key.length > 0) {
            quad_key = quad_key.substring(0, quad_key.length - 1);
            ref1 = this.quadkey_to_tile_xyz(quad_key), x = ref1[0], y = ref1[1], z = ref1[2];
            ref2 = this.denormalize_xyz(x, y, z, world_x), x = ref2[0], y = ref2[1], z = ref2[2];
            if (this.tile_xyz_to_key(x, y, z) in this.tiles) {
                return [
                    x,
                    y,
                    z
                ];
            }
        }
        return [
            0,
            0,
            0
        ];
    };
    MercatorTileSource.prototype.normalize_xyz = function (x, y, z) {
        var tile_count;
        if (this.wrap_around) {
            tile_count = Math.pow(2, z);
            return [
                (x % tile_count + tile_count) % tile_count,
                y,
                z
            ];
        } else {
            return [
                x,
                y,
                z
            ];
        }
    };
    MercatorTileSource.prototype.denormalize_xyz = function (x, y, z, world_x) {
        return [
            x + world_x * Math.pow(2, z),
            y,
            z
        ];
    };
    MercatorTileSource.prototype.denormalize_meters = function (meters_x, meters_y, level, world_x) {
        return [
            meters_x + world_x * 2 * Math.PI * 6378137,
            meters_y
        ];
    };
    MercatorTileSource.prototype.calculate_world_x_by_tile_xyz = function (x, y, z) {
        return Math.floor(x / Math.pow(2, z));
    };
    return MercatorTileSource;
}(tile_source_1.TileSource);    
},
/* models/tiles/quadkey_tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var mercator_tile_source_1 = require(195    /* ./mercator_tile_source */);
exports.QUADKEYTileSource = function (superClass) {
    extend(QUADKEYTileSource, superClass);
    function QUADKEYTileSource() {
        return QUADKEYTileSource.__super__.constructor.apply(this, arguments);
    }
    QUADKEYTileSource.prototype.type = 'QUADKEYTileSource';
    QUADKEYTileSource.prototype.get_image_url = function (x, y, z) {
        var image_url, quadKey, ref;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];
        quadKey = this.tile_xyz_to_quadkey(x, y, z);
        return image_url.replace('{Q}', quadKey);
    };
    return QUADKEYTileSource;
}(mercator_tile_source_1.MercatorTileSource);    
},
/* models/tiles/tile_renderer */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    }, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var image_pool_1 = require(192    /* ./image_pool */);
var wmts_tile_source_1 = require(201    /* ./wmts_tile_source */);
var renderer_1 = require(160    /* ../renderers/renderer */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.TileRendererView = function (superClass) {
    extend(TileRendererView, superClass);
    function TileRendererView() {
        this._update = bind(this._update, this);
        this._prefetch_tiles = bind(this._prefetch_tiles, this);
        this._on_tile_error = bind(this._on_tile_error, this);
        this._on_tile_cache_load = bind(this._on_tile_cache_load, this);
        this._on_tile_load = bind(this._on_tile_load, this);
        this._add_attribution = bind(this._add_attribution, this);
        return TileRendererView.__super__.constructor.apply(this, arguments);
    }
    TileRendererView.prototype.initialize = function (options) {
        this.attributionEl = null;
        this._tiles = [];
        return TileRendererView.__super__.initialize.apply(this, arguments);
    };
    TileRendererView.prototype.connect_signals = function () {
        TileRendererView.__super__.connect_signals.call(this);
        return this.connect(this.model.change, function () {
            return this.request_render();
        });
    };
    TileRendererView.prototype.get_extent = function () {
        return [
            this.x_range.start,
            this.y_range.start,
            this.x_range.end,
            this.y_range.end
        ];
    };
    TileRendererView.prototype._set_data = function () {
        this.pool = new image_pool_1.ImagePool();
        this.map_plot = this.plot_model.plot;
        this.map_canvas = this.plot_view.canvas_view.ctx;
        this.map_frame = this.plot_model.frame;
        this.x_range = this.map_plot.x_range;
        this.y_range = this.map_plot.y_range;
        this.extent = this.get_extent();
        this._last_height = void 0;
        return this._last_width = void 0;
    };
    TileRendererView.prototype._add_attribution = function () {
        var attribution, border_width, bottom_offset, max_width, overlays, right_offset;
        attribution = this.model.tile_source.attribution;
        if (types_1.isString(attribution) && attribution.length > 0) {
            if (this.attributionEl == null) {
                border_width = this.map_plot.outline_line_width;
                bottom_offset = this.map_plot.min_border_bottom + border_width;
                right_offset = this.map_frame._right.value - this.map_frame._width.value;
                max_width = this.map_frame._width.value - border_width;
                this.attributionEl = dom_1.div({
                    'class': 'bk-tile-attribution',
                    style: {
                        position: 'absolute',
                        bottom: bottom_offset + 'px',
                        right: right_offset + 'px',
                        'max-width': max_width + 'px',
                        'background-color': 'rgba(255,255,255,0.8)',
                        'font-size': '9pt',
                        'font-family': 'sans-serif'
                    }
                });
                overlays = this.plot_view.canvas_view.events_el;
                overlays.appendChild(this.attributionEl);
            }
            return this.attributionEl.innerHTML = attribution;
        }
    };
    TileRendererView.prototype._map_data = function () {
        var new_extent, zoom_level;
        this.initial_extent = this.get_extent();
        zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value);
        new_extent = this.model.tile_source.snap_to_zoom(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);
        this.x_range.start = new_extent[0];
        this.y_range.start = new_extent[1];
        this.x_range.end = new_extent[2];
        this.y_range.end = new_extent[3];
        return this._add_attribution();
    };
    TileRendererView.prototype._on_tile_load = function (e) {
        var tile_data;
        tile_data = e.target.tile_data;
        tile_data.img = e.target;
        tile_data.current = true;
        tile_data.loaded = true;
        return this.request_render();
    };
    TileRendererView.prototype._on_tile_cache_load = function (e) {
        var tile_data;
        tile_data = e.target.tile_data;
        tile_data.img = e.target;
        tile_data.loaded = true;
        tile_data.finished = true;
        return this.notify_finished();
    };
    TileRendererView.prototype._on_tile_error = function (e) {
        var tile_data;
        tile_data = e.target.tile_data;
        return tile_data.finished = true;
    };
    TileRendererView.prototype._create_tile = function (x, y, z, bounds, cache_only) {
        var normalized_coords, ref, tile;
        if (cache_only == null) {
            cache_only = false;
        }
        normalized_coords = this.model.tile_source.normalize_xyz(x, y, z);
        tile = this.pool.pop();
        if (cache_only) {
            tile.onload = this._on_tile_cache_load;
        } else {
            tile.onload = this._on_tile_load;
        }
        tile.onerror = this._on_tile_error;
        tile.alt = '';
        tile.tile_data = {
            tile_coords: [
                x,
                y,
                z
            ],
            normalized_coords: normalized_coords,
            quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),
            cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),
            bounds: bounds,
            loaded: false,
            finished: false,
            x_coord: bounds[0],
            y_coord: bounds[3]
        };
        this.model.tile_source.tiles[tile.tile_data.cache_key] = tile.tile_data;
        tile.src = (ref = this.model.tile_source).get_image_url.apply(ref, normalized_coords);
        this._tiles.push(tile);
        return tile;
    };
    TileRendererView.prototype._enforce_aspect_ratio = function () {
        var extent, new_extent, zoom_level;
        if (this._last_height !== this.map_frame._height.value || this._last_width !== this.map_frame._width.value) {
            extent = this.get_extent();
            zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame._height.value, this.map_frame._width.value);
            new_extent = this.model.tile_source.snap_to_zoom(extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);
            this.x_range.setv({
                start: new_extent[0],
                end: new_extent[2]
            });
            this.y_range.setv({
                start: new_extent[1],
                end: new_extent[3]
            });
            this.extent = new_extent;
            this._last_height = this.map_frame._height.value;
            this._last_width = this.map_frame._width.value;
            return true;
        }
        return false;
    };
    TileRendererView.prototype.has_finished = function () {
        var i, len, ref, tile;
        if (!TileRendererView.__super__.has_finished.call(this)) {
            return false;
        }
        if (this._tiles.length === 0) {
            return false;
        }
        ref = this._tiles;
        for (i = 0, len = ref.length; i < len; i++) {
            tile = ref[i];
            if (!tile.tile_data.finished) {
                return false;
            }
        }
        return true;
    };
    TileRendererView.prototype.render = function (ctx, indices, args) {
        if (this.map_initialized == null) {
            this._set_data();
            this._map_data();
            this.map_initialized = true;
        }
        if (this._enforce_aspect_ratio()) {
            return;
        }
        this._update();
        if (this.prefetch_timer != null) {
            clearTimeout(this.prefetch_timer);
        }
        this.prefetch_timer = setTimeout(this._prefetch_tiles, 500);
        if (this.has_finished()) {
            return this.notify_finished();
        }
    };
    TileRendererView.prototype._draw_tile = function (tile_key) {
        var ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin, tile_obj;
        tile_obj = this.model.tile_source.tiles[tile_key];
        if (tile_obj != null) {
            ref = this.plot_view.frame.map_to_screen([tile_obj.bounds[0]], [tile_obj.bounds[3]], this.plot_view.canvas), sxmin = ref[0], symin = ref[1];
            ref1 = this.plot_view.frame.map_to_screen([tile_obj.bounds[2]], [tile_obj.bounds[1]], this.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];
            sxmin = sxmin[0];
            symin = symin[0];
            sxmax = sxmax[0];
            symax = symax[0];
            sw = sxmax - sxmin;
            sh = symax - symin;
            sx = sxmin;
            sy = symin;
            return this.map_canvas.drawImage(tile_obj.img, sx, sy, sw, sh);
        }
    };
    TileRendererView.prototype._set_rect = function () {
        var h, l, outline_width, t, w;
        outline_width = this.plot_model.plot.properties.outline_line_width.value();
        l = this.plot_view.canvas.vx_to_sx(this.map_frame._left.value) + outline_width / 2;
        t = this.plot_view.canvas.vy_to_sy(this.map_frame._top.value) + outline_width / 2;
        w = this.map_frame._width.value - outline_width;
        h = this.map_frame._height.value - outline_width;
        this.map_canvas.rect(l, t, w, h);
        return this.map_canvas.clip();
    };
    TileRendererView.prototype._render_tiles = function (tile_keys) {
        var i, len, tile_key;
        this.map_canvas.save();
        this._set_rect();
        this.map_canvas.globalAlpha = this.model.alpha;
        for (i = 0, len = tile_keys.length; i < len; i++) {
            tile_key = tile_keys[i];
            this._draw_tile(tile_key);
        }
        return this.map_canvas.restore();
    };
    TileRendererView.prototype._prefetch_tiles = function () {
        var bounds, c, cbounds, children, cx, cy, cz, extent, h, i, ref, results, t, tile_source, tiles, w, x, y, z, zoom_level;
        tile_source = this.model.tile_source;
        extent = this.get_extent();
        h = this.map_frame._height.value;
        w = this.map_frame._width.value;
        zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);
        tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);
        results = [];
        for (t = i = 0, ref = Math.min(10, tiles.length); i <= ref; t = i += 1) {
            x = t[0], y = t[1], z = t[2], bounds = t[3];
            children = this.model.tile_source.children_by_tile_xyz(x, y, z);
            results.push(function () {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = children.length; j < len; j++) {
                    c = children[j];
                    cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];
                    if (tile_source.tile_xyz_to_key(cx, cy, cz) in tile_source.tiles) {
                        continue;
                    } else {
                        results1.push(this._create_tile(cx, cy, cz, cbounds, true));
                    }
                }
                return results1;
            }.call(this));
        }
        return results;
    };
    TileRendererView.prototype._fetch_tiles = function (tiles) {
        var bounds, i, len, results, t, x, y, z;
        results = [];
        for (i = 0, len = tiles.length; i < len; i++) {
            t = tiles[i];
            x = t[0], y = t[1], z = t[2], bounds = t[3];
            results.push(this._create_tile(x, y, z, bounds));
        }
        return results;
    };
    TileRendererView.prototype._update = function () {
        var bounds, c, cached, cbounds, child_key, children, cx, cy, cz, extent, h, i, j, k, key, len, len1, len2, max_zoom, min_zoom, need_load, parent_key, parent_tile, parents, px, py, pz, ref, snap_back, t, tile, tile_source, tiles, w, x, y, z, zoom_level, zooming_out;
        tile_source = this.model.tile_source;
        min_zoom = tile_source.min_zoom;
        max_zoom = tile_source.max_zoom;
        tile_source.update();
        extent = this.get_extent();
        zooming_out = this.extent[2] - this.extent[0] < extent[2] - extent[0];
        h = this.map_frame._height.value;
        w = this.map_frame._width.value;
        zoom_level = tile_source.get_level_by_extent(extent, h, w);
        snap_back = false;
        if (zoom_level < min_zoom) {
            extent = this.extent;
            zoom_level = min_zoom;
            snap_back = true;
        } else if (zoom_level > max_zoom) {
            extent = this.extent;
            zoom_level = max_zoom;
            snap_back = true;
        }
        if (snap_back) {
            this.x_range.setv({
                x_range: {
                    start: extent[0],
                    end: extent[2]
                }
            });
            this.y_range.setv({
                start: extent[1],
                end: extent[3]
            });
            this.extent = extent;
        }
        this.extent = extent;
        tiles = tile_source.get_tiles_by_extent(extent, zoom_level);
        parents = [];
        need_load = [];
        cached = [];
        children = [];
        for (i = 0, len = tiles.length; i < len; i++) {
            t = tiles[i];
            x = t[0], y = t[1], z = t[2], bounds = t[3];
            key = tile_source.tile_xyz_to_key(x, y, z);
            tile = tile_source.tiles[key];
            if (tile != null && tile.loaded === true) {
                cached.push(key);
            } else {
                if (this.model.render_parents) {
                    ref = tile_source.get_closest_parent_by_tile_xyz(x, y, z), px = ref[0], py = ref[1], pz = ref[2];
                    parent_key = tile_source.tile_xyz_to_key(px, py, pz);
                    parent_tile = tile_source.tiles[parent_key];
                    if (parent_tile != null && parent_tile.loaded && indexOf.call(parents, parent_key) < 0) {
                        parents.push(parent_key);
                    }
                    if (zooming_out) {
                        children = tile_source.children_by_tile_xyz(x, y, z);
                        for (j = 0, len1 = children.length; j < len1; j++) {
                            c = children[j];
                            cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];
                            child_key = tile_source.tile_xyz_to_key(cx, cy, cz);
                            if (child_key in tile_source.tiles) {
                                children.push(child_key);
                            }
                        }
                    }
                }
            }
            if (tile == null) {
                need_load.push(t);
            }
        }
        this._render_tiles(parents);
        this._render_tiles(children);
        this._render_tiles(cached);
        for (k = 0, len2 = cached.length; k < len2; k++) {
            t = cached[k];
            tile_source.tiles[t].current = true;
        }
        if (this.render_timer != null) {
            clearTimeout(this.render_timer);
        }
        return this.render_timer = setTimeout(function (_this) {
            return function () {
                return _this._fetch_tiles(need_load);
            };
        }(this), 65);
    };
    return TileRendererView;
}(renderer_1.RendererView);
exports.TileRenderer = function (superClass) {
    extend(TileRenderer, superClass);
    function TileRenderer() {
        return TileRenderer.__super__.constructor.apply(this, arguments);
    }
    TileRenderer.prototype.default_view = exports.TileRendererView;
    TileRenderer.prototype.type = 'TileRenderer';
    TileRenderer.define({
        alpha: [
            p.Number,
            1
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        tile_source: [
            p.Instance,
            function () {
                return new wmts_tile_source_1.WMTSTileSource();
            }
        ],
        render_parents: [
            p.Bool,
            true
        ]
    });
    TileRenderer.override({ level: 'underlay' });
    return TileRenderer;
}(renderer_1.Renderer);    
},
/* models/tiles/tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var image_pool_1 = require(192    /* ./image_pool */);
var tile_utils_1 = require(199    /* ./tile_utils */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var model_1 = require(48    /* ../../model */);
exports.TileSource = function (superClass) {
    extend(TileSource, superClass);
    TileSource.prototype.type = 'TileSource';
    TileSource.define({
        url: [
            p.String,
            ''
        ],
        tile_size: [
            p.Number,
            256
        ],
        max_zoom: [
            p.Number,
            30
        ],
        min_zoom: [
            p.Number,
            0
        ],
        extra_url_vars: [
            p.Any,
            {}
        ],
        attribution: [
            p.String,
            ''
        ],
        x_origin_offset: [p.Number],
        y_origin_offset: [p.Number],
        initial_resolution: [p.Number]
    });
    TileSource.prototype.initialize = function (options) {
        TileSource.__super__.initialize.call(this, options);
        return this.normalize_case();
    };
    function TileSource(options) {
        if (options == null) {
            options = {};
        }
        TileSource.__super__.constructor.apply(this, arguments);
        this.utils = new tile_utils_1.ProjectionUtils();
        this.pool = new image_pool_1.ImagePool();
        this.tiles = {};
        this.normalize_case();
    }
    TileSource.prototype.string_lookup_replace = function (str, lookup) {
        var key, result_str, value;
        result_str = str;
        for (key in lookup) {
            value = lookup[key];
            result_str = result_str.replace('{' + key + '}', value.toString());
        }
        return result_str;
    };
    TileSource.prototype.normalize_case = function () {
        'Note: should probably be refactored into subclasses.';
        var url;
        url = this.url;
        url = url.replace('{x}', '{X}');
        url = url.replace('{y}', '{Y}');
        url = url.replace('{z}', '{Z}');
        url = url.replace('{q}', '{Q}');
        url = url.replace('{xmin}', '{XMIN}');
        url = url.replace('{ymin}', '{YMIN}');
        url = url.replace('{xmax}', '{XMAX}');
        url = url.replace('{ymax}', '{YMAX}');
        return this.url = url;
    };
    TileSource.prototype.update = function () {
        var key, ref, results, tile;
        logging_1.logger.debug('TileSource: tile cache count: ' + Object.keys(this.tiles).length);
        ref = this.tiles;
        results = [];
        for (key in ref) {
            tile = ref[key];
            tile.current = false;
            results.push(tile.retain = false);
        }
        return results;
    };
    TileSource.prototype.tile_xyz_to_key = function (x, y, z) {
        var key;
        key = x + ':' + y + ':' + z;
        return key;
    };
    TileSource.prototype.key_to_tile_xyz = function (key) {
        var c;
        return function () {
            var i, len, ref, results;
            ref = key.split(':');
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                c = ref[i];
                results.push(parseInt(c));
            }
            return results;
        }();
    };
    TileSource.prototype.sort_tiles_from_center = function (tiles, tile_extent) {
        var center_x, center_y, txmax, txmin, tymax, tymin;
        txmin = tile_extent[0], tymin = tile_extent[1], txmax = tile_extent[2], tymax = tile_extent[3];
        center_x = (txmax - txmin) / 2 + txmin;
        center_y = (tymax - tymin) / 2 + tymin;
        tiles.sort(function (a, b) {
            var a_distance, b_distance;
            a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));
            b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));
            return a_distance - b_distance;
        });
        return tiles;
    };
    TileSource.prototype.prune_tiles = function () {
        var key, ref, ref1, results, tile;
        ref = this.tiles;
        for (key in ref) {
            tile = ref[key];
            tile.retain = tile.current || tile.tile_coords[2] < 3;
            if (tile.current) {
                this.retain_neighbors(tile);
                this.retain_children(tile);
                this.retain_parents(tile);
            }
        }
        ref1 = this.tiles;
        results = [];
        for (key in ref1) {
            tile = ref1[key];
            if (!tile.retain) {
                results.push(this.remove_tile(key));
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    TileSource.prototype.remove_tile = function (key) {
        var tile;
        tile = this.tiles[key];
        if (tile != null) {
            this.pool.push(tile.img);
            return delete this.tiles[key];
        }
    };
    TileSource.prototype.get_image_url = function (x, y, z) {
        var image_url;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
    };
    TileSource.prototype.retain_neighbors = function (reference_tile) {
        throw new Error('Not Implemented');
    };
    TileSource.prototype.retain_parents = function (reference_tile) {
        throw new Error('Not Implemented');
    };
    TileSource.prototype.retain_children = function (reference_tile) {
        throw new Error('Not Implemented');
    };
    TileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {
        throw new Error('Not Implemented');
    };
    TileSource.prototype.quadkey_to_tile_xyz = function (quadkey) {
        throw new Error('Not Implemented');
    };
    return TileSource;
}(model_1.Model);    
},
/* models/tiles/tile_utils */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var proj4_1 = require(29    /* core/util/proj4 */);
exports.ProjectionUtils = function () {
    function ProjectionUtils() {
        this.origin_shift = 2 * Math.PI * 6378137 / 2;
    }
    ProjectionUtils.prototype.geographic_to_meters = function (xLon, yLat) {
        return proj4_1.proj4(proj4_1.wgs84, proj4_1.mercator, [
            xLon,
            yLat
        ]);
    };
    ProjectionUtils.prototype.meters_to_geographic = function (mx, my) {
        return proj4_1.proj4(proj4_1.mercator, proj4_1.wgs84, [
            mx,
            my
        ]);
    };
    ProjectionUtils.prototype.geographic_extent_to_meters = function (extent) {
        var ref, ref1, xmax, xmin, ymax, ymin;
        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
        ref = this.geographic_to_meters(xmin, ymin), xmin = ref[0], ymin = ref[1];
        ref1 = this.geographic_to_meters(xmax, ymax), xmax = ref1[0], ymax = ref1[1];
        return [
            xmin,
            ymin,
            xmax,
            ymax
        ];
    };
    ProjectionUtils.prototype.meters_extent_to_geographic = function (extent) {
        var ref, ref1, xmax, xmin, ymax, ymin;
        xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
        ref = this.meters_to_geographic(xmin, ymin), xmin = ref[0], ymin = ref[1];
        ref1 = this.meters_to_geographic(xmax, ymax), xmax = ref1[0], ymax = ref1[1];
        return [
            xmin,
            ymin,
            xmax,
            ymax
        ];
    };
    return ProjectionUtils;
}();    
},
/* models/tiles/tms_tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var mercator_tile_source_1 = require(195    /* ./mercator_tile_source */);
exports.TMSTileSource = function (superClass) {
    extend(TMSTileSource, superClass);
    function TMSTileSource() {
        return TMSTileSource.__super__.constructor.apply(this, arguments);
    }
    TMSTileSource.prototype.type = 'TMSTileSource';
    TMSTileSource.prototype.get_image_url = function (x, y, z) {
        var image_url;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
    };
    return TMSTileSource;
}(mercator_tile_source_1.MercatorTileSource);    
},
/* models/tiles/wmts_tile_source */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var mercator_tile_source_1 = require(195    /* ./mercator_tile_source */);
exports.WMTSTileSource = function (superClass) {
    extend(WMTSTileSource, superClass);
    function WMTSTileSource() {
        return WMTSTileSource.__super__.constructor.apply(this, arguments);
    }
    WMTSTileSource.prototype.type = 'WMTSTileSource';
    WMTSTileSource.prototype.get_image_url = function (x, y, z) {
        var image_url, ref;
        image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
        ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];
        return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
    };
    return WMTSTileSource;
}(mercator_tile_source_1.MercatorTileSource);    
},
/* models/tools/actions/action_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var button_tool_1 = require(210    /* ../button_tool */);
var signaling_1 = require(18    /* core/signaling */);
exports.ActionToolButtonView = function (superClass) {
    extend(ActionToolButtonView, superClass);
    function ActionToolButtonView() {
        return ActionToolButtonView.__super__.constructor.apply(this, arguments);
    }
    ActionToolButtonView.prototype._clicked = function () {
        return this.model['do'].emit();
    };
    return ActionToolButtonView;
}(button_tool_1.ButtonToolButtonView);
exports.ActionToolView = function (superClass) {
    extend(ActionToolView, superClass);
    function ActionToolView() {
        return ActionToolView.__super__.constructor.apply(this, arguments);
    }
    ActionToolView.prototype.initialize = function (options) {
        ActionToolView.__super__.initialize.call(this, options);
        return this.connect(this.model['do'], function () {
            return this.doit();
        });
    };
    return ActionToolView;
}(button_tool_1.ButtonToolView);
exports.ActionTool = function (superClass) {
    extend(ActionTool, superClass);
    function ActionTool() {
        return ActionTool.__super__.constructor.apply(this, arguments);
    }
    ActionTool.prototype.initialize = function (attrs, options) {
        ActionTool.__super__.initialize.call(this, attrs, options);
        return this['do'] = new signaling_1.Signal(this, 'do');
    };
    return ActionTool;
}(button_tool_1.ButtonTool);    
},
/* models/tools/actions/help_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
var p = require(13    /* core/properties */);
exports.HelpToolView = function (superClass) {
    extend(HelpToolView, superClass);
    function HelpToolView() {
        return HelpToolView.__super__.constructor.apply(this, arguments);
    }
    HelpToolView.prototype.doit = function () {
        return window.open(this.model.redirect);
    };
    return HelpToolView;
}(action_tool_1.ActionToolView);
exports.HelpTool = function (superClass) {
    extend(HelpTool, superClass);
    function HelpTool() {
        return HelpTool.__super__.constructor.apply(this, arguments);
    }
    HelpTool.prototype.default_view = exports.HelpToolView;
    HelpTool.prototype.type = 'HelpTool';
    HelpTool.prototype.tool_name = 'Help';
    HelpTool.prototype.icon = 'bk-tool-icon-help';
    HelpTool.define({
        help_tooltip: [
            p.String,
            'Click the question mark to learn more about Bokeh plot tools.'
        ],
        redirect: [
            p.String,
            'https://bokeh.pydata.org/en/latest/docs/user_guide/tools.html#built-in-tools'
        ]
    });
    HelpTool.getters({
        tooltip: function () {
            return this.help_tooltip;
        }
    });
    return HelpTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/redo_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
exports.RedoToolView = function (superClass) {
    extend(RedoToolView, superClass);
    function RedoToolView() {
        return RedoToolView.__super__.constructor.apply(this, arguments);
    }
    RedoToolView.prototype.initialize = function (options) {
        RedoToolView.__super__.initialize.call(this, options);
        return this.connect(this.plot_view.state_changed, function (_this) {
            return function () {
                return _this.model.disabled = !_this.plot_view.can_redo();
            };
        }(this));
    };
    RedoToolView.prototype.doit = function () {
        return this.plot_view.redo();
    };
    return RedoToolView;
}(action_tool_1.ActionToolView);
exports.RedoTool = function (superClass) {
    extend(RedoTool, superClass);
    function RedoTool() {
        return RedoTool.__super__.constructor.apply(this, arguments);
    }
    RedoTool.prototype.default_view = exports.RedoToolView;
    RedoTool.prototype.type = 'RedoTool';
    RedoTool.prototype.tool_name = 'Redo';
    RedoTool.prototype.icon = 'bk-tool-icon-redo';
    RedoTool.override({ disabled: true });
    return RedoTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/reset_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
var p = require(13    /* core/properties */);
exports.ResetToolView = function (superClass) {
    extend(ResetToolView, superClass);
    function ResetToolView() {
        return ResetToolView.__super__.constructor.apply(this, arguments);
    }
    ResetToolView.prototype.doit = function () {
        this.plot_view.clear_state();
        this.plot_view.reset_range();
        this.plot_view.reset_selection();
        if (this.model.reset_size) {
            return this.plot_view.reset_dimensions();
        }
    };
    return ResetToolView;
}(action_tool_1.ActionToolView);
exports.ResetTool = function (superClass) {
    extend(ResetTool, superClass);
    function ResetTool() {
        return ResetTool.__super__.constructor.apply(this, arguments);
    }
    ResetTool.prototype.default_view = exports.ResetToolView;
    ResetTool.prototype.type = 'ResetTool';
    ResetTool.prototype.tool_name = 'Reset';
    ResetTool.prototype.icon = 'bk-tool-icon-reset';
    ResetTool.define({
        reset_size: [
            p.Bool,
            true
        ]
    });
    return ResetTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/save_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
exports.SaveToolView = function (superClass) {
    extend(SaveToolView, superClass);
    function SaveToolView() {
        return SaveToolView.__super__.constructor.apply(this, arguments);
    }
    SaveToolView.prototype.doit = function () {
        return this.plot_view.save('bokeh_plot');
    };
    return SaveToolView;
}(action_tool_1.ActionToolView);
exports.SaveTool = function (superClass) {
    extend(SaveTool, superClass);
    function SaveTool() {
        return SaveTool.__super__.constructor.apply(this, arguments);
    }
    SaveTool.prototype.default_view = exports.SaveToolView;
    SaveTool.prototype.type = 'SaveTool';
    SaveTool.prototype.tool_name = 'Save';
    SaveTool.prototype.icon = 'bk-tool-icon-save';
    return SaveTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/undo_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
exports.UndoToolView = function (superClass) {
    extend(UndoToolView, superClass);
    function UndoToolView() {
        return UndoToolView.__super__.constructor.apply(this, arguments);
    }
    UndoToolView.prototype.initialize = function (options) {
        UndoToolView.__super__.initialize.call(this, options);
        return this.connect(this.plot_view.state_changed, function (_this) {
            return function () {
                return _this.model.disabled = !_this.plot_view.can_undo();
            };
        }(this));
    };
    UndoToolView.prototype.doit = function () {
        return this.plot_view.undo();
    };
    return UndoToolView;
}(action_tool_1.ActionToolView);
exports.UndoTool = function (superClass) {
    extend(UndoTool, superClass);
    function UndoTool() {
        return UndoTool.__super__.constructor.apply(this, arguments);
    }
    UndoTool.prototype.default_view = exports.UndoToolView;
    UndoTool.prototype.type = 'UndoTool';
    UndoTool.prototype.tool_name = 'Undo';
    UndoTool.prototype.icon = 'bk-tool-icon-undo';
    UndoTool.override({ disabled: true });
    return UndoTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/zoom_in_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
var zoom_1 = require(42    /* core/util/zoom */);
var p = require(13    /* core/properties */);
exports.ZoomInToolView = function (superClass) {
    extend(ZoomInToolView, superClass);
    function ZoomInToolView() {
        return ZoomInToolView.__super__.constructor.apply(this, arguments);
    }
    ZoomInToolView.prototype.doit = function () {
        var dims, frame, h_axis, v_axis, zoom_info;
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        h_axis = dims === 'width' || dims === 'both';
        v_axis = dims === 'height' || dims === 'both';
        zoom_info = zoom_1.scale_range(frame, this.model.factor, h_axis, v_axis);
        this.plot_view.push_state('zoom_out', { range: zoom_info });
        this.plot_view.update_range(zoom_info, false, true);
        this.plot_view.interactive_timestamp = Date.now();
        return null;
    };
    return ZoomInToolView;
}(action_tool_1.ActionToolView);
exports.ZoomInTool = function (superClass) {
    extend(ZoomInTool, superClass);
    function ZoomInTool() {
        return ZoomInTool.__super__.constructor.apply(this, arguments);
    }
    ZoomInTool.prototype.default_view = exports.ZoomInToolView;
    ZoomInTool.prototype.type = 'ZoomInTool';
    ZoomInTool.prototype.tool_name = 'Zoom In';
    ZoomInTool.prototype.icon = 'bk-tool-icon-zoom-in';
    ZoomInTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    ZoomInTool.define({
        factor: [
            p.Percent,
            0.1
        ],
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    return ZoomInTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/actions/zoom_out_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var action_tool_1 = require(202    /* ./action_tool */);
var zoom_1 = require(42    /* core/util/zoom */);
var p = require(13    /* core/properties */);
exports.ZoomOutToolView = function (superClass) {
    extend(ZoomOutToolView, superClass);
    function ZoomOutToolView() {
        return ZoomOutToolView.__super__.constructor.apply(this, arguments);
    }
    ZoomOutToolView.prototype.doit = function () {
        var dims, frame, h_axis, v_axis, zoom_info;
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        h_axis = dims === 'width' || dims === 'both';
        v_axis = dims === 'height' || dims === 'both';
        zoom_info = zoom_1.scale_range(frame, -this.model.factor, h_axis, v_axis);
        this.plot_view.push_state('zoom_out', { range: zoom_info });
        this.plot_view.update_range(zoom_info, false, true);
        this.plot_view.interactive_timestamp = Date.now();
        return null;
    };
    return ZoomOutToolView;
}(action_tool_1.ActionToolView);
exports.ZoomOutTool = function (superClass) {
    extend(ZoomOutTool, superClass);
    function ZoomOutTool() {
        return ZoomOutTool.__super__.constructor.apply(this, arguments);
    }
    ZoomOutTool.prototype.default_view = exports.ZoomOutToolView;
    ZoomOutTool.prototype.type = 'ZoomOutTool';
    ZoomOutTool.prototype.tool_name = 'Zoom Out';
    ZoomOutTool.prototype.icon = 'bk-tool-icon-zoom-out';
    ZoomOutTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    ZoomOutTool.define({
        factor: [
            p.Percent,
            0.1
        ],
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    return ZoomOutTool;
}(action_tool_1.ActionTool);    
},
/* models/tools/button_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var dom_view_1 = require(5    /* core/dom_view */);
var tool_1 = require(226    /* ./tool */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
exports.ButtonToolButtonView = function (superClass) {
    extend(ButtonToolButtonView, superClass);
    function ButtonToolButtonView() {
        return ButtonToolButtonView.__super__.constructor.apply(this, arguments);
    }
    ButtonToolButtonView.prototype.className = 'bk-toolbar-button';
    ButtonToolButtonView.prototype.initialize = function (options) {
        ButtonToolButtonView.__super__.initialize.call(this, options);
        this.connect(this.model.change, function (_this) {
            return function () {
                return _this.render();
            };
        }(this));
        this.el.addEventListener('click', function (_this) {
            return function (e) {
                return _this._clicked(e);
            };
        }(this));
        return this.render();
    };
    ButtonToolButtonView.prototype.render = function () {
        var icon, tip;
        dom_1.empty(this.el);
        this.el.disabled = this.model.disabled;
        icon = dom_1.div({
            'class': [
                'bk-btn-icon',
                this.model.icon
            ]
        });
        tip = dom_1.span({ 'class': 'bk-tip' }, this.model.tooltip);
        this.el.appendChild(icon);
        return this.el.appendChild(tip);
    };
    ButtonToolButtonView.prototype._clicked = function (e) {
    };
    return ButtonToolButtonView;
}(dom_view_1.DOMView);
exports.ButtonToolView = function (superClass) {
    extend(ButtonToolView, superClass);
    function ButtonToolView() {
        return ButtonToolView.__super__.constructor.apply(this, arguments);
    }
    return ButtonToolView;
}(tool_1.ToolView);
exports.ButtonTool = function (superClass) {
    extend(ButtonTool, superClass);
    function ButtonTool() {
        return ButtonTool.__super__.constructor.apply(this, arguments);
    }
    ButtonTool.prototype.icon = null;
    ButtonTool.getters({
        tooltip: function () {
            return this.tool_name;
        }
    });
    ButtonTool.internal({
        disabled: [
            p.Boolean,
            false
        ]
    });
    return ButtonTool;
}(tool_1.Tool);    
},
/* models/tools/gestures/box_select_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var DEFAULT_BOX_OVERLAY, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var select_tool_1 = require(217    /* ./select_tool */);
var box_annotation_1 = require(53    /* ../../annotations/box_annotation */);
var p = require(13    /* core/properties */);
exports.BoxSelectToolView = function (superClass) {
    extend(BoxSelectToolView, superClass);
    function BoxSelectToolView() {
        return BoxSelectToolView.__super__.constructor.apply(this, arguments);
    }
    BoxSelectToolView.prototype._pan_start = function (e) {
        var canvas;
        canvas = this.plot_view.canvas;
        this._baseboint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        return null;
    };
    BoxSelectToolView.prototype._pan = function (e) {
        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;
        canvas = this.plot_view.canvas;
        curpoint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];
        this.model.overlay.update({
            left: vxlim[0],
            right: vxlim[1],
            top: vylim[1],
            bottom: vylim[0]
        });
        if (this.model.select_every_mousemove) {
            append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;
            this._do_select(vxlim, vylim, false, append);
        }
        return null;
    };
    BoxSelectToolView.prototype._pan_end = function (e) {
        var append, canvas, curpoint, dims, frame, ref, ref1, vxlim, vylim;
        canvas = this.plot_view.canvas;
        curpoint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        ref = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = ref[0], vylim = ref[1];
        append = (ref1 = e.srcEvent.shiftKey) != null ? ref1 : false;
        this._do_select(vxlim, vylim, true, append);
        this.model.overlay.update({
            left: null,
            right: null,
            top: null,
            bottom: null
        });
        this._baseboint = null;
        this.plot_view.push_state('box_select', { selection: this.plot_view.get_selection() });
        return null;
    };
    BoxSelectToolView.prototype._do_select = function (arg, arg1, final, append) {
        var geometry, vx0, vx1, vy0, vy1;
        vx0 = arg[0], vx1 = arg[1];
        vy0 = arg1[0], vy1 = arg1[1];
        if (append == null) {
            append = false;
        }
        geometry = {
            type: 'rect',
            vx0: vx0,
            vx1: vx1,
            vy0: vy0,
            vy1: vy1
        };
        return this._select(geometry, final, append);
    };
    BoxSelectToolView.prototype._emit_callback = function (geometry) {
        var canvas, frame, r, xscale, yscale;
        r = this.computed_renderers[0];
        canvas = this.plot_model.canvas;
        frame = this.plot_model.frame;
        geometry['sx0'] = canvas.vx_to_sx(geometry.vx0);
        geometry['sx1'] = canvas.vx_to_sx(geometry.vx1);
        geometry['sy0'] = canvas.vy_to_sy(geometry.vy0);
        geometry['sy1'] = canvas.vy_to_sy(geometry.vy1);
        xscale = frame.xscales[r.x_range_name];
        yscale = frame.yscales[r.y_range_name];
        geometry['x0'] = xscale.invert(geometry.vx0);
        geometry['x1'] = xscale.invert(geometry.vx1);
        geometry['y0'] = yscale.invert(geometry.vy0);
        geometry['y1'] = yscale.invert(geometry.vy1);
        this.model.callback.execute(this.model, { geometry: geometry });
    };
    return BoxSelectToolView;
}(select_tool_1.SelectToolView);
DEFAULT_BOX_OVERLAY = function () {
    return new box_annotation_1.BoxAnnotation({
        level: 'overlay',
        render_mode: 'css',
        top_units: 'screen',
        left_units: 'screen',
        bottom_units: 'screen',
        right_units: 'screen',
        fill_color: { value: 'lightgrey' },
        fill_alpha: { value: 0.5 },
        line_color: { value: 'black' },
        line_alpha: { value: 1 },
        line_width: { value: 2 },
        line_dash: {
            value: [
                4,
                4
            ]
        }
    });
};
exports.BoxSelectTool = function (superClass) {
    extend(BoxSelectTool, superClass);
    function BoxSelectTool() {
        return BoxSelectTool.__super__.constructor.apply(this, arguments);
    }
    BoxSelectTool.prototype.default_view = exports.BoxSelectToolView;
    BoxSelectTool.prototype.type = 'BoxSelectTool';
    BoxSelectTool.prototype.tool_name = 'Box Select';
    BoxSelectTool.prototype.icon = 'bk-tool-icon-box-select';
    BoxSelectTool.prototype.event_type = 'pan';
    BoxSelectTool.prototype.default_order = 30;
    BoxSelectTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        select_every_mousemove: [
            p.Bool,
            false
        ],
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_BOX_OVERLAY
        ]
    });
    BoxSelectTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    return BoxSelectTool;
}(select_tool_1.SelectTool);    
},
/* models/tools/gestures/box_zoom_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var DEFAULT_BOX_OVERLAY, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var gesture_tool_1 = require(213    /* ./gesture_tool */);
var box_annotation_1 = require(53    /* ../../annotations/box_annotation */);
var p = require(13    /* core/properties */);
exports.BoxZoomToolView = function (superClass) {
    extend(BoxZoomToolView, superClass);
    function BoxZoomToolView() {
        return BoxZoomToolView.__super__.constructor.apply(this, arguments);
    }
    BoxZoomToolView.prototype._match_aspect = function (basepoint, curpoint, frame) {
        var a, bottom, h, hend, hstart, left, ref, ref1, right, top, va, vend, vh, vstart, vw, w, xmod, ymod;
        hend = frame.h_range.end;
        hstart = frame.h_range.start;
        vend = frame.v_range.end;
        vstart = frame.v_range.start;
        w = hend - hstart;
        h = vend - vstart;
        a = w / h;
        vw = Math.abs(basepoint[0] - curpoint[0]);
        vh = Math.abs(basepoint[1] - curpoint[1]);
        if (vh === 0) {
            va = 0;
        } else {
            va = vw / vh;
        }
        if (va >= a) {
            ref = [
                1,
                va / a
            ], xmod = ref[0], ymod = ref[1];
        } else {
            ref1 = [
                a / va,
                1
            ], xmod = ref1[0], ymod = ref1[1];
        }
        if (basepoint[0] <= curpoint[0]) {
            left = basepoint[0];
            right = basepoint[0] + vw * xmod;
            if (right > hend) {
                right = hend;
            }
        } else {
            right = basepoint[0];
            left = basepoint[0] - vw * xmod;
            if (left < hstart) {
                left = hstart;
            }
        }
        vw = Math.abs(right - left);
        if (basepoint[1] <= curpoint[1]) {
            bottom = basepoint[1];
            top = basepoint[1] + vw / a;
            if (top > vend) {
                top = vend;
            }
        } else {
            top = basepoint[1];
            bottom = basepoint[1] - vw / a;
            if (bottom < vstart) {
                bottom = vstart;
            }
        }
        vh = Math.abs(top - bottom);
        if (basepoint[0] <= curpoint[0]) {
            right = basepoint[0] + a * vh;
        } else {
            left = basepoint[0] - a * vh;
        }
        return [
            [
                left,
                right
            ],
            [
                bottom,
                top
            ]
        ];
    };
    BoxZoomToolView.prototype._pan_start = function (e) {
        var canvas;
        canvas = this.plot_view.canvas;
        this._baseboint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        return null;
    };
    BoxZoomToolView.prototype._pan = function (e) {
        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;
        canvas = this.plot_view.canvas;
        curpoint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        if (this.model.match_aspect && dims === 'both') {
            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];
        } else {
            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];
        }
        this.model.overlay.update({
            left: vx[0],
            right: vx[1],
            top: vy[1],
            bottom: vy[0]
        });
        return null;
    };
    BoxZoomToolView.prototype._pan_end = function (e) {
        var canvas, curpoint, dims, frame, ref, ref1, vx, vy;
        canvas = this.plot_view.canvas;
        curpoint = [
            canvas.sx_to_vx(e.bokeh.sx),
            canvas.sy_to_vy(e.bokeh.sy)
        ];
        frame = this.plot_model.frame;
        dims = this.model.dimensions;
        if (this.model.match_aspect && dims === 'both') {
            ref = this._match_aspect(this._baseboint, curpoint, frame), vx = ref[0], vy = ref[1];
        } else {
            ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vx = ref1[0], vy = ref1[1];
        }
        this._update(vx, vy);
        this.model.overlay.update({
            left: null,
            right: null,
            top: null,
            bottom: null
        });
        this._baseboint = null;
        return null;
    };
    BoxZoomToolView.prototype._update = function (vx, vy) {
        var end, name, ref, ref1, ref2, ref3, scale, start, xrs, yrs, zoom_info;
        if (Math.abs(vx[1] - vx[0]) <= 5 || Math.abs(vy[1] - vy[0]) <= 5) {
            return;
        }
        xrs = {};
        ref = this.plot_view.frame.xscales;
        for (name in ref) {
            scale = ref[name];
            ref1 = scale.v_invert(vx), start = ref1[0], end = ref1[1];
            xrs[name] = {
                start: start,
                end: end
            };
        }
        yrs = {};
        ref2 = this.plot_view.frame.yscales;
        for (name in ref2) {
            scale = ref2[name];
            ref3 = scale.v_invert(vy), start = ref3[0], end = ref3[1];
            yrs[name] = {
                start: start,
                end: end
            };
        }
        zoom_info = {
            xrs: xrs,
            yrs: yrs
        };
        this.plot_view.push_state('box_zoom', { range: zoom_info });
        return this.plot_view.update_range(zoom_info);
    };
    return BoxZoomToolView;
}(gesture_tool_1.GestureToolView);
DEFAULT_BOX_OVERLAY = function () {
    return new box_annotation_1.BoxAnnotation({
        level: 'overlay',
        render_mode: 'css',
        top_units: 'screen',
        left_units: 'screen',
        bottom_units: 'screen',
        right_units: 'screen',
        fill_color: { value: 'lightgrey' },
        fill_alpha: { value: 0.5 },
        line_color: { value: 'black' },
        line_alpha: { value: 1 },
        line_width: { value: 2 },
        line_dash: {
            value: [
                4,
                4
            ]
        }
    });
};
exports.BoxZoomTool = function (superClass) {
    extend(BoxZoomTool, superClass);
    function BoxZoomTool() {
        return BoxZoomTool.__super__.constructor.apply(this, arguments);
    }
    BoxZoomTool.prototype.default_view = exports.BoxZoomToolView;
    BoxZoomTool.prototype.type = 'BoxZoomTool';
    BoxZoomTool.prototype.tool_name = 'Box Zoom';
    BoxZoomTool.prototype.icon = 'bk-tool-icon-box-zoom';
    BoxZoomTool.prototype.event_type = 'pan';
    BoxZoomTool.prototype.default_order = 20;
    BoxZoomTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    BoxZoomTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        overlay: [
            p.Instance,
            DEFAULT_BOX_OVERLAY
        ],
        match_aspect: [
            p.Bool,
            false
        ]
    });
    return BoxZoomTool;
}(gesture_tool_1.GestureTool);    
},
/* models/tools/gestures/gesture_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var button_tool_1 = require(210    /* ../button_tool */);
exports.GestureToolView = function (superClass) {
    extend(GestureToolView, superClass);
    function GestureToolView() {
        return GestureToolView.__super__.constructor.apply(this, arguments);
    }
    return GestureToolView;
}(button_tool_1.ButtonToolView);
exports.GestureTool = function (superClass) {
    extend(GestureTool, superClass);
    function GestureTool() {
        return GestureTool.__super__.constructor.apply(this, arguments);
    }
    GestureTool.prototype.event_type = null;
    GestureTool.prototype.default_order = null;
    return GestureTool;
}(button_tool_1.ButtonTool);    
},
/* models/tools/gestures/lasso_select_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var DEFAULT_POLY_OVERLAY, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var select_tool_1 = require(217    /* ./select_tool */);
var poly_annotation_1 = require(60    /* ../../annotations/poly_annotation */);
var p = require(13    /* core/properties */);
exports.LassoSelectToolView = function (superClass) {
    extend(LassoSelectToolView, superClass);
    function LassoSelectToolView() {
        return LassoSelectToolView.__super__.constructor.apply(this, arguments);
    }
    LassoSelectToolView.prototype.initialize = function (options) {
        LassoSelectToolView.__super__.initialize.call(this, options);
        this.connect(this.model.properties.active.change, function () {
            return this._active_change();
        });
        return this.data = null;
    };
    LassoSelectToolView.prototype._active_change = function () {
        if (!this.model.active) {
            return this._clear_overlay();
        }
    };
    LassoSelectToolView.prototype._keyup = function (e) {
        if (e.keyCode === 13) {
            return this._clear_overlay();
        }
    };
    LassoSelectToolView.prototype._pan_start = function (e) {
        var canvas, vx, vy;
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        this.data = {
            vx: [vx],
            vy: [vy]
        };
        return null;
    };
    LassoSelectToolView.prototype._pan = function (e) {
        var append, canvas, h_range, overlay, ref, v_range, vx, vy;
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        h_range = this.plot_model.frame.h_range;
        v_range = this.plot_model.frame.v_range;
        if (vx > h_range.end) {
            vx = h_range.end;
        }
        if (vx < h_range.start) {
            vx = h_range.start;
        }
        if (vy > v_range.end) {
            vy = v_range.end;
        }
        if (vy < v_range.start) {
            vy = v_range.start;
        }
        this.data.vx.push(vx);
        this.data.vy.push(vy);
        overlay = this.model.overlay;
        overlay.update({
            xs: this.data.vx,
            ys: this.data.vy
        });
        if (this.model.select_every_mousemove) {
            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
            return this._do_select(this.data.vx, this.data.vy, false, append);
        }
    };
    LassoSelectToolView.prototype._pan_end = function (e) {
        var append, ref;
        this._clear_overlay();
        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
        this._do_select(this.data.vx, this.data.vy, true, append);
        return this.plot_view.push_state('lasso_select', { selection: this.plot_view.get_selection() });
    };
    LassoSelectToolView.prototype._clear_overlay = function () {
        return this.model.overlay.update({
            xs: [],
            ys: []
        });
    };
    LassoSelectToolView.prototype._do_select = function (vx, vy, final, append) {
        var geometry;
        geometry = {
            type: 'poly',
            vx: vx,
            vy: vy
        };
        return this._select(geometry, final, append);
    };
    LassoSelectToolView.prototype._emit_callback = function (geometry) {
        var canvas, frame, r, xscale, yscale;
        r = this.computed_renderers[0];
        canvas = this.plot_model.canvas;
        frame = this.plot_model.frame;
        geometry['sx'] = canvas.v_vx_to_sx(geometry.vx);
        geometry['sy'] = canvas.v_vy_to_sy(geometry.vy);
        xscale = frame.xscales[r.x_range_name];
        yscale = frame.yscales[r.y_range_name];
        geometry['x'] = xscale.v_invert(geometry.vx);
        geometry['y'] = yscale.v_invert(geometry.vy);
        this.model.callback.execute(this.model, { geometry: geometry });
    };
    return LassoSelectToolView;
}(select_tool_1.SelectToolView);
DEFAULT_POLY_OVERLAY = function () {
    return new poly_annotation_1.PolyAnnotation({
        level: 'overlay',
        xs_units: 'screen',
        ys_units: 'screen',
        fill_color: { value: 'lightgrey' },
        fill_alpha: { value: 0.5 },
        line_color: { value: 'black' },
        line_alpha: { value: 1 },
        line_width: { value: 2 },
        line_dash: {
            value: [
                4,
                4
            ]
        }
    });
};
exports.LassoSelectTool = function (superClass) {
    extend(LassoSelectTool, superClass);
    function LassoSelectTool() {
        return LassoSelectTool.__super__.constructor.apply(this, arguments);
    }
    LassoSelectTool.prototype.default_view = exports.LassoSelectToolView;
    LassoSelectTool.prototype.type = 'LassoSelectTool';
    LassoSelectTool.prototype.tool_name = 'Lasso Select';
    LassoSelectTool.prototype.icon = 'bk-tool-icon-lasso-select';
    LassoSelectTool.prototype.event_type = 'pan';
    LassoSelectTool.prototype.default_order = 12;
    LassoSelectTool.define({
        select_every_mousemove: [
            p.Bool,
            true
        ],
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_POLY_OVERLAY
        ]
    });
    return LassoSelectTool;
}(select_tool_1.SelectTool);    
},
/* models/tools/gestures/pan_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var gesture_tool_1 = require(213    /* ./gesture_tool */);
var p = require(13    /* core/properties */);
exports.PanToolView = function (superClass) {
    extend(PanToolView, superClass);
    function PanToolView() {
        return PanToolView.__super__.constructor.apply(this, arguments);
    }
    PanToolView.prototype._pan_start = function (e) {
        var canvas, frame, hr, vr, vx, vy;
        this.last_dx = 0;
        this.last_dy = 0;
        canvas = this.plot_view.canvas;
        frame = this.plot_view.frame;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        if (!frame.contains(vx, vy)) {
            hr = frame.h_range;
            vr = frame.v_range;
            if (vx < hr.start || vx > hr.end) {
                this.v_axis_only = true;
            }
            if (vy < vr.start || vy > vr.end) {
                this.h_axis_only = true;
            }
        }
        return this.plot_view.interactive_timestamp = Date.now();
    };
    PanToolView.prototype._pan = function (e) {
        this._update(e.deltaX, -e.deltaY);
        return this.plot_view.interactive_timestamp = Date.now();
    };
    PanToolView.prototype._pan_end = function (e) {
        this.h_axis_only = false;
        this.v_axis_only = false;
        if (this.pan_info != null) {
            return this.plot_view.push_state('pan', { range: this.pan_info });
        }
    };
    PanToolView.prototype._update = function (dx, dy) {
        var dims, end, frame, hr, is_panning, name, new_dx, new_dy, ref, ref1, ref2, ref3, scale, sdx, sdy, start, sx0, sx1, sx_high, sx_low, sy0, sy1, sy_high, sy_low, vr, xrs, yrs;
        frame = this.plot_view.frame;
        new_dx = dx - this.last_dx;
        new_dy = dy - this.last_dy;
        hr = frame.h_range;
        sx_low = hr.start - new_dx;
        sx_high = hr.end - new_dx;
        vr = frame.v_range;
        sy_low = vr.start - new_dy;
        sy_high = vr.end - new_dy;
        dims = this.model.dimensions;
        if ((dims === 'width' || dims === 'both') && !this.v_axis_only) {
            sx0 = sx_low;
            sx1 = sx_high;
            sdx = -new_dx;
        } else {
            sx0 = hr.start;
            sx1 = hr.end;
            sdx = 0;
        }
        if ((dims === 'height' || dims === 'both') && !this.h_axis_only) {
            sy0 = sy_low;
            sy1 = sy_high;
            sdy = new_dy;
        } else {
            sy0 = vr.start;
            sy1 = vr.end;
            sdy = 0;
        }
        this.last_dx = dx;
        this.last_dy = dy;
        xrs = {};
        ref = frame.xscales;
        for (name in ref) {
            scale = ref[name];
            ref1 = scale.v_invert([
                sx0,
                sx1
            ]), start = ref1[0], end = ref1[1];
            xrs[name] = {
                start: start,
                end: end
            };
        }
        yrs = {};
        ref2 = frame.yscales;
        for (name in ref2) {
            scale = ref2[name];
            ref3 = scale.v_invert([
                sy0,
                sy1
            ]), start = ref3[0], end = ref3[1];
            yrs[name] = {
                start: start,
                end: end
            };
        }
        this.pan_info = {
            xrs: xrs,
            yrs: yrs,
            sdx: sdx,
            sdy: sdy
        };
        this.plot_view.update_range(this.pan_info, is_panning = true);
        return null;
    };
    return PanToolView;
}(gesture_tool_1.GestureToolView);
exports.PanTool = function (superClass) {
    extend(PanTool, superClass);
    function PanTool() {
        return PanTool.__super__.constructor.apply(this, arguments);
    }
    PanTool.prototype.default_view = exports.PanToolView;
    PanTool.prototype.type = 'PanTool';
    PanTool.prototype.tool_name = 'Pan';
    PanTool.prototype.event_type = 'pan';
    PanTool.prototype.default_order = 10;
    PanTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    PanTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip('Pan', this.dimensions);
        },
        icon: function () {
            var suffix;
            suffix = function () {
                switch (this.dimensions) {
                case 'both':
                    return 'pan';
                case 'width':
                    return 'xpan';
                case 'height':
                    return 'ypan';
                }
            }.call(this);
            return 'bk-tool-icon-' + suffix;
        }
    });
    return PanTool;
}(gesture_tool_1.GestureTool);    
},
/* models/tools/gestures/poly_select_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var DEFAULT_POLY_OVERLAY, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var select_tool_1 = require(217    /* ./select_tool */);
var poly_annotation_1 = require(60    /* ../../annotations/poly_annotation */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.PolySelectToolView = function (superClass) {
    extend(PolySelectToolView, superClass);
    function PolySelectToolView() {
        return PolySelectToolView.__super__.constructor.apply(this, arguments);
    }
    PolySelectToolView.prototype.initialize = function (options) {
        PolySelectToolView.__super__.initialize.call(this, options);
        this.connect(this.model.properties.active.change, function () {
            return this._active_change();
        });
        return this.data = {
            vx: [],
            vy: []
        };
    };
    PolySelectToolView.prototype._active_change = function () {
        if (!this.model.active) {
            return this._clear_data();
        }
    };
    PolySelectToolView.prototype._keyup = function (e) {
        if (e.keyCode === 13) {
            return this._clear_data();
        }
    };
    PolySelectToolView.prototype._doubletap = function (e) {
        var append, ref;
        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
        this._do_select(this.data.vx, this.data.vy, true, append);
        this.plot_view.push_state('poly_select', { selection: this.plot_view.get_selection() });
        return this._clear_data();
    };
    PolySelectToolView.prototype._clear_data = function () {
        this.data = {
            vx: [],
            vy: []
        };
        return this.model.overlay.update({
            xs: [],
            ys: []
        });
    };
    PolySelectToolView.prototype._tap = function (e) {
        var canvas, vx, vy;
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        this.data.vx.push(vx);
        this.data.vy.push(vy);
        return this.model.overlay.update({
            xs: array_1.copy(this.data.vx),
            ys: array_1.copy(this.data.vy)
        });
    };
    PolySelectToolView.prototype._do_select = function (vx, vy, final, append) {
        var geometry;
        geometry = {
            type: 'poly',
            vx: vx,
            vy: vy
        };
        return this._select(geometry, final, append);
    };
    PolySelectToolView.prototype._emit_callback = function (geometry) {
        var canvas, frame, r, xscale, yscale;
        r = this.computed_renderers[0];
        canvas = this.plot_model.canvas;
        frame = this.plot_model.frame;
        geometry['sx'] = canvas.v_vx_to_sx(geometry.vx);
        geometry['sy'] = canvas.v_vx_to_sx(geometry.vy);
        xscale = frame.xscales[r.x_range_name];
        yscale = frame.yscales[r.y_range_name];
        geometry['x'] = xscale.v_invert(geometry.vx);
        geometry['y'] = xscale.v_invert(geometry.vy);
        this.model.callback.execute(this.model, { geometry: geometry });
    };
    return PolySelectToolView;
}(select_tool_1.SelectToolView);
DEFAULT_POLY_OVERLAY = function () {
    return new poly_annotation_1.PolyAnnotation({
        level: 'overlay',
        xs_units: 'screen',
        ys_units: 'screen',
        fill_color: { value: 'lightgrey' },
        fill_alpha: { value: 0.5 },
        line_color: { value: 'black' },
        line_alpha: { value: 1 },
        line_width: { value: 2 },
        line_dash: {
            value: [
                4,
                4
            ]
        }
    });
};
exports.PolySelectTool = function (superClass) {
    extend(PolySelectTool, superClass);
    function PolySelectTool() {
        return PolySelectTool.__super__.constructor.apply(this, arguments);
    }
    PolySelectTool.prototype.default_view = exports.PolySelectToolView;
    PolySelectTool.prototype.type = 'PolySelectTool';
    PolySelectTool.prototype.tool_name = 'Poly Select';
    PolySelectTool.prototype.icon = 'bk-tool-icon-polygon-select';
    PolySelectTool.prototype.event_type = 'tap';
    PolySelectTool.prototype.default_order = 11;
    PolySelectTool.define({
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_POLY_OVERLAY
        ]
    });
    return PolySelectTool;
}(select_tool_1.SelectTool);    
},
/* models/tools/gestures/select_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var gesture_tool_1 = require(213    /* ./gesture_tool */);
var glyph_renderer_1 = require(156    /* ../../renderers/glyph_renderer */);
var graph_renderer_1 = require(157    /* ../../renderers/graph_renderer */);
var logging_1 = require(12    /* core/logging */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
var bokeh_events_1 = require(2    /* core/bokeh_events */);
exports.SelectToolView = function (superClass) {
    extend(SelectToolView, superClass);
    function SelectToolView() {
        return SelectToolView.__super__.constructor.apply(this, arguments);
    }
    SelectToolView.getters({
        computed_renderers: function () {
            var all_renderers, names, r, renderers;
            renderers = this.model.renderers;
            names = this.model.names;
            if (renderers.length === 0) {
                all_renderers = this.plot_model.plot.renderers;
                renderers = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = all_renderers.length; j < len; j++) {
                        r = all_renderers[j];
                        if (r instanceof glyph_renderer_1.GlyphRenderer || r instanceof graph_renderer_1.GraphRenderer) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            if (names.length > 0) {
                renderers = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = renderers.length; j < len; j++) {
                        r = renderers[j];
                        if (names.indexOf(r.name) >= 0) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            return renderers;
        }
    });
    SelectToolView.prototype._computed_renderers_by_data_source = function () {
        var j, len, r, ref, renderers_by_source, source;
        renderers_by_source = {};
        ref = this.computed_renderers;
        for (j = 0, len = ref.length; j < len; j++) {
            r = ref[j];
            if (r instanceof graph_renderer_1.GraphRenderer) {
                source = r.node_renderer.data_source.id;
            } else if (r instanceof glyph_renderer_1.GlyphRenderer) {
                source = r.data_source.id;
            }
            if (!(source in renderers_by_source)) {
                renderers_by_source[source] = [r];
            } else {
                renderers_by_source[source] = renderers_by_source[source].concat([r]);
            }
        }
        return renderers_by_source;
    };
    SelectToolView.prototype._keyup = function (e) {
        var ds, j, len, r, ref, results, sm;
        if (e.keyCode === 27) {
            ref = this.computed_renderers;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                r = ref[j];
                ds = r.data_source;
                sm = ds.selection_manager;
                results.push(sm.clear());
            }
            return results;
        }
    };
    SelectToolView.prototype._select = function (geometry, final, append) {
        var _, r, r_views, renderers, renderers_by_source, sm;
        renderers_by_source = this._computed_renderers_by_data_source();
        for (_ in renderers_by_source) {
            renderers = renderers_by_source[_];
            sm = renderers[0].get_selection_manager();
            r_views = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = renderers.length; j < len; j++) {
                    r = renderers[j];
                    results.push(this.plot_view.renderer_views[r.id]);
                }
                return results;
            }.call(this);
            sm.select(r_views, geometry, final, append);
        }
        if (this.model.callback != null) {
            this._emit_callback(geometry);
        }
        this._emit_selection_event(geometry, final);
        return null;
    };
    SelectToolView.prototype._emit_selection_event = function (geometry, final) {
        var g, i, j, ref, xm, ym;
        if (final == null) {
            final = true;
        }
        g = object_1.clone(geometry);
        xm = this.plot_view.frame.xscales['default'];
        ym = this.plot_view.frame.yscales['default'];
        switch (g.type) {
        case 'point':
            g.x = xm.invert(g.vx);
            g.y = ym.invert(g.vy);
            break;
        case 'rect':
            g.x0 = xm.invert(g.vx0);
            g.y0 = ym.invert(g.vy0);
            g.x1 = xm.invert(g.vx1);
            g.y1 = ym.invert(g.vy1);
            break;
        case 'poly':
            g.x = new Array(g.vx.length);
            g.y = new Array(g.vy.length);
            for (i = j = 0, ref = g.vx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                g.x[i] = xm.invert(g.vx[i]);
                g.y[i] = ym.invert(g.vy[i]);
            }
            break;
        default:
            logging_1.logger.debug('Unrecognized selection geometry type: \'' + g.type + '\'');
        }
        return this.plot_model.plot.trigger_event(new bokeh_events_1.SelectionGeometry({
            geometry: g,
            final: final
        }));
    };
    return SelectToolView;
}(gesture_tool_1.GestureToolView);
exports.SelectTool = function (superClass) {
    extend(SelectTool, superClass);
    function SelectTool() {
        return SelectTool.__super__.constructor.apply(this, arguments);
    }
    SelectTool.define({
        renderers: [
            p.Array,
            []
        ],
        names: [
            p.Array,
            []
        ]
    });
    SelectTool.internal({
        multi_select_modifier: [
            p.String,
            'shift'
        ]
    });
    return SelectTool;
}(gesture_tool_1.GestureTool);    
},
/* models/tools/gestures/tap_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var select_tool_1 = require(217    /* ./select_tool */);
var p = require(13    /* core/properties */);
var types_1 = require(40    /* core/util/types */);
exports.TapToolView = function (superClass) {
    extend(TapToolView, superClass);
    function TapToolView() {
        return TapToolView.__super__.constructor.apply(this, arguments);
    }
    TapToolView.prototype._tap = function (e) {
        var append, canvas, ref, vx, vy;
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
        return this._select(vx, vy, true, append);
    };
    TapToolView.prototype._select = function (vx, vy, final, append) {
        var _, callback, cb_data, did_hit, geometry, i, len, r, r_views, ref, renderers, renderers_by_source, sm;
        geometry = {
            type: 'point',
            vx: vx,
            vy: vy
        };
        callback = this.model.callback;
        cb_data = { geometries: geometry };
        if (this.model.behavior === 'select') {
            renderers_by_source = this._computed_renderers_by_data_source();
            for (_ in renderers_by_source) {
                renderers = renderers_by_source[_];
                sm = renderers[0].get_selection_manager();
                r_views = function () {
                    var i, len, results;
                    results = [];
                    for (i = 0, len = renderers.length; i < len; i++) {
                        r = renderers[i];
                        results.push(this.plot_view.renderer_views[r.id]);
                    }
                    return results;
                }.call(this);
                did_hit = sm.select(r_views, geometry, final, append);
                if (did_hit && callback != null) {
                    cb_data.source = sm.source;
                    if (types_1.isFunction(callback)) {
                        callback(this, cb_data);
                    } else {
                        callback.execute(this, cb_data);
                    }
                }
            }
            this._emit_selection_event(geometry);
            this.plot_view.push_state('tap', { selection: this.plot_view.get_selection() });
        } else {
            ref = this.computed_renderers;
            for (i = 0, len = ref.length; i < len; i++) {
                r = ref[i];
                sm = r.get_selection_manager();
                did_hit = sm.inspect(this.plot_view.renderer_views[r.id], geometry);
                if (did_hit && callback != null) {
                    cb_data.source = sm.source;
                    if (types_1.isFunction(callback)) {
                        callback(this, cb_data);
                    } else {
                        callback.execute(this, cb_data);
                    }
                }
            }
        }
        return null;
    };
    return TapToolView;
}(select_tool_1.SelectToolView);
exports.TapTool = function (superClass) {
    extend(TapTool, superClass);
    function TapTool() {
        return TapTool.__super__.constructor.apply(this, arguments);
    }
    TapTool.prototype.default_view = exports.TapToolView;
    TapTool.prototype.type = 'TapTool';
    TapTool.prototype.tool_name = 'Tap';
    TapTool.prototype.icon = 'bk-tool-icon-tap-select';
    TapTool.prototype.event_type = 'tap';
    TapTool.prototype.default_order = 10;
    TapTool.define({
        behavior: [
            p.String,
            'select'
        ],
        callback: [p.Any]
    });
    return TapTool;
}(select_tool_1.SelectTool);    
},
/* models/tools/gestures/wheel_pan_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var gesture_tool_1 = require(213    /* ./gesture_tool */);
var p = require(13    /* core/properties */);
exports.WheelPanToolView = function (superClass) {
    extend(WheelPanToolView, superClass);
    function WheelPanToolView() {
        return WheelPanToolView.__super__.constructor.apply(this, arguments);
    }
    WheelPanToolView.prototype._scroll = function (e) {
        var factor;
        factor = this.model.speed * e.bokeh.delta;
        if (factor > 0.9) {
            factor = 0.9;
        } else if (factor < -0.9) {
            factor = -0.9;
        }
        return this._update_ranges(factor);
    };
    WheelPanToolView.prototype._update_ranges = function (factor) {
        var end, frame, hr, name, pan_info, ref, ref1, ref2, ref3, ref4, ref5, scale, start, sx0, sx1, sy0, sy1, vr, vx_high, vx_low, vx_range, vy_high, vy_low, vy_range, xrs, yrs;
        frame = this.plot_model.frame;
        hr = frame.h_range;
        vr = frame.v_range;
        ref = [
            hr.start,
            hr.end
        ], vx_low = ref[0], vx_high = ref[1];
        ref1 = [
            vr.start,
            vr.end
        ], vy_low = ref1[0], vy_high = ref1[1];
        switch (this.model.dimension) {
        case 'height':
            vy_range = Math.abs(vy_high - vy_low);
            sx0 = vx_low;
            sx1 = vx_high;
            sy0 = vy_low + vy_range * factor;
            sy1 = vy_high + vy_range * factor;
            break;
        case 'width':
            vx_range = Math.abs(vx_high - vx_low);
            sx0 = vx_low - vx_range * factor;
            sx1 = vx_high - vx_range * factor;
            sy0 = vy_low;
            sy1 = vy_high;
        }
        xrs = {};
        ref2 = frame.xscales;
        for (name in ref2) {
            scale = ref2[name];
            ref3 = scale.v_invert([
                sx0,
                sx1
            ]), start = ref3[0], end = ref3[1];
            xrs[name] = {
                start: start,
                end: end
            };
        }
        yrs = {};
        ref4 = frame.yscales;
        for (name in ref4) {
            scale = ref4[name];
            ref5 = scale.v_invert([
                sy0,
                sy1
            ]), start = ref5[0], end = ref5[1];
            yrs[name] = {
                start: start,
                end: end
            };
        }
        pan_info = {
            xrs: xrs,
            yrs: yrs,
            factor: factor
        };
        this.plot_view.push_state('wheel_pan', { range: pan_info });
        this.plot_view.update_range(pan_info, false, true);
        this.plot_view.interactive_timestamp = Date.now();
        return null;
    };
    return WheelPanToolView;
}(gesture_tool_1.GestureToolView);
exports.WheelPanTool = function (superClass) {
    extend(WheelPanTool, superClass);
    function WheelPanTool() {
        return WheelPanTool.__super__.constructor.apply(this, arguments);
    }
    WheelPanTool.prototype.type = 'WheelPanTool';
    WheelPanTool.prototype.default_view = exports.WheelPanToolView;
    WheelPanTool.prototype.tool_name = 'Wheel Pan';
    WheelPanTool.prototype.icon = 'bk-tool-icon-wheel-pan';
    WheelPanTool.prototype.event_type = 'scroll';
    WheelPanTool.prototype.default_order = 12;
    WheelPanTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimension);
        }
    });
    WheelPanTool.define({
        dimension: [
            p.Dimension,
            'width'
        ]
    });
    WheelPanTool.internal({
        speed: [
            p.Number,
            1 / 1000
        ]
    });
    return WheelPanTool;
}(gesture_tool_1.GestureTool);    
},
/* models/tools/gestures/wheel_zoom_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var document, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var gesture_tool_1 = require(213    /* ./gesture_tool */);
var zoom_1 = require(42    /* core/util/zoom */);
var p = require(13    /* core/properties */);
if (typeof document === 'undefined' || document === null) {
    document = {};
}
exports.WheelZoomToolView = function (superClass) {
    extend(WheelZoomToolView, superClass);
    function WheelZoomToolView() {
        return WheelZoomToolView.__super__.constructor.apply(this, arguments);
    }
    WheelZoomToolView.prototype._pinch = function (e) {
        var delta;
        if (e.scale >= 1) {
            delta = (e.scale - 1) * 20;
        } else {
            delta = -20 / e.scale;
        }
        e.bokeh.delta = delta;
        return this._scroll(e);
    };
    WheelZoomToolView.prototype._scroll = function (e) {
        var dims, factor, frame, h_axis, hr, v_axis, vr, vx, vy, zoom_info;
        frame = this.plot_model.frame;
        hr = frame.h_range;
        vr = frame.v_range;
        vx = this.plot_view.canvas.sx_to_vx(e.bokeh.sx);
        vy = this.plot_view.canvas.sy_to_vy(e.bokeh.sy);
        dims = this.model.dimensions;
        h_axis = (dims === 'width' || dims === 'both') && (hr.min < vx && vx < hr.max);
        v_axis = (dims === 'height' || dims === 'both') && (vr.min < vy && vy < vr.max);
        factor = this.model.speed * e.bokeh.delta;
        zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, {
            x: vx,
            y: vy
        });
        this.plot_view.push_state('wheel_zoom', { range: zoom_info });
        this.plot_view.update_range(zoom_info, false, true);
        this.plot_view.interactive_timestamp = Date.now();
        return null;
    };
    return WheelZoomToolView;
}(gesture_tool_1.GestureToolView);
exports.WheelZoomTool = function (superClass) {
    extend(WheelZoomTool, superClass);
    function WheelZoomTool() {
        return WheelZoomTool.__super__.constructor.apply(this, arguments);
    }
    WheelZoomTool.prototype.default_view = exports.WheelZoomToolView;
    WheelZoomTool.prototype.type = 'WheelZoomTool';
    WheelZoomTool.prototype.tool_name = 'Wheel Zoom';
    WheelZoomTool.prototype.icon = 'bk-tool-icon-wheel-zoom';
    WheelZoomTool.prototype.event_type = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'pinch' : 'scroll';
    WheelZoomTool.prototype.default_order = 10;
    WheelZoomTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    WheelZoomTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    WheelZoomTool.internal({
        speed: [
            p.Number,
            1 / 600
        ]
    });
    return WheelZoomTool;
}(gesture_tool_1.GestureTool);    
},
/* models/tools/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var action_tool_1 = require(202    /* ./actions/action_tool */);
exports.ActionTool = action_tool_1.ActionTool;
var help_tool_1 = require(203    /* ./actions/help_tool */);
exports.HelpTool = help_tool_1.HelpTool;
var redo_tool_1 = require(204    /* ./actions/redo_tool */);
exports.RedoTool = redo_tool_1.RedoTool;
var reset_tool_1 = require(205    /* ./actions/reset_tool */);
exports.ResetTool = reset_tool_1.ResetTool;
var save_tool_1 = require(206    /* ./actions/save_tool */);
exports.SaveTool = save_tool_1.SaveTool;
var undo_tool_1 = require(207    /* ./actions/undo_tool */);
exports.UndoTool = undo_tool_1.UndoTool;
var zoom_in_tool_1 = require(208    /* ./actions/zoom_in_tool */);
exports.ZoomInTool = zoom_in_tool_1.ZoomInTool;
var zoom_out_tool_1 = require(209    /* ./actions/zoom_out_tool */);
exports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;
var button_tool_1 = require(210    /* ./button_tool */);
exports.ButtonTool = button_tool_1.ButtonTool;
var box_select_tool_1 = require(211    /* ./gestures/box_select_tool */);
exports.BoxSelectTool = box_select_tool_1.BoxSelectTool;
var box_zoom_tool_1 = require(212    /* ./gestures/box_zoom_tool */);
exports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;
var gesture_tool_1 = require(213    /* ./gestures/gesture_tool */);
exports.GestureTool = gesture_tool_1.GestureTool;
var lasso_select_tool_1 = require(214    /* ./gestures/lasso_select_tool */);
exports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;
var pan_tool_1 = require(215    /* ./gestures/pan_tool */);
exports.PanTool = pan_tool_1.PanTool;
var poly_select_tool_1 = require(216    /* ./gestures/poly_select_tool */);
exports.PolySelectTool = poly_select_tool_1.PolySelectTool;
var select_tool_1 = require(217    /* ./gestures/select_tool */);
exports.SelectTool = select_tool_1.SelectTool;
var tap_tool_1 = require(218    /* ./gestures/tap_tool */);
exports.TapTool = tap_tool_1.TapTool;
var wheel_pan_tool_1 = require(219    /* ./gestures/wheel_pan_tool */);
exports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;
var wheel_zoom_tool_1 = require(220    /* ./gestures/wheel_zoom_tool */);
exports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;
var crosshair_tool_1 = require(222    /* ./inspectors/crosshair_tool */);
exports.CrosshairTool = crosshair_tool_1.CrosshairTool;
var hover_tool_1 = require(223    /* ./inspectors/hover_tool */);
exports.HoverTool = hover_tool_1.HoverTool;
var inspect_tool_1 = require(224    /* ./inspectors/inspect_tool */);
exports.InspectTool = inspect_tool_1.InspectTool;
var tool_1 = require(226    /* ./tool */);
exports.Tool = tool_1.Tool;
var tool_proxy_1 = require(227    /* ./tool_proxy */);
exports.ToolProxy = tool_proxy_1.ToolProxy;
var toolbar_1 = require(228    /* ./toolbar */);
exports.Toolbar = toolbar_1.Toolbar;
var toolbar_base_1 = require(229    /* ./toolbar_base */);
exports.ToolbarBase = toolbar_base_1.ToolbarBase;
var toolbar_box_1 = require(230    /* ./toolbar_box */);
exports.ToolbarBoxToolbar = toolbar_box_1.ToolbarBoxToolbar;
var toolbar_box_2 = require(230    /* ./toolbar_box */);
exports.ToolbarBox = toolbar_box_2.ToolbarBox;    
},
/* models/tools/inspectors/crosshair_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var inspect_tool_1 = require(224    /* ./inspect_tool */);
var span_1 = require(61    /* ../../annotations/span */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
exports.CrosshairToolView = function (superClass) {
    extend(CrosshairToolView, superClass);
    function CrosshairToolView() {
        return CrosshairToolView.__super__.constructor.apply(this, arguments);
    }
    CrosshairToolView.prototype._move = function (e) {
        var canvas, frame, vx, vy;
        if (!this.model.active) {
            return;
        }
        frame = this.plot_model.frame;
        canvas = this.plot_model.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        if (!frame.contains(vx, vy)) {
            vx = vy = null;
        }
        return this._update_spans(vx, vy);
    };
    CrosshairToolView.prototype._move_exit = function (e) {
        return this._update_spans(null, null);
    };
    CrosshairToolView.prototype._update_spans = function (x, y) {
        var dims;
        dims = this.model.dimensions;
        if (dims === 'width' || dims === 'both') {
            this.model.spans.width.computed_location = y;
        }
        if (dims === 'height' || dims === 'both') {
            return this.model.spans.height.computed_location = x;
        }
    };
    return CrosshairToolView;
}(inspect_tool_1.InspectToolView);
exports.CrosshairTool = function (superClass) {
    extend(CrosshairTool, superClass);
    function CrosshairTool() {
        return CrosshairTool.__super__.constructor.apply(this, arguments);
    }
    CrosshairTool.prototype.default_view = exports.CrosshairToolView;
    CrosshairTool.prototype.type = 'CrosshairTool';
    CrosshairTool.prototype.tool_name = 'Crosshair';
    CrosshairTool.prototype.icon = 'bk-tool-icon-crosshair';
    CrosshairTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        line_color: [
            p.Color,
            'black'
        ],
        line_width: [
            p.Number,
            1
        ],
        line_alpha: [
            p.Number,
            1
        ]
    });
    CrosshairTool.internal({
        location_units: [
            p.SpatialUnits,
            'screen'
        ],
        render_mode: [
            p.RenderMode,
            'css'
        ],
        spans: [p.Any]
    });
    CrosshairTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip('Crosshair', this.dimensions);
        },
        synthetic_renderers: function () {
            return object_1.values(this.spans);
        }
    });
    CrosshairTool.prototype.initialize = function (attrs, options) {
        CrosshairTool.__super__.initialize.call(this, attrs, options);
        return this.spans = {
            width: new span_1.Span({
                for_hover: true,
                dimension: 'width',
                render_mode: this.render_mode,
                location_units: this.location_units,
                line_color: this.line_color,
                line_width: this.line_width,
                line_alpha: this.line_alpha
            }),
            height: new span_1.Span({
                for_hover: true,
                dimension: 'height',
                render_mode: this.render_mode,
                location_units: this.location_units,
                line_color: this.line_color,
                line_width: this.line_width,
                line_alpha: this.line_alpha
            })
        };
    };
    return CrosshairTool;
}(inspect_tool_1.InspectTool);    
},
/* models/tools/inspectors/hover_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var _color_to_hex, extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var inspect_tool_1 = require(224    /* ./inspect_tool */);
var tooltip_1 = require(64    /* ../../annotations/tooltip */);
var glyph_renderer_1 = require(156    /* ../../renderers/glyph_renderer */);
var graph_renderer_1 = require(157    /* ../../renderers/graph_renderer */);
var hittest = require(8    /* core/hittest */);
var templating_1 = require(37    /* core/util/templating */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
var types_1 = require(40    /* core/util/types */);
var build_views_1 = require(3    /* core/build_views */);
_color_to_hex = function (color) {
    var blue, digits, green, red, rgb;
    if (color.substr(0, 1) === '#') {
        return color;
    }
    digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);
    red = parseInt(digits[2]);
    green = parseInt(digits[3]);
    blue = parseInt(digits[4]);
    rgb = blue | green << 8 | red << 16;
    return digits[1] + '#' + rgb.toString(16);
};
exports.HoverToolView = function (superClass) {
    extend(HoverToolView, superClass);
    function HoverToolView() {
        return HoverToolView.__super__.constructor.apply(this, arguments);
    }
    HoverToolView.prototype.initialize = function (options) {
        HoverToolView.__super__.initialize.call(this, options);
        return this.ttviews = {};
    };
    HoverToolView.prototype.remove = function () {
        build_views_1.remove_views(this.ttviews);
        return HoverToolView.__super__.remove.call(this);
    };
    HoverToolView.prototype.connect_signals = function () {
        var k, len, r, ref;
        HoverToolView.__super__.connect_signals.call(this);
        ref = this.computed_renderers;
        for (k = 0, len = ref.length; k < len; k++) {
            r = ref[k];
            if (r instanceof glyph_renderer_1.GlyphRenderer) {
                this.connect(r.data_source.inspect, this._update);
            } else if (r instanceof graph_renderer_1.GraphRenderer) {
                this.connect(r.node_renderer.data_source.inspect, this._update);
                this.connect(r.edge_renderer.data_source.inspect, this._update);
            }
        }
        this.connect(this.model.properties.renderers.change, function () {
            return this._computed_renderers = this._ttmodels = null;
        });
        this.connect(this.model.properties.names.change, function () {
            return this._computed_renderers = this._ttmodels = null;
        });
        return this.connect(this.model.properties.tooltips.change, function () {
            return this._ttmodels = null;
        });
    };
    HoverToolView.prototype._compute_renderers = function () {
        var all_renderers, names, r, renderers;
        renderers = this.model.renderers;
        names = this.model.names;
        if (renderers.length === 0) {
            all_renderers = this.plot_model.plot.renderers;
            renderers = function () {
                var k, len, results;
                results = [];
                for (k = 0, len = all_renderers.length; k < len; k++) {
                    r = all_renderers[k];
                    if (r instanceof glyph_renderer_1.GlyphRenderer || r instanceof graph_renderer_1.GraphRenderer) {
                        results.push(r);
                    }
                }
                return results;
            }();
        }
        if (names.length > 0) {
            renderers = function () {
                var k, len, results;
                results = [];
                for (k = 0, len = renderers.length; k < len; k++) {
                    r = renderers[k];
                    if (names.indexOf(r.name) >= 0) {
                        results.push(r);
                    }
                }
                return results;
            }();
        }
        return renderers;
    };
    HoverToolView.prototype._compute_ttmodels = function () {
        var k, l, len, len1, new_views, r, ref, tooltip, tooltips, ttmodels, view;
        ttmodels = {};
        tooltips = this.model.tooltips;
        if (tooltips != null) {
            ref = this.computed_renderers;
            for (k = 0, len = ref.length; k < len; k++) {
                r = ref[k];
                if (r instanceof glyph_renderer_1.GlyphRenderer) {
                    tooltip = new tooltip_1.Tooltip({
                        custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),
                        attachment: this.model.attachment,
                        show_arrow: this.model.show_arrow
                    });
                    ttmodels[r.id] = tooltip;
                } else if (r instanceof graph_renderer_1.GraphRenderer) {
                    tooltip = new tooltip_1.Tooltip({
                        custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),
                        attachment: this.model.attachment,
                        show_arrow: this.model.show_arrow
                    });
                    ttmodels[r.node_renderer.id] = tooltip;
                    ttmodels[r.edge_renderer.id] = tooltip;
                }
            }
        }
        new_views = build_views_1.build_views(this.ttviews, object_1.values(ttmodels), {
            parent: this,
            plot_view: this.plot_view
        });
        for (l = 0, len1 = new_views.length; l < len1; l++) {
            view = new_views[l];
            view.connect_signals();
        }
        return ttmodels;
    };
    HoverToolView.getters({
        computed_renderers: function () {
            if (this._computed_renderers == null) {
                this._computed_renderers = this._compute_renderers();
            }
            return this._computed_renderers;
        },
        ttmodels: function () {
            if (this._ttmodels == null) {
                this._ttmodels = this._compute_ttmodels();
            }
            return this._ttmodels;
        }
    });
    HoverToolView.prototype._clear = function () {
        var ref, results, rid, tt;
        this._inspect(1e+400, 1e+400);
        ref = this.ttmodels;
        results = [];
        for (rid in ref) {
            tt = ref[rid];
            results.push(tt.clear());
        }
        return results;
    };
    HoverToolView.prototype._move = function (e) {
        var canvas, vx, vy;
        if (!this.model.active) {
            return;
        }
        canvas = this.plot_view.canvas;
        vx = canvas.sx_to_vx(e.bokeh.sx);
        vy = canvas.sy_to_vy(e.bokeh.sy);
        if (!this.plot_view.frame.contains(vx, vy)) {
            return this._clear();
        } else {
            return this._inspect(vx, vy);
        }
    };
    HoverToolView.prototype._move_exit = function () {
        return this._clear();
    };
    HoverToolView.prototype._inspect = function (vx, vy, e) {
        var geometry, k, len, r, ref, sm;
        geometry = {
            type: 'point',
            vx: vx,
            vy: vy
        };
        if (this.model.mode === 'mouse') {
            geometry['type'] = 'point';
        } else {
            geometry['type'] = 'span';
            if (this.model.mode === 'vline') {
                geometry.direction = 'h';
            } else {
                geometry.direction = 'v';
            }
        }
        ref = this.computed_renderers;
        for (k = 0, len = ref.length; k < len; k++) {
            r = ref[k];
            sm = r.get_selection_manager();
            sm.inspect(this.plot_view.renderer_views[r.id], geometry);
        }
        if (this.model.callback != null) {
            this._emit_callback(geometry);
        }
    };
    HoverToolView.prototype._update = function (arg) {
        var canvas, d1x, d1y, d2x, d2y, data_x, data_y, dist1, dist2, ds, frame, geometry, i, ii, indices, j, jj, k, l, len, len1, pt, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, renderer_view, rx, ry, sdatax, sdatay, sx, sy, tooltip, vars, vx, vy, x, xscale, y, yscale;
        renderer_view = arg[0], (ref = arg[1], geometry = ref.geometry);
        if (!this.model.active) {
            return;
        }
        tooltip = (ref1 = this.ttmodels[renderer_view.model.id]) != null ? ref1 : null;
        if (tooltip == null) {
            return;
        }
        tooltip.clear();
        indices = renderer_view.model.get_selection_manager().inspectors[renderer_view.model.id].indices;
        ds = renderer_view.model.get_selection_manager().source;
        if (indices.is_empty()) {
            return;
        }
        vx = geometry.vx;
        vy = geometry.vy;
        canvas = this.plot_model.canvas;
        frame = this.plot_model.frame;
        sx = canvas.vx_to_sx(vx);
        sy = canvas.vy_to_sy(vy);
        xscale = frame.xscales[renderer_view.model.x_range_name];
        yscale = frame.yscales[renderer_view.model.y_range_name];
        x = xscale.invert(vx);
        y = yscale.invert(vy);
        ref2 = indices['0d'].indices;
        for (k = 0, len = ref2.length; k < len; k++) {
            i = ref2[k];
            data_x = renderer_view.glyph._x[i + 1];
            data_y = renderer_view.glyph._y[i + 1];
            ii = i;
            switch (this.model.line_policy) {
            case 'interp':
                ref3 = renderer_view.glyph.get_interpolation_hit(i, geometry), data_x = ref3[0], data_y = ref3[1];
                rx = xscale.compute(data_x);
                ry = yscale.compute(data_y);
                break;
            case 'prev':
                rx = canvas.sx_to_vx(renderer_view.glyph.sx[i]);
                ry = canvas.sy_to_vy(renderer_view.glyph.sy[i]);
                break;
            case 'next':
                rx = canvas.sx_to_vx(renderer_view.glyph.sx[i + 1]);
                ry = canvas.sy_to_vy(renderer_view.glyph.sy[i + 1]);
                ii = i + 1;
                break;
            case 'nearest':
                d1x = renderer_view.glyph.sx[i];
                d1y = renderer_view.glyph.sy[i];
                dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);
                d2x = renderer_view.glyph.sx[i + 1];
                d2y = renderer_view.glyph.sy[i + 1];
                dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);
                if (dist1 < dist2) {
                    ref4 = [
                        d1x,
                        d1y
                    ], sdatax = ref4[0], sdatay = ref4[1];
                } else {
                    ref5 = [
                        d2x,
                        d2y
                    ], sdatax = ref5[0], sdatay = ref5[1];
                    ii = i + 1;
                }
                data_x = renderer_view.glyph._x[i];
                data_y = renderer_view.glyph._y[i];
                rx = canvas.sx_to_vx(sdatax);
                ry = canvas.sy_to_vy(sdatay);
                break;
            default:
                ref6 = [
                    vx,
                    vy
                ], rx = ref6[0], ry = ref6[1];
            }
            vars = {
                index: ii,
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                sx: sx,
                sy: sy,
                data_x: data_x,
                data_y: data_y,
                rx: rx,
                ry: ry
            };
            tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));
        }
        ref7 = indices['1d'].indices;
        for (l = 0, len1 = ref7.length; l < len1; l++) {
            i = ref7[l];
            if (!object_1.isEmpty(indices['2d'].indices)) {
                ref8 = indices['2d'].indices;
                for (i in ref8) {
                    j = ref8[i][0];
                    data_x = renderer_view.glyph._xs[i][j];
                    data_y = renderer_view.glyph._ys[i][j];
                    jj = j;
                    switch (this.model.line_policy) {
                    case 'interp':
                        ref9 = renderer_view.glyph.get_interpolation_hit(i, j, geometry), data_x = ref9[0], data_y = ref9[1];
                        rx = xscale.compute(data_x);
                        ry = yscale.compute(data_y);
                        break;
                    case 'prev':
                        rx = canvas.sx_to_vx(renderer_view.glyph.sxs[i][j]);
                        ry = canvas.sy_to_vy(renderer_view.glyph.sys[i][j]);
                        break;
                    case 'next':
                        rx = canvas.sx_to_vx(renderer_view.glyph.sxs[i][j + 1]);
                        ry = canvas.sy_to_vy(renderer_view.glyph.sys[i][j + 1]);
                        jj = j + 1;
                        break;
                    case 'nearest':
                        d1x = renderer_view.glyph.sxs[i][j];
                        d1y = renderer_view.glyph.sys[i][j];
                        dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);
                        d2x = renderer_view.glyph.sxs[i][j + 1];
                        d2y = renderer_view.glyph.sys[i][j + 1];
                        dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);
                        if (dist1 < dist2) {
                            ref10 = [
                                d1x,
                                d1y
                            ], sdatax = ref10[0], sdatay = ref10[1];
                        } else {
                            ref11 = [
                                d2x,
                                d2y
                            ], sdatax = ref11[0], sdatay = ref11[1];
                            jj = j + 1;
                        }
                        data_x = renderer_view.glyph._xs[i][j];
                        data_y = renderer_view.glyph._ys[i][j];
                        rx = canvas.sx_to_vx(sdatax);
                        ry = canvas.sy_to_vy(sdatay);
                    }
                    vars = {
                        index: i,
                        segment_index: jj,
                        x: x,
                        y: y,
                        vx: vx,
                        vy: vy,
                        sx: sx,
                        sy: sy,
                        data_x: data_x,
                        data_y: data_y
                    };
                    tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));
                }
            } else {
                data_x = (ref12 = renderer_view.glyph._x) != null ? ref12[i] : void 0;
                data_y = (ref13 = renderer_view.glyph._y) != null ? ref13[i] : void 0;
                if (this.model.point_policy === 'snap_to_data') {
                    pt = renderer_view.glyph.get_anchor_point(this.model.anchor, i, [
                        sx,
                        sy
                    ]);
                    if (pt == null) {
                        pt = renderer_view.glyph.get_anchor_point('center', i, [
                            sx,
                            sy
                        ]);
                    }
                    rx = canvas.sx_to_vx(pt.x);
                    ry = canvas.sy_to_vy(pt.y);
                } else {
                    ref14 = [
                        vx,
                        vy
                    ], rx = ref14[0], ry = ref14[1];
                }
                vars = {
                    index: i,
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    sx: sx,
                    sy: sy,
                    data_x: data_x,
                    data_y: data_y
                };
                tooltip.add(rx, ry, this._render_tooltips(ds, i, vars));
            }
        }
        return null;
    };
    HoverToolView.prototype._emit_callback = function (geometry) {
        var callback, canvas, data, frame, indices, obj, r, ref, xscale, yscale;
        r = this.computed_renderers[0];
        indices = this.plot_view.renderer_views[r.id].hit_test(geometry);
        canvas = this.plot_model.canvas;
        frame = this.plot_model.frame;
        geometry['sx'] = canvas.vx_to_sx(geometry.vx);
        geometry['sy'] = canvas.vy_to_sy(geometry.vy);
        xscale = frame.xscales[r.x_range_name];
        yscale = frame.yscales[r.y_range_name];
        geometry['x'] = xscale.invert(geometry.vx);
        geometry['y'] = yscale.invert(geometry.vy);
        callback = this.model.callback;
        ref = [
            callback,
            {
                index: indices,
                geometry: geometry,
                renderer: r
            }
        ], obj = ref[0], data = ref[1];
        if (types_1.isFunction(callback)) {
            callback(obj, data);
        } else {
            callback.execute(obj, data);
        }
    };
    HoverToolView.prototype._render_tooltips = function (ds, i, vars) {
        var cell, colname, color, column, el, hex, k, label, len, match, opts, ref, ref1, row, rows, swatch, tooltips, value;
        tooltips = this.model.tooltips;
        if (types_1.isString(tooltips)) {
            el = dom_1.div();
            el.innerHTML = templating_1.replace_placeholders(tooltips, ds, i, this.model.formatters, vars);
            return el;
        } else if (types_1.isFunction(tooltips)) {
            return tooltips(ds, vars);
        } else {
            rows = dom_1.div({
                style: {
                    display: 'table',
                    borderSpacing: '2px'
                }
            });
            for (k = 0, len = tooltips.length; k < len; k++) {
                ref = tooltips[k], label = ref[0], value = ref[1];
                row = dom_1.div({ style: { display: 'table-row' } });
                rows.appendChild(row);
                cell = dom_1.div({
                    style: { display: 'table-cell' },
                    'class': 'bk-tooltip-row-label'
                }, label + ': ');
                row.appendChild(cell);
                cell = dom_1.div({
                    style: { display: 'table-cell' },
                    'class': 'bk-tooltip-row-value'
                });
                row.appendChild(cell);
                if (value.indexOf('$color') >= 0) {
                    ref1 = value.match(/\$color(\[.*\])?:(\w*)/), match = ref1[0], opts = ref1[1], colname = ref1[2];
                    column = ds.get_column(colname);
                    if (column == null) {
                        el = dom_1.span({}, colname + ' unknown');
                        cell.appendChild(el);
                        continue;
                    }
                    hex = (opts != null ? opts.indexOf('hex') : void 0) >= 0;
                    swatch = (opts != null ? opts.indexOf('swatch') : void 0) >= 0;
                    color = column[i];
                    if (color == null) {
                        el = dom_1.span({}, '(null)');
                        cell.appendChild(el);
                        continue;
                    }
                    if (hex) {
                        color = _color_to_hex(color);
                    }
                    el = dom_1.span({}, color);
                    cell.appendChild(el);
                    if (swatch) {
                        el = dom_1.span({
                            'class': 'bk-tooltip-color-block',
                            style: { backgroundColor: color }
                        }, ' ');
                        cell.appendChild(el);
                    }
                } else {
                    value = value.replace('$~', '$data_');
                    el = dom_1.span();
                    el.innerHTML = templating_1.replace_placeholders(value, ds, i, this.model.formatters, vars);
                    cell.appendChild(el);
                }
            }
            return rows;
        }
    };
    return HoverToolView;
}(inspect_tool_1.InspectToolView);
exports.HoverTool = function (superClass) {
    extend(HoverTool, superClass);
    function HoverTool() {
        return HoverTool.__super__.constructor.apply(this, arguments);
    }
    HoverTool.prototype.default_view = exports.HoverToolView;
    HoverTool.prototype.type = 'HoverTool';
    HoverTool.prototype.tool_name = 'Hover';
    HoverTool.prototype.icon = 'bk-tool-icon-hover';
    HoverTool.define({
        tooltips: [
            p.Any,
            [
                [
                    'index',
                    '$index'
                ],
                [
                    'data (x, y)',
                    '($x, $y)'
                ],
                [
                    'canvas (x, y)',
                    '($sx, $sy)'
                ]
            ]
        ],
        formatters: [
            p.Any,
            {}
        ],
        renderers: [
            p.Array,
            []
        ],
        names: [
            p.Array,
            []
        ],
        mode: [
            p.String,
            'mouse'
        ],
        point_policy: [
            p.String,
            'snap_to_data'
        ],
        line_policy: [
            p.String,
            'nearest'
        ],
        show_arrow: [
            p.Boolean,
            true
        ],
        anchor: [
            p.String,
            'center'
        ],
        attachment: [
            p.String,
            'horizontal'
        ],
        callback: [p.Any]
    });
    return HoverTool;
}(inspect_tool_1.InspectTool);    
},
/* models/tools/inspectors/inspect_tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var button_tool_1 = require(210    /* ../button_tool */);
exports.InspectToolView = function (superClass) {
    extend(InspectToolView, superClass);
    function InspectToolView() {
        return InspectToolView.__super__.constructor.apply(this, arguments);
    }
    return InspectToolView;
}(button_tool_1.ButtonToolView);
exports.InspectTool = function (superClass) {
    extend(InspectTool, superClass);
    function InspectTool() {
        return InspectTool.__super__.constructor.apply(this, arguments);
    }
    InspectTool.prototype.event_type = 'move';
    InspectTool.define({
        toggleable: [
            p.Bool,
            true
        ]
    });
    InspectTool.override({ active: true });
    return InspectTool;
}(button_tool_1.ButtonTool);    
},
/* models/tools/on_off_button */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var button_tool_1 = require(210    /* ./button_tool */);
exports.OnOffButtonView = function (superClass) {
    extend(OnOffButtonView, superClass);
    function OnOffButtonView() {
        return OnOffButtonView.__super__.constructor.apply(this, arguments);
    }
    OnOffButtonView.prototype.render = function () {
        OnOffButtonView.__super__.render.call(this);
        if (this.model.active) {
            return this.el.classList.add('bk-active');
        } else {
            return this.el.classList.remove('bk-active');
        }
    };
    OnOffButtonView.prototype._clicked = function () {
        var active;
        active = this.model.active;
        return this.model.active = !active;
    };
    return OnOffButtonView;
}(button_tool_1.ButtonToolButtonView);    
},
/* models/tools/tool */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var view_1 = require(43    /* core/view */);
var array_1 = require(20    /* core/util/array */);
var model_1 = require(48    /* ../../model */);
exports.ToolView = function (superClass) {
    extend(ToolView, superClass);
    function ToolView() {
        return ToolView.__super__.constructor.apply(this, arguments);
    }
    ToolView.prototype.initialize = function (options) {
        ToolView.__super__.initialize.call(this, options);
        return this.plot_view = options.plot_view;
    };
    ToolView.getters({
        plot_model: function () {
            return this.plot_view.model;
        }
    });
    ToolView.prototype.connect_signals = function () {
        ToolView.__super__.connect_signals.call(this);
        return this.connect(this.model.properties.active.change, function (_this) {
            return function () {
                if (_this.model.active) {
                    return _this.activate();
                } else {
                    return _this.deactivate();
                }
            };
        }(this));
    };
    ToolView.prototype.activate = function () {
    };
    ToolView.prototype.deactivate = function () {
    };
    return ToolView;
}(view_1.View);
exports.Tool = function (superClass) {
    extend(Tool, superClass);
    function Tool() {
        return Tool.__super__.constructor.apply(this, arguments);
    }
    Tool.getters({
        synthetic_renderers: function () {
            return [];
        }
    });
    Tool.internal({
        active: [
            p.Boolean,
            false
        ]
    });
    Tool.prototype._get_dim_tooltip = function (name, dims) {
        switch (dims) {
        case 'width':
            return name + ' (x-axis)';
        case 'height':
            return name + ' (y-axis)';
        case 'both':
            return name;
        }
    };
    Tool.prototype._get_dim_limits = function (arg, arg1, frame, dims) {
        var hr, vr, vx0, vx1, vxlim, vy0, vy1, vylim;
        vx0 = arg[0], vy0 = arg[1];
        vx1 = arg1[0], vy1 = arg1[1];
        hr = frame.h_range;
        if (dims === 'width' || dims === 'both') {
            vxlim = [
                array_1.min([
                    vx0,
                    vx1
                ]),
                array_1.max([
                    vx0,
                    vx1
                ])
            ];
            vxlim = [
                array_1.max([
                    vxlim[0],
                    hr.min
                ]),
                array_1.min([
                    vxlim[1],
                    hr.max
                ])
            ];
        } else {
            vxlim = [
                hr.min,
                hr.max
            ];
        }
        vr = frame.v_range;
        if (dims === 'height' || dims === 'both') {
            vylim = [
                array_1.min([
                    vy0,
                    vy1
                ]),
                array_1.max([
                    vy0,
                    vy1
                ])
            ];
            vylim = [
                array_1.max([
                    vylim[0],
                    vr.min
                ]),
                array_1.min([
                    vylim[1],
                    vr.max
                ])
            ];
        } else {
            vylim = [
                vr.min,
                vr.max
            ];
        }
        return [
            vxlim,
            vylim
        ];
    };
    return Tool;
}(model_1.Model);    
},
/* models/tools/tool_proxy */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var p = require(13    /* core/properties */);
var signaling_1 = require(18    /* core/signaling */);
var model_1 = require(48    /* ../../model */);
exports.ToolProxy = function (superClass) {
    extend(ToolProxy, superClass);
    function ToolProxy() {
        return ToolProxy.__super__.constructor.apply(this, arguments);
    }
    ToolProxy.prototype.initialize = function (options) {
        ToolProxy.__super__.initialize.call(this, options);
        this['do'] = new signaling_1.Signal(this, 'do');
        this.connect(this['do'], function () {
            return this.doit();
        });
        return this.connect(this.properties.active.change, function () {
            return this.set_active();
        });
    };
    ToolProxy.prototype.doit = function () {
        var i, len, ref, tool;
        ref = this.tools;
        for (i = 0, len = ref.length; i < len; i++) {
            tool = ref[i];
            tool['do'].emit();
        }
        return null;
    };
    ToolProxy.prototype.set_active = function () {
        var i, len, ref, tool;
        ref = this.tools;
        for (i = 0, len = ref.length; i < len; i++) {
            tool = ref[i];
            tool.active = this.active;
        }
        return null;
    };
    ToolProxy.define({
        tools: [
            p.Array,
            []
        ],
        active: [
            p.Bool,
            false
        ],
        tooltip: [p.String],
        tool_name: [p.String],
        disabled: [
            p.Bool,
            false
        ],
        event_type: [p.String],
        icon: [p.String]
    });
    ToolProxy.prototype._clicked = function () {
        var active;
        active = this.model.active;
        return this.model.active = !active;
    };
    return ToolProxy;
}(model_1.Model);    
},
/* models/tools/toolbar */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var action_tool_1 = require(202    /* ./actions/action_tool */);
var help_tool_1 = require(203    /* ./actions/help_tool */);
var gesture_tool_1 = require(213    /* ./gestures/gesture_tool */);
var inspect_tool_1 = require(224    /* ./inspectors/inspect_tool */);
var toolbar_base_1 = require(229    /* ./toolbar_base */);
exports.Toolbar = function (superClass) {
    extend(Toolbar, superClass);
    function Toolbar() {
        return Toolbar.__super__.constructor.apply(this, arguments);
    }
    Toolbar.prototype.type = 'Toolbar';
    Toolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;
    Toolbar.prototype.initialize = function (attrs, options) {
        Toolbar.__super__.initialize.call(this, attrs, options);
        this.connect(this.properties.tools.change, function () {
            return this._init_tools();
        });
        return this._init_tools();
    };
    Toolbar.prototype._init_tools = function () {
        var et, i, len, ref, results, tool, tools;
        ref = this.tools;
        for (i = 0, len = ref.length; i < len; i++) {
            tool = ref[i];
            if (tool instanceof inspect_tool_1.InspectTool) {
                if (!array_1.any(this.inspectors, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    this.inspectors = this.inspectors.concat([tool]);
                }
            } else if (tool instanceof help_tool_1.HelpTool) {
                if (!array_1.any(this.help, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    this.help = this.help.concat([tool]);
                }
            } else if (tool instanceof action_tool_1.ActionTool) {
                if (!array_1.any(this.actions, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    this.actions = this.actions.concat([tool]);
                }
            } else if (tool instanceof gesture_tool_1.GestureTool) {
                et = tool.event_type;
                if (!(et in this.gestures)) {
                    logger.warn('Toolbar: unknown event type \'' + et + '\' for tool: ' + tool.type + ' (' + tool.id + ')');
                    continue;
                }
                if (!array_1.any(this.gestures[et].tools, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    this.gestures[et].tools = this.gestures[et].tools.concat([tool]);
                }
                this.connect(tool.properties.active.change, this._active_change.bind(null, tool));
            }
        }
        if (this.active_inspect === 'auto') {
        } else if (this.active_inspect instanceof inspect_tool_1.InspectTool) {
            this.inspectors.map(function (_this) {
                return function (inspector) {
                    if (inspector !== _this.active_inspect) {
                        return inspector.active = false;
                    }
                };
            }(this));
        } else if (this.active_inspect instanceof Array) {
            this.inspectors.map(function (_this) {
                return function (inspector) {
                    if (indexOf.call(_this.active_inspect, inspector) < 0) {
                        return inspector.active = false;
                    }
                };
            }(this));
        } else if (this.active_inspect === null) {
            this.inspectors.map(function (inspector) {
                return inspector.active = false;
            });
        }
        results = [];
        for (et in this.gestures) {
            tools = this.gestures[et].tools;
            if (tools.length === 0) {
                continue;
            }
            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {
                return tool.default_order;
            });
            if (et === 'tap') {
                if (this.active_tap === null) {
                    continue;
                }
                if (this.active_tap === 'auto') {
                    this.gestures[et].tools[0].active = true;
                } else {
                    this.active_tap.active = true;
                }
            }
            if (et === 'pan') {
                if (this.active_drag === null) {
                    continue;
                }
                if (this.active_drag === 'auto') {
                    this.gestures[et].tools[0].active = true;
                } else {
                    this.active_drag.active = true;
                }
            }
            if (et === 'pinch' || et === 'scroll') {
                if (this.active_scroll === null || this.active_scroll === 'auto') {
                    continue;
                }
                results.push(this.active_scroll.active = true);
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    Toolbar.define({
        active_drag: [
            p.Any,
            'auto'
        ],
        active_inspect: [
            p.Any,
            'auto'
        ],
        active_scroll: [
            p.Any,
            'auto'
        ],
        active_tap: [
            p.Any,
            'auto'
        ]
    });
    return Toolbar;
}(toolbar_base_1.ToolbarBase);    
},
/* models/tools/toolbar_base */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, bind = function (fn, me) {
        return function () {
            return fn.apply(me, arguments);
        };
    };
var logging_1 = require(12    /* core/logging */);
var solver_1 = require(11    /* core/layout/solver */);
var dom_1 = require(4    /* core/dom */);
var p = require(13    /* core/properties */);
var layout_dom_1 = require(134    /* ../layouts/layout_dom */);
var action_tool_1 = require(202    /* ./actions/action_tool */);
var on_off_button_1 = require(225    /* ./on_off_button */);
exports.ToolbarBaseView = function (superClass) {
    extend(ToolbarBaseView, superClass);
    function ToolbarBaseView() {
        return ToolbarBaseView.__super__.constructor.apply(this, arguments);
    }
    ToolbarBaseView.prototype.className = 'bk-toolbar-wrapper';
    ToolbarBaseView.prototype.template = function () {
        var cls, logo, sticky;
        if (this.model.logo != null) {
            cls = this.model.logo === 'grey' ? 'bk-grey' : null;
            logo = dom_1.a({
                href: 'https://bokeh.pydata.org/',
                target: '_blank',
                'class': [
                    'bk-logo',
                    'bk-logo-small',
                    cls
                ]
            });
        } else {
            logo = null;
        }
        sticky = this.model.toolbar_sticky ? 'sticky' : 'not-sticky';
        return dom_1.div({
            'class': [
                'bk-toolbar-' + this.model.toolbar_location,
                'bk-toolbar-' + sticky
            ]
        }, logo, dom_1.div({ 'class': 'bk-button-bar' }, dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'pan'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'scroll'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'pinch'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'tap'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'press'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'rotate'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'actions'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'inspectors'
        }), dom_1.div({
            'class': 'bk-button-bar-list',
            type: 'help'
        })));
    };
    ToolbarBaseView.prototype.render = function () {
        var buttons, et, gestures, i, j, k, l, len, len1, len2, len3, obj, ref, ref1, ref2, ref3;
        dom_1.empty(this.el);
        if (this.model.sizing_mode !== 'fixed') {
            this.el.style.left = this.model._dom_left.value + 'px';
            this.el.style.top = this.model._dom_top.value + 'px';
            this.el.style.width = this.model._width.value + 'px';
            this.el.style.height = this.model._height.value + 'px';
        }
        this.el.appendChild(this.template());
        buttons = this.el.querySelector('.bk-button-bar-list[type=\'inspectors\']');
        ref = this.model.inspectors;
        for (i = 0, len = ref.length; i < len; i++) {
            obj = ref[i];
            if (obj.toggleable) {
                buttons.appendChild(new on_off_button_1.OnOffButtonView({
                    model: obj,
                    parent: this
                }).el);
            }
        }
        buttons = this.el.querySelector('.bk-button-bar-list[type=\'help\']');
        ref1 = this.model.help;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
            obj = ref1[j];
            buttons.appendChild(new action_tool_1.ActionToolButtonView({
                model: obj,
                parent: this
            }).el);
        }
        buttons = this.el.querySelector('.bk-button-bar-list[type=\'actions\']');
        ref2 = this.model.actions;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
            obj = ref2[k];
            buttons.appendChild(new action_tool_1.ActionToolButtonView({
                model: obj,
                parent: this
            }).el);
        }
        gestures = this.model.gestures;
        for (et in gestures) {
            buttons = this.el.querySelector('.bk-button-bar-list[type=\'' + et + '\']');
            ref3 = gestures[et].tools;
            for (l = 0, len3 = ref3.length; l < len3; l++) {
                obj = ref3[l];
                buttons.appendChild(new on_off_button_1.OnOffButtonView({
                    model: obj,
                    parent: this
                }).el);
            }
        }
        return this;
    };
    return ToolbarBaseView;
}(layout_dom_1.LayoutDOMView);
exports.ToolbarBase = function (superClass) {
    extend(ToolbarBase, superClass);
    function ToolbarBase() {
        this._active_change = bind(this._active_change, this);
        return ToolbarBase.__super__.constructor.apply(this, arguments);
    }
    ToolbarBase.prototype.type = 'ToolbarBase';
    ToolbarBase.prototype.default_view = exports.ToolbarBaseView;
    ToolbarBase.prototype.initialize = function (attrs, options) {
        ToolbarBase.__super__.initialize.call(this, attrs, options);
        this._set_sizeable();
        return this.connect(this.properties.toolbar_location.change, function (_this) {
            return function () {
                return _this._set_sizeable();
            };
        }(this));
    };
    ToolbarBase.prototype._set_sizeable = function () {
        var horizontal, ref;
        horizontal = (ref = this.toolbar_location) === 'left' || ref === 'right';
        return this._sizeable = !horizontal ? this._height : this._width;
    };
    ToolbarBase.prototype._active_change = function (tool) {
        var currently_active_tool, event_type;
        event_type = tool.event_type;
        if (tool.active) {
            currently_active_tool = this.gestures[event_type].active;
            if (currently_active_tool != null) {
                logging_1.logger.debug('Toolbar: deactivating tool: ' + currently_active_tool.type + ' (' + currently_active_tool.id + ') for event type \'' + event_type + '\'');
                currently_active_tool.active = false;
            }
            this.gestures[event_type].active = tool;
            logging_1.logger.debug('Toolbar: activating tool: ' + tool.type + ' (' + tool.id + ') for event type \'' + event_type + '\'');
        } else {
            this.gestures[event_type].active = null;
        }
        return null;
    };
    ToolbarBase.prototype.get_constraints = function () {
        return ToolbarBase.__super__.get_constraints.call(this).concat(solver_1.EQ(this._sizeable, -30));
    };
    ToolbarBase.define({
        tools: [
            p.Array,
            []
        ],
        logo: [
            p.String,
            'normal'
        ]
    });
    ToolbarBase.internal({
        gestures: [
            p.Any,
            function () {
                return {
                    pan: {
                        tools: [],
                        active: null
                    },
                    tap: {
                        tools: [],
                        active: null
                    },
                    doubletap: {
                        tools: [],
                        active: null
                    },
                    scroll: {
                        tools: [],
                        active: null
                    },
                    pinch: {
                        tools: [],
                        active: null
                    },
                    press: {
                        tools: [],
                        active: null
                    },
                    rotate: {
                        tools: [],
                        active: null
                    }
                };
            }
        ],
        actions: [
            p.Array,
            []
        ],
        inspectors: [
            p.Array,
            []
        ],
        help: [
            p.Array,
            []
        ],
        toolbar_location: [
            p.Location,
            'right'
        ],
        toolbar_sticky: [p.Bool]
    });
    ToolbarBase.override({ sizing_mode: null });
    return ToolbarBase;
}(layout_dom_1.LayoutDOM);    
},
/* models/tools/toolbar_box */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
var action_tool_1 = require(202    /* ./actions/action_tool */);
var help_tool_1 = require(203    /* ./actions/help_tool */);
var gesture_tool_1 = require(213    /* ./gestures/gesture_tool */);
var inspect_tool_1 = require(224    /* ./inspectors/inspect_tool */);
var toolbar_base_1 = require(229    /* ./toolbar_base */);
var tool_proxy_1 = require(227    /* ./tool_proxy */);
var box_1 = require(131    /* ../layouts/box */);
exports.ToolbarBoxToolbar = function (superClass) {
    extend(ToolbarBoxToolbar, superClass);
    function ToolbarBoxToolbar() {
        return ToolbarBoxToolbar.__super__.constructor.apply(this, arguments);
    }
    ToolbarBoxToolbar.prototype.type = 'ToolbarBoxToolbar';
    ToolbarBoxToolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;
    ToolbarBoxToolbar.prototype.initialize = function (options) {
        ToolbarBoxToolbar.__super__.initialize.call(this, options);
        this._init_tools();
        if (this.merge_tools === true) {
            return this._merge_tools();
        }
    };
    ToolbarBoxToolbar.define({
        merge_tools: [
            p.Bool,
            true
        ]
    });
    ToolbarBoxToolbar.prototype._init_tools = function () {
        var et, i, len, ref, results, tool;
        ref = this.tools;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
            tool = ref[i];
            if (tool instanceof inspect_tool_1.InspectTool) {
                if (!array_1.any(this.inspectors, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    results.push(this.inspectors = this.inspectors.concat([tool]));
                } else {
                    results.push(void 0);
                }
            } else if (tool instanceof help_tool_1.HelpTool) {
                if (!array_1.any(this.help, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    results.push(this.help = this.help.concat([tool]));
                } else {
                    results.push(void 0);
                }
            } else if (tool instanceof action_tool_1.ActionTool) {
                if (!array_1.any(this.actions, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    results.push(this.actions = this.actions.concat([tool]));
                } else {
                    results.push(void 0);
                }
            } else if (tool instanceof gesture_tool_1.GestureTool) {
                et = tool.event_type;
                if (!array_1.any(this.gestures[et].tools, function (_this) {
                        return function (t) {
                            return t.id === tool.id;
                        };
                    }(this))) {
                    results.push(this.gestures[et].tools = this.gestures[et].tools.concat([tool]));
                } else {
                    results.push(void 0);
                }
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    ToolbarBoxToolbar.prototype._merge_tools = function () {
        var actions, active, et, event_type, gestures, helptool, i, info, inspectors, j, k, l, len, len1, len2, len3, make_proxy, new_help_tools, new_help_urls, proxy, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, tool, tool_type, tools;
        inspectors = {};
        actions = {};
        gestures = {};
        new_help_tools = [];
        new_help_urls = [];
        ref = this.help;
        for (i = 0, len = ref.length; i < len; i++) {
            helptool = ref[i];
            if (ref1 = helptool.redirect, indexOf.call(new_help_urls, ref1) < 0) {
                new_help_tools.push(helptool);
                new_help_urls.push(helptool.redirect);
            }
        }
        this.help = new_help_tools;
        ref2 = this.gestures;
        for (event_type in ref2) {
            info = ref2[event_type];
            if (!(event_type in gestures)) {
                gestures[event_type] = {};
            }
            ref3 = info.tools;
            for (j = 0, len1 = ref3.length; j < len1; j++) {
                tool = ref3[j];
                if (!(tool.type in gestures[event_type])) {
                    gestures[event_type][tool.type] = [];
                }
                gestures[event_type][tool.type].push(tool);
            }
        }
        ref4 = this.inspectors;
        for (k = 0, len2 = ref4.length; k < len2; k++) {
            tool = ref4[k];
            if (!(tool.type in inspectors)) {
                inspectors[tool.type] = [];
            }
            inspectors[tool.type].push(tool);
        }
        ref5 = this.actions;
        for (l = 0, len3 = ref5.length; l < len3; l++) {
            tool = ref5[l];
            if (!(tool.type in actions)) {
                actions[tool.type] = [];
            }
            actions[tool.type].push(tool);
        }
        make_proxy = function (tools, active) {
            if (active == null) {
                active = false;
            }
            return new tool_proxy_1.ToolProxy({
                tools: tools,
                event_type: tools[0].event_type,
                tooltip: tools[0].tool_name,
                tool_name: tools[0].tool_name,
                icon: tools[0].icon,
                active: active
            });
        };
        for (event_type in gestures) {
            this.gestures[event_type].tools = [];
            ref6 = gestures[event_type];
            for (tool_type in ref6) {
                tools = ref6[tool_type];
                if (tools.length > 0) {
                    proxy = make_proxy(tools);
                    this.gestures[event_type].tools.push(proxy);
                    this.connect(proxy.properties.active.change, this._active_change.bind(null, proxy));
                }
            }
        }
        this.actions = [];
        for (tool_type in actions) {
            tools = actions[tool_type];
            if (tools.length > 0) {
                this.actions.push(make_proxy(tools));
            }
        }
        this.inspectors = [];
        for (tool_type in inspectors) {
            tools = inspectors[tool_type];
            if (tools.length > 0) {
                this.inspectors.push(make_proxy(tools, active = true));
            }
        }
        results = [];
        for (et in this.gestures) {
            tools = this.gestures[et].tools;
            if (tools.length === 0) {
                continue;
            }
            this.gestures[et].tools = array_1.sortBy(tools, function (tool) {
                return tool.default_order;
            });
            if (et !== 'pinch' && et !== 'scroll') {
                results.push(this.gestures[et].tools[0].active = true);
            } else {
                results.push(void 0);
            }
        }
        return results;
    };
    return ToolbarBoxToolbar;
}(toolbar_base_1.ToolbarBase);
exports.ToolbarBoxView = function (superClass) {
    extend(ToolbarBoxView, superClass);
    function ToolbarBoxView() {
        return ToolbarBoxView.__super__.constructor.apply(this, arguments);
    }
    ToolbarBoxView.prototype.className = 'bk-toolbar-box';
    ToolbarBoxView.prototype.get_width = function () {
        if (this.model._horizontal === true) {
            return 30;
        } else {
            return null;
        }
    };
    ToolbarBoxView.prototype.get_height = function () {
        return 30;
    };
    return ToolbarBoxView;
}(box_1.BoxView);
exports.ToolbarBox = function (superClass) {
    extend(ToolbarBox, superClass);
    function ToolbarBox() {
        return ToolbarBox.__super__.constructor.apply(this, arguments);
    }
    ToolbarBox.prototype.type = 'ToolbarBox';
    ToolbarBox.prototype.default_view = exports.ToolbarBoxView;
    ToolbarBox.prototype.initialize = function (options) {
        var ref;
        ToolbarBox.__super__.initialize.call(this, options);
        this._toolbar = new exports.ToolbarBoxToolbar(options);
        this._horizontal = (ref = this.toolbar_location) === 'left' || ref === 'right';
        return this._sizeable = !this._horizontal ? this._height : this._width;
    };
    ToolbarBox.prototype._doc_attached = function () {
        this._toolbar.attach_document(this.document);
        return ToolbarBox.__super__._doc_attached.call(this);
    };
    ToolbarBox.prototype.get_layoutable_children = function () {
        return [this._toolbar];
    };
    ToolbarBox.define({
        toolbar_location: [
            p.Location,
            'right'
        ],
        merge_tools: [
            p.Bool,
            true
        ],
        tools: [
            p.Any,
            []
        ],
        logo: [
            p.String,
            'normal'
        ]
    });
    return ToolbarBox;
}(box_1.Box);    
},
/* models/transforms/customjs_transform */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice;
var transform_1 = require(238    /* ./transform */);
var p = require(13    /* core/properties */);
var object_1 = require(28    /* core/util/object */);
exports.CustomJSTransform = function (superClass) {
    extend(CustomJSTransform, superClass);
    function CustomJSTransform() {
        return CustomJSTransform.__super__.constructor.apply(this, arguments);
    }
    CustomJSTransform.prototype.type = 'CustomJSTransform';
    CustomJSTransform.define({
        args: [
            p.Any,
            {}
        ],
        func: [
            p.String,
            ''
        ],
        v_func: [
            p.String,
            ''
        ]
    });
    CustomJSTransform.getters({
        values: function () {
            return this._make_values();
        },
        scalar_transform: function () {
            return this._make_transform('x', this.func);
        },
        vector_transform: function () {
            return this._make_transform('xs', this.v_func);
        }
    });
    CustomJSTransform.prototype.compute = function (x) {
        return this.scalar_transform.apply(this, slice.call(this.values).concat([x], [require], [exports]));
    };
    CustomJSTransform.prototype.v_compute = function (xs) {
        return this.vector_transform.apply(this, slice.call(this.values).concat([xs], [require], [exports]));
    };
    CustomJSTransform.prototype._make_transform = function (val, fn) {
        return function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor(), result = func.apply(child, args);
            return Object(result) === result ? result : child;
        }(Function, slice.call(Object.keys(this.args)).concat([val], ['require'], ['exports'], [fn]), function () {
        });
    };
    CustomJSTransform.prototype._make_values = function () {
        return object_1.values(this.args);
    };
    return CustomJSTransform;
}(transform_1.Transform);    
},
/* models/transforms/dodge */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var transform_1 = require(238    /* ./transform */);
var p = require(13    /* core/properties */);
exports.Dodge = function (superClass) {
    extend(Dodge, superClass);
    function Dodge() {
        return Dodge.__super__.constructor.apply(this, arguments);
    }
    Dodge.define({
        value: [
            p.Number,
            0
        ],
        range: [p.Instance]
    });
    Dodge.prototype.compute = function (x, use_synthetic) {
        var ref;
        if (use_synthetic == null) {
            use_synthetic = true;
        }
        if (((ref = this.range) != null ? ref.synthetic : void 0) != null && use_synthetic) {
            x = this.range.synthetic(x);
        }
        return x + this.value;
    };
    return Dodge;
}(transform_1.Transform);    
},
/* models/transforms/index */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var customjs_transform_1 = require(231    /* ./customjs_transform */);
exports.CustomJSTransform = customjs_transform_1.CustomJSTransform;
var dodge_1 = require(232    /* ./dodge */);
exports.Dodge = dodge_1.Dodge;
var interpolator_1 = require(234    /* ./interpolator */);
exports.Interpolator = interpolator_1.Interpolator;
var jitter_1 = require(235    /* ./jitter */);
exports.Jitter = jitter_1.Jitter;
var linear_interpolator_1 = require(236    /* ./linear_interpolator */);
exports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;
var step_interpolator_1 = require(237    /* ./step_interpolator */);
exports.StepInterpolator = step_interpolator_1.StepInterpolator;
var transform_1 = require(238    /* ./transform */);
exports.Transform = transform_1.Transform;    
},
/* models/transforms/interpolator */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    };
var transform_1 = require(238    /* ./transform */);
var p = require(13    /* core/properties */);
exports.Interpolator = function (superClass) {
    extend(Interpolator, superClass);
    function Interpolator() {
        return Interpolator.__super__.constructor.apply(this, arguments);
    }
    Interpolator.prototype.initialize = function (attrs, options) {
        Interpolator.__super__.initialize.call(this, attrs, options);
        this._x_sorted = [];
        this._y_sorted = [];
        this._sorted_dirty = true;
        return this.connect(this.change, function () {
            return this._sorted_dirty = true;
        });
    };
    Interpolator.define({
        x: [p.Any],
        y: [p.Any],
        data: [p.Any],
        clip: [
            p.Bool,
            true
        ]
    });
    Interpolator.prototype.sort = function (descending) {
        var column_names, data, i, j, k, list, ref, ref1, ref2, tsx, tsy;
        if (descending == null) {
            descending = false;
        }
        if (typeof this.x !== typeof this.y) {
            throw new Error('The parameters for x and y must be of the same type, either both strings which define a column in the data source or both arrays of the same length');
            return;
        } else {
            if (typeof this.x === 'string' && this.data === null) {
                throw new Error('If the x and y parameters are not specified as an array, the data parameter is reqired.');
                return;
            }
        }
        if (this._sorted_dirty === false) {
            return;
        }
        tsx = [];
        tsy = [];
        if (typeof this.x === 'string') {
            data = this.data;
            column_names = data.columns();
            if (ref = this.x, indexOf.call(column_names, ref) < 0) {
                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');
            }
            if (ref1 = this.y, indexOf.call(column_names, ref1) < 0) {
                throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');
            }
            tsx = data.get_column(this.x);
            tsy = data.get_column(this.y);
        } else {
            tsx = this.x;
            tsy = this.y;
        }
        if (tsx.length !== tsy.length) {
            throw new Error('The length for x and y do not match');
        }
        if (tsx.length < 2) {
            throw new Error('x and y must have at least two elements to support interpolation');
        }
        list = [];
        for (j in tsx) {
            list.push({
                'x': tsx[j],
                'y': tsy[j]
            });
        }
        if (descending === true) {
            list.sort(function (a, b) {
                var ref2, ref3;
                return (ref2 = a.x < b.x) != null ? ref2 : -{ 1: (ref3 = a.x === b.x) != null ? ref3 : { 0: 1 } };
            });
        } else {
            list.sort(function (a, b) {
                var ref2, ref3;
                return (ref2 = a.x > b.x) != null ? ref2 : -{ 1: (ref3 = a.x === b.x) != null ? ref3 : { 0: 1 } };
            });
        }
        for (k = i = 0, ref2 = list.length; 0 <= ref2 ? i < ref2 : i > ref2; k = 0 <= ref2 ? ++i : --i) {
            this._x_sorted[k] = list[k].x;
            this._y_sorted[k] = list[k].y;
        }
        return this._sorted_dirty = false;
    };
    return Interpolator;
}(transform_1.Transform);    
},
/* models/transforms/jitter */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var transform_1 = require(238    /* ./transform */);
var p = require(13    /* core/properties */);
var bokeh_math = require(27    /* core/util/math */);
exports.Jitter = function (superClass) {
    extend(Jitter, superClass);
    function Jitter() {
        return Jitter.__super__.constructor.apply(this, arguments);
    }
    Jitter.define({
        mean: [
            p.Number,
            0
        ],
        width: [
            p.Number,
            1
        ],
        distribution: [
            p.Distribution,
            'uniform'
        ],
        range: [p.Instance]
    });
    Jitter.prototype.compute = function (x, use_synthetic) {
        var ref;
        if (use_synthetic == null) {
            use_synthetic = true;
        }
        if (((ref = this.range) != null ? ref.synthetic : void 0) != null && use_synthetic) {
            x = this.range.synthetic(x);
        }
        if (this.distribution === 'uniform') {
            return x + this.mean + (bokeh_math.random() - 0.5) * this.width;
        }
        if (this.distribution === 'normal') {
            return x + bokeh_math.rnorm(this.mean, this.width);
        }
    };
    return Jitter;
}(transform_1.Transform);    
},
/* models/transforms/linear_interpolator */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var array_1 = require(20    /* core/util/array */);
var interpolator_1 = require(234    /* ./interpolator */);
exports.LinearInterpolator = function (superClass) {
    extend(LinearInterpolator, superClass);
    function LinearInterpolator() {
        return LinearInterpolator.__super__.constructor.apply(this, arguments);
    }
    LinearInterpolator.prototype.compute = function (x) {
        var descending, ind, ret, x1, x2, y1, y2;
        this.sort(descending = false);
        if (this.clip === true) {
            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {
                return null;
            }
        } else {
            if (x < this._x_sorted[0]) {
                return this._y_sorted[0];
            }
            if (x > this._x_sorted[this._x_sorted.length - 1]) {
                return this._y_sorted[this._y_sorted.length - 1];
            }
        }
        if (x === this._x_sorted[0]) {
            return this._y_sorted[0];
        }
        ind = array_1.findLastIndex(this._x_sorted, function (num) {
            return num < x;
        });
        x1 = this._x_sorted[ind];
        x2 = this._x_sorted[ind + 1];
        y1 = this._y_sorted[ind];
        y2 = this._y_sorted[ind + 1];
        ret = y1 + (x - x1) / (x2 - x1) * (y2 - y1);
        return ret;
    };
    LinearInterpolator.prototype.v_compute = function (xs) {
        var i, idx, len, result, x;
        result = new Float64Array(xs.length);
        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
            x = xs[idx];
            result[idx] = this.compute(x);
        }
        return result;
    };
    return LinearInterpolator;
}(interpolator_1.Interpolator);    
},
/* models/transforms/step_interpolator */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var interpolator_1 = require(234    /* ./interpolator */);
var p = require(13    /* core/properties */);
var array_1 = require(20    /* core/util/array */);
exports.StepInterpolator = function (superClass) {
    extend(StepInterpolator, superClass);
    function StepInterpolator() {
        return StepInterpolator.__super__.constructor.apply(this, arguments);
    }
    StepInterpolator.define({
        mode: [
            p.TransformStepMode,
            'after'
        ]
    });
    StepInterpolator.prototype.compute = function (x) {
        var descending, diffs, ind, mdiff, ret, tx;
        this.sort(descending = false);
        if (this.clip === true) {
            if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {
                return null;
            }
        } else {
            if (x < this._x_sorted[0]) {
                return this._y_sorted[0];
            }
            if (x > this._x_sorted[this._x_sorted.length - 1]) {
                return this._y_sorted[this._y_sorted.length - 1];
            }
        }
        ind = -1;
        if (this.mode === 'after') {
            ind = array_1.findLastIndex(this._x_sorted, function (num) {
                return x >= num;
            });
        }
        if (this.mode === 'before') {
            ind = array_1.findIndex(this._x_sorted, function (num) {
                return x <= num;
            });
        }
        if (this.mode === 'center') {
            diffs = function () {
                var i, len, ref, results;
                ref = this._x_sorted;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    tx = ref[i];
                    results.push(Math.abs(tx - x));
                }
                return results;
            }.call(this);
            mdiff = array_1.min(diffs);
            ind = array_1.findIndex(diffs, function (num) {
                return mdiff === num;
            });
        }
        if (ind !== -1) {
            ret = this._y_sorted[ind];
        } else {
            ret = null;
        }
        return ret;
    };
    StepInterpolator.prototype.v_compute = function (xs) {
        var i, idx, len, result, x;
        result = new Float64Array(xs.length);
        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
            x = xs[idx];
            result[idx] = this.compute(x);
        }
        return result;
    };
    return StepInterpolator;
}(interpolator_1.Interpolator);    
},
/* models/transforms/transform */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key))
                child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
var model_1 = require(48    /* ../../model */);
exports.Transform = function (superClass) {
    extend(Transform, superClass);
    function Transform() {
        return Transform.__super__.constructor.apply(this, arguments);
    }
    Transform.prototype.v_compute = function (xs) {
        var i, idx, len, ref, result, x;
        if (((ref = this.range) != null ? ref.v_synthetic : void 0) != null) {
            xs = this.range.v_synthetic(xs);
        }
        result = new Float64Array(xs.length);
        for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
            x = xs[idx];
            result[idx] = this.compute(x, false);
        }
        return result;
    };
    return Transform;
}(model_1.Model);    
},
/* polyfill */ function(require, module, exports) {
'use strict';
if (typeof WeakMap !== 'function') {
    require(306    /* es6-weak-map/implement */);
}
if (typeof Set !== 'function') {
    require(296    /* es6-set/implement */);
}
var proto = String.prototype;
if (!proto.repeat) {
    proto.repeat = function (count) {
        if (this == null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        // Could we try:
        // return Array(count + 1).join(this);
        return rpt;
    };
}    
},
/* safely */ function(require, module, exports) {
'use strict';
// Keep this code as terse and as close to vanila JS as possible. If we
// arrived here, it means we should trust no one and need to act properly.
Object.defineProperty(exports, '__esModule', { value: true });
function _burst_into_flames(error) {
    // Make box
    var box = document.createElement('div');
    box.style.backgroundColor = '#f2dede';
    box.style.border = '1px solid #a94442';
    box.style.borderRadius = '4px';
    box.style.display = 'inline-block';
    box.style.fontFamily = 'sans-serif';
    box.style.marginTop = '5px';
    box.style.minWidth = '200px';
    box.style.padding = '5px 5px 5px 10px';
    // Make button
    var button = document.createElement('span');
    button.style.backgroundColor = '#a94442';
    button.style.borderRadius = '0px 4px 0px 0px';
    button.style.color = 'white';
    button.style.cursor = 'pointer';
    button.style.cssFloat = 'right';
    button.style.fontSize = '0.8em';
    button.style.margin = '-6px -6px 0px 0px';
    button.style.padding = '2px 5px 4px 5px';
    button.title = 'close';
    button.setAttribute('aria-label', 'close');
    button.appendChild(document.createTextNode('x'));
    button.addEventListener('click', function () {
        return body.removeChild(box);
    });
    // Make title
    var title = document.createElement('h3');
    title.style.color = '#a94442';
    title.style.margin = '8px 0px 0px 0px';
    title.style.padding = '0px';
    title.appendChild(document.createTextNode('Bokeh Error'));
    // Make message
    var message = document.createElement('pre');
    message.style.whiteSpace = 'unset';
    message.style.overflowX = 'auto';
    message.appendChild(document.createTextNode(error.message || error));
    // Add pieces to box
    box.appendChild(button);
    box.appendChild(title);
    box.appendChild(message);
    // Put box in doc
    var body = document.getElementsByTagName('body')[0];
    body.insertBefore(box, body.firstChild);
}
function safely(fn, silent) {
    if (silent === void 0) {
        silent = false;
    }
    try {
        return fn();
    } catch (error) {
        _burst_into_flames(error);
        if (!silent)
            throw error;
        else
            return;
    }
}
exports.safely = safely;    
},
/* version */ function(require, module, exports) {
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.version = '0.12.7';    
},
/* canvas2svg/canvas2svg */ function(require, module, exports) {
/*!!
 *  Canvas 2 Svg v1.0.21
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */
;
(function () {
    'use strict';
    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;
    //helper function to format a string
    function format(str, args) {
        var keys = Object.keys(args), i;
        for (i = 0; i < keys.length; i++) {
            str = str.replace(new RegExp('\\{' + keys[i] + '\\}', 'gi'), args[keys[i]]);
        }
        return str;
    }
    //helper function that generates a random string
    function randomString(holder) {
        var chars, randomstring, i;
        if (!holder) {
            throw new Error('cannot create a random attribute name for an undefined object');
        }
        chars = 'ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
        randomstring = '';
        do {
            randomstring = '';
            for (i = 0; i < 12; i++) {
                randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
        } while (holder[randomstring]);
        return randomstring;
    }
    //helper function to map named to numbered entities
    function createNamedToNumberedLookup(items, radix) {
        var i, entity, lookup = {}, base10, base16;
        items = items.split(',');
        radix = radix || 10;
        // Map from named to numbered entities.
        for (i = 0; i < items.length; i += 2) {
            entity = '&' + items[i + 1] + ';';
            base10 = parseInt(items[i], radix);
            lookup[entity] = '&#' + base10 + ';';
        }
        //FF and IE need to create a regex from hex values ie &nbsp; == \xa0
        lookup['\\xa0'] = '&#160;';
        return lookup;
    }
    //helper function to map canvas-textAlign to svg-textAnchor
    function getTextAnchor(textAlign) {
        //TODO: support rtl languages
        var mapping = {
            'left': 'start',
            'right': 'end',
            'center': 'middle',
            'start': 'start',
            'end': 'end'
        };
        return mapping[textAlign] || mapping.start;
    }
    //helper function to map canvas-textBaseline to svg-dominantBaseline
    function getDominantBaseline(textBaseline) {
        //INFO: not supported in all browsers
        var mapping = {
            'alphabetic': 'alphabetic',
            'hanging': 'hanging',
            'top': 'text-before-edge',
            'bottom': 'text-after-edge',
            'middle': 'central'
        };
        return mapping[textBaseline] || mapping.alphabetic;
    }
    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    // entity mapping courtesy of tinymce
    namedEntities = createNamedToNumberedLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    //Some basic mappings for attributes and default values.
    STYLES = {
        'strokeStyle': {
            svgAttr: 'stroke',
            //corresponding svg attribute
            canvas: '#000000',
            //canvas default
            svg: 'none',
            //svg default
            apply: 'stroke'    //apply on stroke() or fill()
        },
        'fillStyle': {
            svgAttr: 'fill',
            canvas: '#000000',
            svg: null,
            //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply: 'fill'
        },
        'lineCap': {
            svgAttr: 'stroke-linecap',
            canvas: 'butt',
            svg: 'butt',
            apply: 'stroke'
        },
        'lineJoin': {
            svgAttr: 'stroke-linejoin',
            canvas: 'miter',
            svg: 'miter',
            apply: 'stroke'
        },
        'miterLimit': {
            svgAttr: 'stroke-miterlimit',
            canvas: 10,
            svg: 4,
            apply: 'stroke'
        },
        'lineWidth': {
            svgAttr: 'stroke-width',
            canvas: 1,
            svg: 1,
            apply: 'stroke'
        },
        'globalAlpha': {
            svgAttr: 'opacity',
            canvas: 1,
            svg: 1,
            apply: 'fill stroke'
        },
        'font': {
            //font converts to multiple svg attributes, there is custom logic for this
            canvas: '10px sans-serif'
        },
        'shadowColor': { canvas: '#000000' },
        'shadowOffsetX': { canvas: 0 },
        'shadowOffsetY': { canvas: 0 },
        'shadowBlur': { canvas: 0 },
        'textAlign': { canvas: 'start' },
        'textBaseline': { canvas: 'alphabetic' },
        'lineDash': {
            svgAttr: 'stroke-dasharray',
            canvas: [],
            svg: null,
            apply: 'stroke'
        }
    };
    /**
     *
     * @param gradientNode - reference to the gradient
     * @constructor
     */
    CanvasGradient = function (gradientNode, ctx) {
        this.__root = gradientNode;
        this.__ctx = ctx;
    };
    /**
     * Adds a color stop to the gradient root
     */
    CanvasGradient.prototype.addColorStop = function (offset, color) {
        var stop = this.__ctx.__createElement('stop'), regex, matches;
        stop.setAttribute('offset', offset);
        if (color.indexOf('rgba') !== -1) {
            //separate alpha value, since webkit can't handle it
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches = regex.exec(color);
            stop.setAttribute('stop-color', format('rgb({r},{g},{b})', {
                r: matches[1],
                g: matches[2],
                b: matches[3]
            }));
            stop.setAttribute('stop-opacity', matches[4]);
        } else {
            stop.setAttribute('stop-color', color);
        }
        this.__root.appendChild(stop);
    };
    CanvasPattern = function (pattern, ctx) {
        this.__root = pattern;
        this.__ctx = ctx;
    };
    /**
     * The mock canvas context
     * @param o - options include:
     * ctx - existing Context2D to wrap around
     * width - width of your canvas (defaults to 500)
     * height - height of your canvas (defaults to 500)
     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)
     * document - the document object (defaults to the current document)
     */
    ctx = function (o) {
        var defaultOptions = {
                width: 500,
                height: 500,
                enableMirroring: false
            }, options;
        //keep support for this way of calling C2S: new C2S(width,height)
        if (arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
        } else if (!o) {
            options = defaultOptions;
        } else {
            options = o;
        }
        if (!(this instanceof ctx)) {
            //did someone call this without new?
            return new ctx(options);
        }
        //setup options
        this.width = options.width || defaultOptions.width;
        this.height = options.height || defaultOptions.height;
        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;
        this.canvas = this;
        ///point back to this instance!
        this.__document = options.document || document;
        // allow passing in an existing context to wrap around
        // if a context is passed in, we know a canvas already exist
        if (options.ctx) {
            this.__ctx = options.ctx;
        } else {
            this.__canvas = this.__document.createElement('canvas');
            this.__ctx = this.__canvas.getContext('2d');
        }
        this.__setDefaultStyles();
        this.__stack = [this.__getStyleState()];
        this.__groupStack = [];
        //the root svg element
        this.__root = this.__document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        this.__root.setAttribute('version', 1.1);
        this.__root.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        this.__root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
        this.__root.setAttribute('width', this.width);
        this.__root.setAttribute('height', this.height);
        //make sure we don't generate the same ids in defs
        this.__ids = {};
        //defs tag
        this.__defs = this.__document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        this.__root.appendChild(this.__defs);
        //also add a group child. the svg element can't use the transform attribute
        this.__currentElement = this.__document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.__root.appendChild(this.__currentElement);
    };
    /**
     * Creates the specified svg element
     * @private
     */
    ctx.prototype.__createElement = function (elementName, properties, resetFill) {
        if (typeof properties === 'undefined') {
            properties = {};
        }
        var element = this.__document.createElementNS('http://www.w3.org/2000/svg', elementName), keys = Object.keys(properties), i, key;
        if (resetFill) {
            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.
            element.setAttribute('fill', 'none');
            element.setAttribute('stroke', 'none');
        }
        for (i = 0; i < keys.length; i++) {
            key = keys[i];
            element.setAttribute(key, properties[key]);
        }
        return element;
    };
    /**
     * Applies default canvas styles to the context
     * @private
     */
    ctx.prototype.__setDefaultStyles = function () {
        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/
        var keys = Object.keys(STYLES), i, key;
        for (i = 0; i < keys.length; i++) {
            key = keys[i];
            this[key] = STYLES[key].canvas;
        }
    };
    /**
     * Applies styles on restore
     * @param styleState
     * @private
     */
    ctx.prototype.__applyStyleState = function (styleState) {
        var keys = Object.keys(styleState), i, key;
        for (i = 0; i < keys.length; i++) {
            key = keys[i];
            this[key] = styleState[key];
        }
    };
    /**
     * Gets the current style state
     * @return {Object}
     * @private
     */
    ctx.prototype.__getStyleState = function () {
        var i, styleState = {}, keys = Object.keys(STYLES), key;
        for (i = 0; i < keys.length; i++) {
            key = keys[i];
            styleState[key] = this[key];
        }
        return styleState;
    };
    /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     * @param type
     * @private
     */
    ctx.prototype.__applyStyleToCurrentElement = function (type) {
        var currentElement = this.__currentElement;
        var currentStyleGroup = this.__currentElementsToStyle;
        if (currentStyleGroup) {
            currentElement.setAttribute(type, '');
            currentElement = currentStyleGroup.element;
            currentStyleGroup.children.forEach(function (node) {
                node.setAttribute(type, '');
            });
        }
        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
        for (i = 0; i < keys.length; i++) {
            style = STYLES[keys[i]];
            value = this[keys[i]];
            if (style.apply) {
                //is this a gradient or pattern?
                if (value instanceof CanvasPattern) {
                    //pattern
                    if (value.__ctx) {
                        //copy over defs
                        while (value.__ctx.__defs.childNodes.length) {
                            id = value.__ctx.__defs.childNodes[0].getAttribute('id');
                            this.__ids[id] = id;
                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                        }
                    }
                    currentElement.setAttribute(style.apply, format('url(#{id})', { id: value.__root.getAttribute('id') }));
                } else if (value instanceof CanvasGradient) {
                    //gradient
                    currentElement.setAttribute(style.apply, format('url(#{id})', { id: value.__root.getAttribute('id') }));
                } else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {
                    if ((style.svgAttr === 'stroke' || style.svgAttr === 'fill') && value.indexOf('rgba') !== -1) {
                        //separate alpha value, since illustrator can't handle it
                        regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                        matches = regex.exec(value);
                        currentElement.setAttribute(style.svgAttr, format('rgb({r},{g},{b})', {
                            r: matches[1],
                            g: matches[2],
                            b: matches[3]
                        }));
                        //should take globalAlpha here
                        var opacity = matches[4];
                        var globalAlpha = this.globalAlpha;
                        if (globalAlpha != null) {
                            opacity *= globalAlpha;
                        }
                        currentElement.setAttribute(style.svgAttr + '-opacity', opacity);
                    } else {
                        var attr = style.svgAttr;
                        if (keys[i] === 'globalAlpha') {
                            attr = type + '-' + style.svgAttr;
                            if (currentElement.getAttribute(attr)) {
                                //fill-opacity or stroke-opacity has already been set by stroke or fill.
                                continue;
                            }
                        }
                        //otherwise only update attribute if right type, and not svg default
                        currentElement.setAttribute(attr, value);
                    }
                }
            }
        }
    };
    /**
     * Will return the closest group or svg node. May return the current element.
     * @private
     */
    ctx.prototype.__closestGroupOrSvg = function (node) {
        node = node || this.__currentElement;
        if (node.nodeName === 'g' || node.nodeName === 'svg') {
            return node;
        } else {
            return this.__closestGroupOrSvg(node.parentNode);
        }
    };
    /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
     *                           If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
    ctx.prototype.getSerializedSvg = function (fixNamedEntities) {
        var serialized = new XMLSerializer().serializeToString(this.__root), keys, i, key, value, regexp, xmlns;
        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly
        xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
        if (xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
        }
        if (fixNamedEntities) {
            keys = Object.keys(namedEntities);
            //loop over each named entity and replace with the proper equivalent.
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                value = namedEntities[key];
                regexp = new RegExp(key, 'gi');
                if (regexp.test(serialized)) {
                    serialized = serialized.replace(regexp, value);
                }
            }
        }
        return serialized;
    };
    /**
     * Returns the root svg
     * @return
     */
    ctx.prototype.getSvg = function () {
        return this.__root;
    };
    /**
     * Will generate a group tag.
     */
    ctx.prototype.save = function () {
        var group = this.__createElement('g');
        var parent = this.__closestGroupOrSvg();
        this.__groupStack.push(parent);
        parent.appendChild(group);
        this.__currentElement = group;
        this.__stack.push(this.__getStyleState());
    };
    /**
     * Sets current element to parent, or just root if already root
     */
    ctx.prototype.restore = function () {
        this.__currentElement = this.__groupStack.pop();
        this.__currentElementsToStyle = null;
        //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.
        if (!this.__currentElement) {
            this.__currentElement = this.__root.childNodes[1];
        }
        var state = this.__stack.pop();
        this.__applyStyleState(state);
    };
    /**
     * Helper method to add transform
     * @private
     */
    ctx.prototype.__addTransform = function (t) {
        //if the current element has siblings, add another group
        var parent = this.__closestGroupOrSvg();
        if (parent.childNodes.length > 0) {
            if (this.__currentElement.nodeName === 'path') {
                if (!this.__currentElementsToStyle)
                    this.__currentElementsToStyle = {
                        element: parent,
                        children: []
                    };
                this.__currentElementsToStyle.children.push(this.__currentElement);
                this.__applyCurrentDefaultPath();
            }
            var group = this.__createElement('g');
            parent.appendChild(group);
            this.__currentElement = group;
        }
        var transform = this.__currentElement.getAttribute('transform');
        if (transform) {
            transform += ' ';
        } else {
            transform = '';
        }
        transform += t;
        this.__currentElement.setAttribute('transform', transform);
    };
    /**
     *  scales the current element
     */
    ctx.prototype.scale = function (x, y) {
        if (y === undefined) {
            y = x;
        }
        this.__addTransform(format('scale({x},{y})', {
            x: x,
            y: y
        }));
    };
    /**
     * rotates the current element
     */
    ctx.prototype.rotate = function (angle) {
        var degrees = angle * 180 / Math.PI;
        this.__addTransform(format('rotate({angle},{cx},{cy})', {
            angle: degrees,
            cx: 0,
            cy: 0
        }));
    };
    /**
     * translates the current element
     */
    ctx.prototype.translate = function (x, y) {
        this.__addTransform(format('translate({x},{y})', {
            x: x,
            y: y
        }));
    };
    /**
     * applies a transform to the current element
     */
    ctx.prototype.transform = function (a, b, c, d, e, f) {
        this.__addTransform(format('matrix({a},{b},{c},{d},{e},{f})', {
            a: a,
            b: b,
            c: c,
            d: d,
            e: e,
            f: f
        }));
    };
    /**
     * Create a new Path Element
     */
    ctx.prototype.beginPath = function () {
        var path, parent;
        // Note that there is only one current default path, it is not part of the drawing state.
        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path
        this.__currentDefaultPath = '';
        this.__currentPosition = {};
        path = this.__createElement('path', {}, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(path);
        this.__currentElement = path;
    };
    /**
     * Helper function to apply currentDefaultPath to current path element
     * @private
     */
    ctx.prototype.__applyCurrentDefaultPath = function () {
        var currentElement = this.__currentElement;
        if (currentElement.nodeName === 'path') {
            currentElement.setAttribute('d', this.__currentDefaultPath);
        } else {
            console.error('Attempted to apply path command to node', currentElement.nodeName);
        }
    };
    /**
     * Helper function to add path command
     * @private
     */
    ctx.prototype.__addPathCommand = function (command) {
        this.__currentDefaultPath += ' ';
        this.__currentDefaultPath += command;
    };
    /**
     * Adds the move command to the current path element,
     * if the currentPathElement is not empty create a new path element
     */
    ctx.prototype.moveTo = function (x, y) {
        if (this.__currentElement.nodeName !== 'path') {
            this.beginPath();
        }
        // creates a new subpath with the given point
        this.__currentPosition = {
            x: x,
            y: y
        };
        this.__addPathCommand(format('M {x} {y}', {
            x: x,
            y: y
        }));
    };
    /**
     * Closes the current path
     */
    ctx.prototype.closePath = function () {
        if (this.__currentDefaultPath) {
            this.__addPathCommand('Z');
        }
    };
    /**
     * Adds a line to command
     */
    ctx.prototype.lineTo = function (x, y) {
        this.__currentPosition = {
            x: x,
            y: y
        };
        if (this.__currentDefaultPath.indexOf('M') > -1) {
            this.__addPathCommand(format('L {x} {y}', {
                x: x,
                y: y
            }));
        } else {
            this.__addPathCommand(format('M {x} {y}', {
                x: x,
                y: y
            }));
        }
    };
    /**
     * Add a bezier command
     */
    ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        this.__currentPosition = {
            x: x,
            y: y
        };
        this.__addPathCommand(format('C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}', {
            cp1x: cp1x,
            cp1y: cp1y,
            cp2x: cp2x,
            cp2y: cp2y,
            x: x,
            y: y
        }));
    };
    /**
     * Adds a quadratic curve to command
     */
    ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        this.__currentPosition = {
            x: x,
            y: y
        };
        this.__addPathCommand(format('Q {cpx} {cpy} {x} {y}', {
            cpx: cpx,
            cpy: cpy,
            x: x,
            y: y
        }));
    };
    /**
     * Return a new normalized vector of given vector
     */
    var normalize = function (vector) {
        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        return [
            vector[0] / len,
            vector[1] / len
        ];
    };
    /**
     * Adds the arcTo to the current path
     *
     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
     */
    ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        // Let the point (x0, y0) be the last point in the subpath.
        var x0 = this.__currentPosition && this.__currentPosition.x;
        var y0 = this.__currentPosition && this.__currentPosition.y;
        // First ensure there is a subpath for (x1, y1).
        if (typeof x0 == 'undefined' || typeof y0 == 'undefined') {
            return;
        }
        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.
        if (radius < 0) {
            throw new Error('IndexSizeError: The radius provided (' + radius + ') is negative.');
        }
        // If the point (x0, y0) is equal to the point (x1, y1),
        // or if the point (x1, y1) is equal to the point (x2, y2),
        // or if the radius radius is zero,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
            this.lineTo(x1, y1);
            return;
        }
        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        var unit_vec_p1_p0 = normalize([
            x0 - x1,
            y0 - y1
        ]);
        var unit_vec_p1_p2 = normalize([
            x2 - x1,
            y2 - y1
        ]);
        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
        }
        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,
        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),
        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).
        // The points at which this circle touches these two lines are called the start and end tangent points respectively.
        // note that both vectors are unit vectors, so the length is 1
        var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
        var theta = Math.acos(Math.abs(cos));
        // Calculate origin
        var unit_vec_p1_origin = normalize([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
        ]);
        var len_p1_origin = radius / Math.sin(theta / 2);
        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];
        // Calculate start angle and end angle
        // rotate 90deg clockwise (note that y axis points to its down)
        var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
        ];
        // rotate 90deg counter clockwise (note that y axis points to its down)
        var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
        ];
        var getAngle = function (vector) {
            // get angle (clockwise) between vector and (1, 0)
            var x = vector[0];
            var y = vector[1];
            if (y >= 0) {
                // note that y axis points to its down
                return Math.acos(x);
            } else {
                return -Math.acos(x);
            }
        };
        var startAngle = getAngle(unit_vec_origin_start_tangent);
        var endAngle = getAngle(unit_vec_origin_end_tangent);
        // Connect the point (x0, y0) to the start tangent point by a straight line
        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius, y + unit_vec_origin_start_tangent[1] * radius);
        // Connect the start tangent point to the end tangent point by arc
        // and adding the end tangent point to the subpath.
        this.arc(x, y, radius, startAngle, endAngle);
    };
    /**
     * Sets the stroke property on the current element
     */
    ctx.prototype.stroke = function () {
        if (this.__currentElement.nodeName === 'path') {
            this.__currentElement.setAttribute('paint-order', 'fill stroke markers');
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement('stroke');
    };
    /**
     * Sets fill properties on the current element
     */
    ctx.prototype.fill = function () {
        if (this.__currentElement.nodeName === 'path') {
            this.__currentElement.setAttribute('paint-order', 'stroke fill markers');
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement('fill');
    };
    /**
     *  Adds a rectangle to the path.
     */
    ctx.prototype.rect = function (x, y, width, height) {
        if (this.__currentElement.nodeName !== 'path') {
            this.beginPath();
        }
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.closePath();
    };
    /**
     * adds a rectangle element
     */
    ctx.prototype.fillRect = function (x, y, width, height) {
        var rect, parent;
        rect = this.__createElement('rect', {
            x: x,
            y: y,
            width: width,
            height: height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement('fill');
    };
    /**
     * Draws a rectangle with no fill
     * @param x
     * @param y
     * @param width
     * @param height
     */
    ctx.prototype.strokeRect = function (x, y, width, height) {
        var rect, parent;
        rect = this.__createElement('rect', {
            x: x,
            y: y,
            width: width,
            height: height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement('stroke');
    };
    /**
     * Clear entire canvas:
     * 1. save current transforms
     * 2. remove all the childNodes of the root g element
     */
    ctx.prototype.__clearCanvas = function () {
        var current = this.__closestGroupOrSvg(), transform = current.getAttribute('transform');
        var rootGroup = this.__root.childNodes[1];
        var childNodes = rootGroup.childNodes;
        for (var i = childNodes.length - 1; i >= 0; i--) {
            if (childNodes[i]) {
                rootGroup.removeChild(childNodes[i]);
            }
        }
        this.__currentElement = rootGroup;
        //reset __groupStack as all the child group nodes are all removed.
        this.__groupStack = [];
        if (transform) {
            this.__addTransform(transform);
        }
    };
    /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
    ctx.prototype.clearRect = function (x, y, width, height) {
        //clear entire canvas
        if (x === 0 && y === 0 && width === this.width && height === this.height) {
            this.__clearCanvas();
            return;
        }
        var rect, parent = this.__closestGroupOrSvg();
        rect = this.__createElement('rect', {
            x: x,
            y: y,
            width: width,
            height: height,
            fill: '#FFFFFF'
        }, true);
        parent.appendChild(rect);
    };
    /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {
        var grad = this.__createElement('linearGradient', {
            id: randomString(this.__ids),
            x1: x1 + 'px',
            x2: x2 + 'px',
            y1: y1 + 'px',
            y2: y2 + 'px',
            'gradientUnits': 'userSpaceOnUse'
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
    };
    /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
        var grad = this.__createElement('radialGradient', {
            id: randomString(this.__ids),
            cx: x1 + 'px',
            cy: y1 + 'px',
            r: r1 + 'px',
            fx: x0 + 'px',
            fy: y0 + 'px',
            'gradientUnits': 'userSpaceOnUse'
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
    };
    /**
     * Parses the font string and returns svg mapping
     * @private
     */
    ctx.prototype.__parseFont = function () {
        var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
        var fontPart = regex.exec(this.font);
        var data = {
            style: fontPart[1] || 'normal',
            size: fontPart[4] || '10px',
            family: fontPart[6] || 'sans-serif',
            weight: fontPart[3] || 'normal',
            decoration: fontPart[2] || 'normal',
            href: null
        };
        //canvas doesn't support underline natively, but we can pass this attribute
        if (this.__fontUnderline === 'underline') {
            data.decoration = 'underline';
        }
        //canvas also doesn't support linking, but we can pass this as well
        if (this.__fontHref) {
            data.href = this.__fontHref;
        }
        return data;
    };
    /**
     * Helper to link text fragments
     * @param font
     * @param element
     * @return {*}
     * @private
     */
    ctx.prototype.__wrapTextLink = function (font, element) {
        if (font.href) {
            var a = this.__createElement('a');
            a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', font.href);
            a.appendChild(element);
            return a;
        }
        return element;
    };
    /**
     * Fills or strokes text
     * @param text
     * @param x
     * @param y
     * @param action - stroke or fill
     * @private
     */
    ctx.prototype.__applyText = function (text, x, y, action) {
        var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement('text', {
                'font-family': font.family,
                'font-size': font.size,
                'font-style': font.style,
                'font-weight': font.weight,
                'text-decoration': font.decoration,
                'x': x,
                'y': y,
                'text-anchor': getTextAnchor(this.textAlign),
                'dominant-baseline': getDominantBaseline(this.textBaseline)
            }, true);
        textElement.appendChild(this.__document.createTextNode(text));
        this.__currentElement = textElement;
        this.__applyStyleToCurrentElement(action);
        parent.appendChild(this.__wrapTextLink(font, textElement));
    };
    /**
     * Creates a text element
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.fillText = function (text, x, y) {
        this.__applyText(text, x, y, 'fill');
    };
    /**
     * Strokes text
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.strokeText = function (text, x, y) {
        this.__applyText(text, x, y, 'stroke');
    };
    /**
     * No need to implement this for svg.
     * @param text
     * @return {TextMetrics}
     */
    ctx.prototype.measureText = function (text) {
        this.__ctx.font = this.font;
        return this.__ctx.measureText(text);
    };
    /**
     *  Arc command!
     */
    ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {
        // in canvas no circle is drawn if no angle is provided.
        if (startAngle === endAngle) {
            return;
        }
        startAngle = startAngle % (2 * Math.PI);
        endAngle = endAngle % (2 * Math.PI);
        if (startAngle === endAngle) {
            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)
            endAngle = (endAngle + 2 * Math.PI - 0.001 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
        }
        var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
        // https://github.com/gliffy/canvas2svg/issues/4
        if (diff < 0) {
            diff += 2 * Math.PI;
        }
        if (counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
        } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
        }
        this.lineTo(startX, startY);
        this.__addPathCommand(format('A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}', {
            rx: radius,
            ry: radius,
            xAxisRotation: 0,
            largeArcFlag: largeArcFlag,
            sweepFlag: sweepFlag,
            endX: endX,
            endY: endY
        }));
        this.__currentPosition = {
            x: endX,
            y: endY
        };
    };
    /**
     * Generates a ClipPath from the clip command.
     */
    ctx.prototype.clip = function () {
        var group = this.__closestGroupOrSvg(), clipPath = this.__createElement('clipPath'), id = randomString(this.__ids), newGroup = this.__createElement('g');
        this.__applyCurrentDefaultPath();
        group.removeChild(this.__currentElement);
        clipPath.setAttribute('id', id);
        clipPath.appendChild(this.__currentElement);
        this.__defs.appendChild(clipPath);
        //set the clip path to this group
        group.setAttribute('clip-path', format('url(#{id})', { id: id }));
        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations
        // to this path
        group.appendChild(newGroup);
        this.__currentElement = newGroup;
    };
    /**
     * Draws a canvas, image or mock context to this canvas.
     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
    ctx.prototype.drawImage = function () {
        //convert arguments to a real array
        var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, currentElement, svgImage, canvas, context, id;
        if (args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
        } else if (args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
        } else if (args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else {
            throw new Error('Inavlid number of arguments passed to drawImage: ' + arguments.length);
        }
        parent = this.__closestGroupOrSvg();
        currentElement = this.__currentElement;
        var translateDirective = 'translate(' + dx + ', ' + dy + ')';
        if (image instanceof ctx) {
            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.
            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.
            svg = image.getSvg().cloneNode(true);
            if (svg.childNodes && svg.childNodes.length > 1) {
                defs = svg.childNodes[0];
                while (defs.childNodes.length) {
                    id = defs.childNodes[0].getAttribute('id');
                    this.__ids[id] = id;
                    this.__defs.appendChild(defs.childNodes[0]);
                }
                group = svg.childNodes[1];
                if (group) {
                    //save original transform
                    var originTransform = group.getAttribute('transform');
                    var transformDirective;
                    if (originTransform) {
                        transformDirective = originTransform + ' ' + translateDirective;
                    } else {
                        transformDirective = translateDirective;
                    }
                    group.setAttribute('transform', transformDirective);
                    parent.appendChild(group);
                }
            }
        } else if (image.nodeName === 'IMG') {
            svgImage = this.__createElement('image');
            svgImage.setAttribute('width', dw);
            svgImage.setAttribute('height', dh);
            svgImage.setAttribute('preserveAspectRatio', 'none');
            if (sx || sy || sw !== image.width || sh !== image.height) {
                //crop the image using a temporary canvas
                canvas = this.__document.createElement('canvas');
                canvas.width = dw;
                canvas.height = dh;
                context = canvas.getContext('2d');
                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                image = canvas;
            }
            svgImage.setAttribute('transform', translateDirective);
            svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.nodeName === 'CANVAS' ? image.toDataURL() : image.getAttribute('src'));
            parent.appendChild(svgImage);
        } else if (image.nodeName === 'CANVAS') {
            svgImage = this.__createElement('image');
            svgImage.setAttribute('width', dw);
            svgImage.setAttribute('height', dh);
            svgImage.setAttribute('preserveAspectRatio', 'none');
            // draw canvas onto temporary canvas so that smoothing can be handled
            canvas = this.__document.createElement('canvas');
            canvas.width = dw;
            canvas.height = dh;
            context = canvas.getContext('2d');
            context.imageSmoothingEnabled = false;
            context.mozImageSmoothingEnabled = false;
            context.oImageSmoothingEnabled = false;
            context.webkitImageSmoothingEnabled = false;
            context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
            image = canvas;
            svgImage.setAttribute('transform', translateDirective);
            svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.toDataURL());
            parent.appendChild(svgImage);
        }
    };
    /**
     * Generates a pattern tag
     */
    ctx.prototype.createPattern = function (image, repetition) {
        var pattern = this.__document.createElementNS('http://www.w3.org/2000/svg', 'pattern'), id = randomString(this.__ids), img;
        pattern.setAttribute('id', id);
        pattern.setAttribute('width', image.width);
        pattern.setAttribute('height', image.height);
        if (image.nodeName === 'CANVAS' || image.nodeName === 'IMG') {
            img = this.__document.createElementNS('http://www.w3.org/2000/svg', 'image');
            img.setAttribute('width', image.width);
            img.setAttribute('height', image.height);
            img.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.nodeName === 'CANVAS' ? image.toDataURL() : image.getAttribute('src'));
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
        } else if (image instanceof ctx) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
        }
        return new CanvasPattern(pattern, this);
    };
    ctx.prototype.setLineDash = function (dashArray) {
        if (dashArray && dashArray.length > 0) {
            this.lineDash = dashArray.join(',');
        } else {
            this.lineDash = null;
        }
    };
    /**
     * Not yet implemented
     */
    ctx.prototype.drawFocusRing = function () {
    };
    ctx.prototype.createImageData = function () {
    };
    ctx.prototype.getImageData = function () {
    };
    ctx.prototype.putImageData = function () {
    };
    ctx.prototype.globalCompositeOperation = function () {
    };
    ctx.prototype.setTransform = function () {
    };
    //add options for alternative namespace
    if (typeof window === 'object') {
        window.C2S = ctx;
    }
    // CommonJS/Browserify
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = ctx;
    }
}());},
/* d/auto-bind */ function(require, module, exports) {
'use strict';
var copy = require(266    /* es5-ext/object/copy */), normalizeOptions = require(276    /* es5-ext/object/normalize-options */), ensureCallable = require(280    /* es5-ext/object/valid-callable */), map = require(275    /* es5-ext/object/map */), callable = require(280    /* es5-ext/object/valid-callable */), validValue = require(282    /* es5-ext/object/valid-value */), bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, define;
define = function (name, desc, options) {
    var value = validValue(desc) && callable(desc.value), dgs;
    dgs = copy(desc);
    delete dgs.writable;
    delete dgs.value;
    dgs.get = function () {
        if (!options.overwriteDefinition && hasOwnProperty.call(this, name))
            return value;
        desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
        defineProperty(this, name, desc);
        return this[name];
    };
    return dgs;
};
module.exports = function (props) {
    var options = normalizeOptions(arguments[1]);
    if (options.resolveContext != null)
        ensureCallable(options.resolveContext);
    return map(props, function (desc, name) {
        return define(name, desc, options);
    });
};},
/* d/index */ function(require, module, exports) {
'use strict';
var assign = require(263    /* es5-ext/object/assign */), normalizeOpts = require(276    /* es5-ext/object/normalize-options */), isCallable = require(269    /* es5-ext/object/is-callable */), contains = require(283    /* es5-ext/string/#/contains */), d;
d = module.exports = function (dscr, value) {
    var c, e, w, options, desc;
    if (arguments.length < 2 || typeof dscr !== 'string') {
        options = value;
        value = dscr;
        dscr = null;
    } else {
        options = arguments[2];
    }
    if (dscr == null) {
        c = w = true;
        e = false;
    } else {
        c = contains.call(dscr, 'c');
        e = contains.call(dscr, 'e');
        w = contains.call(dscr, 'w');
    }
    desc = {
        value: value,
        configurable: c,
        enumerable: e,
        writable: w
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
};
d.gs = function (dscr, get, set) {
    var c, e, options, desc;
    if (typeof dscr !== 'string') {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
    } else {
        options = arguments[3];
    }
    if (get == null) {
        get = undefined;
    } else if (!isCallable(get)) {
        options = get;
        get = set = undefined;
    } else if (set == null) {
        set = undefined;
    } else if (!isCallable(set)) {
        options = set;
        set = undefined;
    }
    if (dscr == null) {
        c = true;
        e = false;
    } else {
        c = contains.call(dscr, 'c');
        e = contains.call(dscr, 'e');
    }
    desc = {
        get: get,
        set: set,
        configurable: c,
        enumerable: e
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
};},
/* es5-ext/array/#/clear */ function(require, module, exports) {
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear
'use strict';
var value = require(282    /* ../../object/valid-value */);
module.exports = function () {
    value(this).length = 0;
    return this;
};},
/* es5-ext/array/#/e-index-of */ function(require, module, exports) {
'use strict';
var numberIsNaN = require(257    /* ../../number/is-nan */), toPosInt = require(261    /* ../../number/to-pos-integer */), value = require(282    /* ../../object/valid-value */), indexOf = Array.prototype.indexOf, objHasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
module.exports = function (searchElement) {
    var i, length, fromIndex, val;
    if (!numberIsNaN(searchElement))
        return indexOf.apply(this, arguments);
    length = toPosInt(value(this).length);
    fromIndex = arguments[1];
    if (isNaN(fromIndex))
        fromIndex = 0;
    else if (fromIndex >= 0)
        fromIndex = floor(fromIndex);
    else
        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
    for (i = fromIndex; i < length; ++i) {
        if (objHasOwnProperty.call(this, i)) {
            val = this[i];
            if (numberIsNaN(val))
                return i;    // Jslint: ignore
        }
    }
    return -1;
};},
/* es5-ext/array/from/index */ function(require, module, exports) {
'use strict';
module.exports = require(248    /* ./is-implemented */)() ? Array.from : require(249    /* ./shim */);},
/* es5-ext/array/from/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var from = Array.from, arr, result;
    if (typeof from !== 'function')
        return false;
    arr = [
        'raz',
        'dwa'
    ];
    result = from(arr);
    return Boolean(result && result !== arr && result[1] === 'dwa');
};},
/* es5-ext/array/from/shim */ function(require, module, exports) {
'use strict';
var iteratorSymbol = require(301    /* es6-symbol */).iterator, isArguments = require(250    /* ../../function/is-arguments */), isFunction = require(251    /* ../../function/is-function */), toPosInt = require(261    /* ../../number/to-pos-integer */), callable = require(280    /* ../../object/valid-callable */), validValue = require(282    /* ../../object/valid-value */), isValue = require(271    /* ../../object/is-value */), isString = require(286    /* ../../string/is-string */), isArray = Array.isArray, call = Function.prototype.call, desc = {
        configurable: true,
        enumerable: true,
        writable: true,
        value: null
    }, defineProperty = Object.defineProperty;
// eslint-disable-next-line complexity
module.exports = function (arrayLike) {
    var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
    arrayLike = Object(validValue(arrayLike));
    if (isValue(mapFn))
        callable(mapFn);
    if (!this || this === Array || !isFunction(this)) {
        // Result: Plain array
        if (!mapFn) {
            if (isArguments(arrayLike)) {
                // Source: Arguments
                length = arrayLike.length;
                if (length !== 1)
                    return Array.apply(null, arrayLike);
                arr = new Array(1);
                arr[0] = arrayLike[0];
                return arr;
            }
            if (isArray(arrayLike)) {
                // Source: Array
                arr = new Array(length = arrayLike.length);
                for (i = 0; i < length; ++i)
                    arr[i] = arrayLike[i];
                return arr;
            }
        }
        arr = [];
    } else {
        // Result: Non plain array
        Context = this;
    }
    if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
            // Source: Iterator
            iterator = callable(getIterator).call(arrayLike);
            if (Context)
                arr = new Context();
            result = iterator.next();
            i = 0;
            while (!result.done) {
                value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
                if (Context) {
                    desc.value = value;
                    defineProperty(arr, i, desc);
                } else {
                    arr[i] = value;
                }
                result = iterator.next();
                ++i;
            }
            length = i;
        } else if (isString(arrayLike)) {
            // Source: String
            length = arrayLike.length;
            if (Context)
                arr = new Context();
            for (i = 0, j = 0; i < length; ++i) {
                value = arrayLike[i];
                if (i + 1 < length) {
                    code = value.charCodeAt(0);
                    // eslint-disable-next-line max-depth
                    if (code >= 55296 && code <= 56319)
                        value += arrayLike[++i];
                }
                value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
                if (Context) {
                    desc.value = value;
                    defineProperty(arr, j, desc);
                } else {
                    arr[j] = value;
                }
                ++j;
            }
            length = j;
        }
    }
    if (length === undefined) {
        // Source: array or array-like
        length = toPosInt(arrayLike.length);
        if (Context)
            arr = new Context(length);
        for (i = 0; i < length; ++i) {
            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
            if (Context) {
                desc.value = value;
                defineProperty(arr, i, desc);
            } else {
                arr[i] = value;
            }
        }
    }
    if (Context) {
        desc.value = null;
        arr.length = length;
    }
    return arr;
};},
/* es5-ext/function/is-arguments */ function(require, module, exports) {
'use strict';
var objToString = Object.prototype.toString, id = objToString.call(function () {
        return arguments;
    }());
module.exports = function (value) {
    return objToString.call(value) === id;
};},
/* es5-ext/function/is-function */ function(require, module, exports) {
'use strict';
var objToString = Object.prototype.toString, id = objToString.call(require(252    /* ./noop */));
module.exports = function (value) {
    return typeof value === 'function' && objToString.call(value) === id;
};},
/* es5-ext/function/noop */ function(require, module, exports) {
'use strict';
// eslint-disable-next-line no-empty-function
module.exports = function () {
};},
/* es5-ext/global */ function(require, module, exports) {
/* eslint strict: "off" */
module.exports = function () {
    return this;
}();},
/* es5-ext/math/sign/index */ function(require, module, exports) {
'use strict';
module.exports = require(255    /* ./is-implemented */)() ? Math.sign : require(256    /* ./shim */);},
/* es5-ext/math/sign/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var sign = Math.sign;
    if (typeof sign !== 'function')
        return false;
    return sign(10) === 1 && sign(-20) === -1;
};},
/* es5-ext/math/sign/shim */ function(require, module, exports) {
'use strict';
module.exports = function (value) {
    value = Number(value);
    if (isNaN(value) || value === 0)
        return value;
    return value > 0 ? 1 : -1;
};},
/* es5-ext/number/is-nan/index */ function(require, module, exports) {
'use strict';
module.exports = require(258    /* ./is-implemented */)() ? Number.isNaN : require(259    /* ./shim */);},
/* es5-ext/number/is-nan/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var numberIsNaN = Number.isNaN;
    if (typeof numberIsNaN !== 'function')
        return false;
    return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
};},
/* es5-ext/number/is-nan/shim */ function(require, module, exports) {
'use strict';
module.exports = function (value) {
    // eslint-disable-next-line no-self-compare
    return value !== value;
};},
/* es5-ext/number/to-integer */ function(require, module, exports) {
'use strict';
var sign = require(254    /* ../math/sign */), abs = Math.abs, floor = Math.floor;
module.exports = function (value) {
    if (isNaN(value))
        return 0;
    value = Number(value);
    if (value === 0 || !isFinite(value))
        return value;
    return sign(value) * floor(abs(value));
};},
/* es5-ext/number/to-pos-integer */ function(require, module, exports) {
'use strict';
var toInteger = require(260    /* ./to-integer */), max = Math.max;
module.exports = function (value) {
    return max(0, toInteger(value));
};},
/* es5-ext/object/_iterate */ function(require, module, exports) {
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order
'use strict';
var callable = require(280    /* ./valid-callable */), value = require(282    /* ./valid-value */), bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys, objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
module.exports = function (method, defVal) {
    return function (obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
            list.sort(typeof compareFn === 'function' ? bind.call(compareFn, obj) : undefined);
        }
        if (typeof method !== 'function')
            method = list[method];
        return call.call(method, list, function (key, index) {
            if (!objPropertyIsEnumerable.call(obj, key))
                return defVal;
            return call.call(cb, thisArg, obj[key], key, obj, index);
        });
    };
};},
/* es5-ext/object/assign/index */ function(require, module, exports) {
'use strict';
module.exports = require(264    /* ./is-implemented */)() ? Object.assign : require(265    /* ./shim */);},
/* es5-ext/object/assign/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var assign = Object.assign, obj;
    if (typeof assign !== 'function')
        return false;
    obj = { foo: 'raz' };
    assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
    return obj.foo + obj.bar + obj.trzy === 'razdwatrzy';
};},
/* es5-ext/object/assign/shim */ function(require, module, exports) {
'use strict';
var keys = require(272    /* ../keys */), value = require(282    /* ../valid-value */), max = Math.max;
module.exports = function (dest, src) {
    var error, i, length = max(arguments.length, 2), assign;
    dest = Object(value(dest));
    assign = function (key) {
        try {
            dest[key] = src[key];
        } catch (e) {
            if (!error)
                error = e;
        }
    };
    for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
    }
    if (error !== undefined)
        throw error;
    return dest;
};},
/* es5-ext/object/copy */ function(require, module, exports) {
'use strict';
var aFrom = require(247    /* ../array/from */), assign = require(263    /* ./assign */), value = require(282    /* ./valid-value */);
module.exports = function (obj) {
    var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
    if (copy !== obj && !propertyNames)
        return copy;
    var result = {};
    if (propertyNames) {
        aFrom(propertyNames, function (propertyName) {
            if (options.ensure || propertyName in obj)
                result[propertyName] = obj[propertyName];
        });
    } else {
        assign(result, obj);
    }
    return result;
};},
/* es5-ext/object/create */ function(require, module, exports) {
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804
'use strict';
var create = Object.create, shim;
if (!require(278    /* ./set-prototype-of/is-implemented */)()) {
    shim = require(279    /* ./set-prototype-of/shim */);
}
module.exports = function () {
    var nullObject, polyProps, desc;
    if (!shim)
        return create;
    if (shim.level !== 1)
        return create;
    nullObject = {};
    polyProps = {};
    desc = {
        configurable: false,
        enumerable: false,
        writable: true,
        value: undefined
    };
    Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
        if (name === '__proto__') {
            polyProps[name] = {
                configurable: true,
                enumerable: false,
                writable: true,
                value: undefined
            };
            return;
        }
        polyProps[name] = desc;
    });
    Object.defineProperties(nullObject, polyProps);
    Object.defineProperty(shim, 'nullPolyfill', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: nullObject
    });
    return function (prototype, props) {
        return create(prototype === null ? nullObject : prototype, props);
    };
}();},
/* es5-ext/object/for-each */ function(require, module, exports) {
'use strict';
module.exports = require(262    /* ./_iterate */)('forEach');},
/* es5-ext/object/is-callable */ function(require, module, exports) {
// Deprecated
'use strict';
module.exports = function (obj) {
    return typeof obj === 'function';
};},
/* es5-ext/object/is-object */ function(require, module, exports) {
'use strict';
var isValue = require(271    /* ./is-value */);
var map = {
    function: true,
    object: true
};
module.exports = function (value) {
    return isValue(value) && map[typeof value] || false;
};},
/* es5-ext/object/is-value */ function(require, module, exports) {
'use strict';
var _undefined = require(252    /* ../function/noop */)();
// Support ES3 engines
module.exports = function (val) {
    return val !== _undefined && val !== null;
};},
/* es5-ext/object/keys/index */ function(require, module, exports) {
'use strict';
module.exports = require(273    /* ./is-implemented */)() ? Object.keys : require(274    /* ./shim */);},
/* es5-ext/object/keys/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    try {
        Object.keys('primitive');
        return true;
    } catch (e) {
        return false;
    }
};},
/* es5-ext/object/keys/shim */ function(require, module, exports) {
'use strict';
var isValue = require(271    /* ../is-value */);
var keys = Object.keys;
module.exports = function (object) {
    return keys(isValue(object) ? Object(object) : object);
};},
/* es5-ext/object/map */ function(require, module, exports) {
'use strict';
var callable = require(280    /* ./valid-callable */), forEach = require(268    /* ./for-each */), call = Function.prototype.call;
module.exports = function (obj, cb) {
    var result = {}, thisArg = arguments[2];
    callable(cb);
    forEach(obj, function (value, key, targetObj, index) {
        result[key] = call.call(cb, thisArg, value, key, targetObj, index);
    });
    return result;
};},
/* es5-ext/object/normalize-options */ function(require, module, exports) {
'use strict';
var isValue = require(271    /* ./is-value */);
var forEach = Array.prototype.forEach, create = Object.create;
var process = function (src, obj) {
    var key;
    for (key in src)
        obj[key] = src[key];
};
// eslint-disable-next-line no-unused-vars
module.exports = function (opts1) {
    var result = create(null);
    forEach.call(arguments, function (options) {
        if (!isValue(options))
            return;
        process(Object(options), result);
    });
    return result;
};},
/* es5-ext/object/set-prototype-of/index */ function(require, module, exports) {
'use strict';
module.exports = require(278    /* ./is-implemented */)() ? Object.setPrototypeOf : require(279    /* ./shim */);},
/* es5-ext/object/set-prototype-of/is-implemented */ function(require, module, exports) {
'use strict';
var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};
module.exports = function () {
    var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
    if (typeof setPrototypeOf !== 'function')
        return false;
    return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
};},
/* es5-ext/object/set-prototype-of/shim */ function(require, module, exports) {
/* eslint no-proto: "off" */
// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554
'use strict';
var isObject = require(270    /* ../is-object */), value = require(282    /* ../valid-value */), objIsPrototypOf = Object.prototype.isPrototypeOf, defineProperty = Object.defineProperty, nullDesc = {
        configurable: true,
        enumerable: false,
        writable: true,
        value: undefined
    }, validate;
validate = function (obj, prototype) {
    value(obj);
    if (prototype === null || isObject(prototype))
        return obj;
    throw new TypeError('Prototype must be null or an object');
};
module.exports = function (status) {
    var fn, set;
    if (!status)
        return null;
    if (status.level === 2) {
        if (status.set) {
            set = status.set;
            fn = function (obj, prototype) {
                set.call(validate(obj, prototype), prototype);
                return obj;
            };
        } else {
            fn = function (obj, prototype) {
                validate(obj, prototype).__proto__ = prototype;
                return obj;
            };
        }
    } else {
        fn = function self(obj, prototype) {
            var isNullBase;
            validate(obj, prototype);
            isNullBase = objIsPrototypOf.call(self.nullPolyfill, obj);
            if (isNullBase)
                delete self.nullPolyfill.__proto__;
            if (prototype === null)
                prototype = self.nullPolyfill;
            obj.__proto__ = prototype;
            if (isNullBase)
                defineProperty(self.nullPolyfill, '__proto__', nullDesc);
            return obj;
        };
    }
    return Object.defineProperty(fn, 'level', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: status.level
    });
}(function () {
    var tmpObj1 = Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
    if (desc) {
        try {
            set = desc.set;
            // Opera crashes at this point
            set.call(tmpObj1, tmpObj2);
        } catch (ignore) {
        }
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
            return {
                set: set,
                level: 2
            };
    }
    tmpObj1.__proto__ = tmpObj2;
    if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
        return { level: 2 };
    tmpObj1 = {};
    tmpObj1.__proto__ = tmpObj2;
    if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
        return { level: 1 };
    return false;
}());
require(267    /* ../create */);},
/* es5-ext/object/valid-callable */ function(require, module, exports) {
'use strict';
module.exports = function (fn) {
    if (typeof fn !== 'function')
        throw new TypeError(fn + ' is not a function');
    return fn;
};},
/* es5-ext/object/valid-object */ function(require, module, exports) {
'use strict';
var isObject = require(270    /* ./is-object */);
module.exports = function (value) {
    if (!isObject(value))
        throw new TypeError(value + ' is not an Object');
    return value;
};},
/* es5-ext/object/valid-value */ function(require, module, exports) {
'use strict';
var isValue = require(271    /* ./is-value */);
module.exports = function (value) {
    if (!isValue(value))
        throw new TypeError('Cannot use null or undefined');
    return value;
};},
/* es5-ext/string/#/contains/index */ function(require, module, exports) {
'use strict';
module.exports = require(284    /* ./is-implemented */)() ? String.prototype.contains : require(285    /* ./shim */);},
/* es5-ext/string/#/contains/is-implemented */ function(require, module, exports) {
'use strict';
var str = 'razdwatrzy';
module.exports = function () {
    if (typeof str.contains !== 'function')
        return false;
    return str.contains('dwa') === true && str.contains('foo') === false;
};},
/* es5-ext/string/#/contains/shim */ function(require, module, exports) {
'use strict';
var indexOf = String.prototype.indexOf;
module.exports = function (searchString) {
    return indexOf.call(this, searchString, arguments[1]) > -1;
};},
/* es5-ext/string/is-string */ function(require, module, exports) {
'use strict';
var objToString = Object.prototype.toString, id = objToString.call('');
module.exports = function (value) {
    return typeof value === 'string' || value && typeof value === 'object' && (value instanceof String || objToString.call(value) === id) || false;
};},
/* es5-ext/string/random-uniq */ function(require, module, exports) {
'use strict';
var generated = Object.create(null), random = Math.random;
module.exports = function () {
    var str;
    do {
        str = random().toString(36).slice(2);
    } while (generated[str]);
    return str;
};},
/* es6-iterator/array */ function(require, module, exports) {
'use strict';
var setPrototypeOf = require(277    /* es5-ext/object/set-prototype-of */), contains = require(283    /* es5-ext/string/#/contains */), d = require(244    /* d */), Iterator = require(291    /* ./ */), defineProperty = Object.defineProperty, ArrayIterator;
ArrayIterator = module.exports = function (arr, kind) {
    if (!(this instanceof ArrayIterator))
        return new ArrayIterator(arr, kind);
    Iterator.call(this, arr);
    if (!kind)
        kind = 'value';
    else if (contains.call(kind, 'key+value'))
        kind = 'key+value';
    else if (contains.call(kind, 'key'))
        kind = 'key';
    else
        kind = 'value';
    defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf)
    setPrototypeOf(ArrayIterator, Iterator);
ArrayIterator.prototype = Object.create(Iterator.prototype, {
    constructor: d(ArrayIterator),
    _resolve: d(function (i) {
        if (this.__kind__ === 'value')
            return this.__list__[i];
        if (this.__kind__ === 'key+value')
            return [
                i,
                this.__list__[i]
            ];
        return i;
    }),
    toString: d(function () {
        return '[object Array Iterator]';
    })
});},
/* es6-iterator/for-of */ function(require, module, exports) {
'use strict';
var isArguments = require(250    /* es5-ext/function/is-arguments */), callable = require(280    /* es5-ext/object/valid-callable */), isString = require(286    /* es5-ext/string/is-string */), get = require(290    /* ./get */), isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;
module.exports = function (iterable, cb) {
    var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
    if (isArray(iterable) || isArguments(iterable))
        mode = 'array';
    else if (isString(iterable))
        mode = 'string';
    else
        iterable = get(iterable);
    callable(cb);
    doBreak = function () {
        broken = true;
    };
    if (mode === 'array') {
        some.call(iterable, function (value) {
            call.call(cb, thisArg, value, doBreak);
            if (broken)
                return true;
        });
        return;
    }
    if (mode === 'string') {
        l = iterable.length;
        for (i = 0; i < l; ++i) {
            char = iterable[i];
            if (i + 1 < l) {
                code = char.charCodeAt(0);
                if (code >= 55296 && code <= 56319)
                    char += iterable[++i];
            }
            call.call(cb, thisArg, char, doBreak);
            if (broken)
                break;
        }
        return;
    }
    result = iterable.next();
    while (!result.done) {
        call.call(cb, thisArg, result.value, doBreak);
        if (broken)
            return;
        result = iterable.next();
    }
};},
/* es6-iterator/get */ function(require, module, exports) {
'use strict';
var isArguments = require(250    /* es5-ext/function/is-arguments */), isString = require(286    /* es5-ext/string/is-string */), ArrayIterator = require(288    /* ./array */), StringIterator = require(293    /* ./string */), iterable = require(294    /* ./valid-iterable */), iteratorSymbol = require(301    /* es6-symbol */).iterator;
module.exports = function (obj) {
    if (typeof iterable(obj)[iteratorSymbol] === 'function')
        return obj[iteratorSymbol]();
    if (isArguments(obj))
        return new ArrayIterator(obj);
    if (isString(obj))
        return new StringIterator(obj);
    return new ArrayIterator(obj);
};},
/* es6-iterator/index */ function(require, module, exports) {
'use strict';
var clear = require(245    /* es5-ext/array/#/clear */), assign = require(263    /* es5-ext/object/assign */), callable = require(280    /* es5-ext/object/valid-callable */), value = require(282    /* es5-ext/object/valid-value */), d = require(244    /* d */), autoBind = require(243    /* d/auto-bind */), Symbol = require(301    /* es6-symbol */), defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
module.exports = Iterator = function (list, context) {
    if (!(this instanceof Iterator))
        return new Iterator(list, context);
    defineProperties(this, {
        __list__: d('w', value(list)),
        __context__: d('w', context),
        __nextIndex__: d('w', 0)
    });
    if (!context)
        return;
    callable(context.on);
    context.on('_add', this._onAdd);
    context.on('_delete', this._onDelete);
    context.on('_clear', this._onClear);
};
defineProperties(Iterator.prototype, assign({
    constructor: d(Iterator),
    _next: d(function () {
        var i;
        if (!this.__list__)
            return;
        if (this.__redo__) {
            i = this.__redo__.shift();
            if (i !== undefined)
                return i;
        }
        if (this.__nextIndex__ < this.__list__.length)
            return this.__nextIndex__++;
        this._unBind();
    }),
    next: d(function () {
        return this._createResult(this._next());
    }),
    _createResult: d(function (i) {
        if (i === undefined)
            return {
                done: true,
                value: undefined
            };
        return {
            done: false,
            value: this._resolve(i)
        };
    }),
    _resolve: d(function (i) {
        return this.__list__[i];
    }),
    _unBind: d(function () {
        this.__list__ = null;
        delete this.__redo__;
        if (!this.__context__)
            return;
        this.__context__.off('_add', this._onAdd);
        this.__context__.off('_delete', this._onDelete);
        this.__context__.off('_clear', this._onClear);
        this.__context__ = null;
    }),
    toString: d(function () {
        return '[object Iterator]';
    })
}, autoBind({
    _onAdd: d(function (index) {
        if (index >= this.__nextIndex__)
            return;
        ++this.__nextIndex__;
        if (!this.__redo__) {
            defineProperty(this, '__redo__', d('c', [index]));
            return;
        }
        this.__redo__.forEach(function (redo, i) {
            if (redo >= index)
                this.__redo__[i] = ++redo;
        }, this);
        this.__redo__.push(index);
    }),
    _onDelete: d(function (index) {
        var i;
        if (index >= this.__nextIndex__)
            return;
        --this.__nextIndex__;
        if (!this.__redo__)
            return;
        i = this.__redo__.indexOf(index);
        if (i !== -1)
            this.__redo__.splice(i, 1);
        this.__redo__.forEach(function (redo, i) {
            if (redo > index)
                this.__redo__[i] = --redo;
        }, this);
    }),
    _onClear: d(function () {
        if (this.__redo__)
            clear.call(this.__redo__);
        this.__nextIndex__ = 0;
    })
})));
defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
    return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));},
/* es6-iterator/is-iterable */ function(require, module, exports) {
'use strict';
var isArguments = require(250    /* es5-ext/function/is-arguments */), isString = require(286    /* es5-ext/string/is-string */), iteratorSymbol = require(301    /* es6-symbol */).iterator, isArray = Array.isArray;
module.exports = function (value) {
    if (value == null)
        return false;
    if (isArray(value))
        return true;
    if (isString(value))
        return true;
    if (isArguments(value))
        return true;
    return typeof value[iteratorSymbol] === 'function';
};},
/* es6-iterator/string */ function(require, module, exports) {
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols
'use strict';
var setPrototypeOf = require(277    /* es5-ext/object/set-prototype-of */), d = require(244    /* d */), Iterator = require(291    /* ./ */), defineProperty = Object.defineProperty, StringIterator;
StringIterator = module.exports = function (str) {
    if (!(this instanceof StringIterator))
        return new StringIterator(str);
    str = String(str);
    Iterator.call(this, str);
    defineProperty(this, '__length__', d('', str.length));
};
if (setPrototypeOf)
    setPrototypeOf(StringIterator, Iterator);
StringIterator.prototype = Object.create(Iterator.prototype, {
    constructor: d(StringIterator),
    _next: d(function () {
        if (!this.__list__)
            return;
        if (this.__nextIndex__ < this.__length__)
            return this.__nextIndex__++;
        this._unBind();
    }),
    _resolve: d(function (i) {
        var char = this.__list__[i], code;
        if (this.__nextIndex__ === this.__length__)
            return char;
        code = char.charCodeAt(0);
        if (code >= 55296 && code <= 56319)
            return char + this.__list__[this.__nextIndex__++];
        return char;
    }),
    toString: d(function () {
        return '[object String Iterator]';
    })
});},
/* es6-iterator/valid-iterable */ function(require, module, exports) {
'use strict';
var isIterable = require(292    /* ./is-iterable */);
module.exports = function (value) {
    if (!isIterable(value))
        throw new TypeError(value + ' is not iterable');
    return value;
};},
/* es6-promise/dist/es6-promise */ function(require, module, exports) {
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */
(function () {
    'use strict';
    function lib$es6$promise$utils$$objectOrFunction(x) {
        return typeof x === 'function' || typeof x === 'object' && x !== null;
    }
    function lib$es6$promise$utils$$isFunction(x) {
        return typeof x === 'function';
    }
    function lib$es6$promise$utils$$isMaybeThenable(x) {
        return typeof x === 'object' && x !== null;
    }
    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
        lib$es6$promise$utils$$_isArray = function (x) {
            return Object.prototype.toString.call(x) === '[object Array]';
        };
    } else {
        lib$es6$promise$utils$$_isArray = Array.isArray;
    }
    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;
    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
        lib$es6$promise$asap$$len += 2;
        if (lib$es6$promise$asap$$len === 2) {
            // If len is 2, that means that we need to schedule an async flush.
            // If additional callbacks are queued before the queue is flushed, they
            // will be processed by this flush that we are scheduling.
            if (lib$es6$promise$asap$$customSchedulerFn) {
                lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
            } else {
                lib$es6$promise$asap$$scheduleFlush();
            }
        }
    };
    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
        lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }
    function lib$es6$promise$asap$$setAsap(asapFn) {
        lib$es6$promise$asap$$asap = asapFn;
    }
    var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
    // node
    function lib$es6$promise$asap$$useNextTick() {
        // node version 0.10.x displays a deprecation warning when nextTick is used recursively
        // see https://github.com/cujojs/when/issues/410 for details
        return function () {
            process.nextTick(lib$es6$promise$asap$$flush);
        };
    }
    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
        return function () {
            lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
        };
    }
    function lib$es6$promise$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });
        return function () {
            node.data = iterations = ++iterations % 2;
        };
    }
    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = lib$es6$promise$asap$$flush;
        return function () {
            channel.port2.postMessage(0);
        };
    }
    function lib$es6$promise$asap$$useSetTimeout() {
        return function () {
            setTimeout(lib$es6$promise$asap$$flush, 1);
        };
    }
    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
        for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
            var callback = lib$es6$promise$asap$$queue[i];
            var arg = lib$es6$promise$asap$$queue[i + 1];
            callback(arg);
            lib$es6$promise$asap$$queue[i] = undefined;
            lib$es6$promise$asap$$queue[i + 1] = undefined;
        }
        lib$es6$promise$asap$$len = 0;
    }
    function lib$es6$promise$asap$$attemptVertx() {
        try {
            var r = require;
            var vertx = r('vertx');
            lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
            return lib$es6$promise$asap$$useVertxTimer();
        } catch (e) {
            return lib$es6$promise$asap$$useSetTimeout();
        }
    }
    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$$internal$$noop() {
    }
    var lib$es6$promise$$internal$$PENDING = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED = 2;
    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
    function lib$es6$promise$$internal$$selfFulfillment() {
        return new TypeError('You cannot resolve a promise with itself');
    }
    function lib$es6$promise$$internal$$cannotReturnOwn() {
        return new TypeError('A promises callback cannot return that same promise.');
    }
    function lib$es6$promise$$internal$$getThen(promise) {
        try {
            return promise.then;
        } catch (error) {
            lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
            return lib$es6$promise$$internal$$GET_THEN_ERROR;
        }
    }
    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
        try {
            then.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
            return e;
        }
    }
    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
        lib$es6$promise$asap$$asap(function (promise) {
            var sealed = false;
            var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {
                if (sealed) {
                    return;
                }
                sealed = true;
                if (thenable !== value) {
                    lib$es6$promise$$internal$$resolve(promise, value);
                } else {
                    lib$es6$promise$$internal$$fulfill(promise, value);
                }
            }, function (reason) {
                if (sealed) {
                    return;
                }
                sealed = true;
                lib$es6$promise$$internal$$reject(promise, reason);
            }, 'Settle: ' + (promise._label || ' unknown promise'));
            if (!sealed && error) {
                sealed = true;
                lib$es6$promise$$internal$$reject(promise, error);
            }
        }, promise);
    }
    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
            lib$es6$promise$$internal$$fulfill(promise, thenable._result);
        } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
            lib$es6$promise$$internal$$reject(promise, thenable._result);
        } else {
            lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {
                lib$es6$promise$$internal$$resolve(promise, value);
            }, function (reason) {
                lib$es6$promise$$internal$$reject(promise, reason);
            });
        }
    }
    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
        if (maybeThenable.constructor === promise.constructor) {
            lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
        } else {
            var then = lib$es6$promise$$internal$$getThen(maybeThenable);
            if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
                lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
            } else if (then === undefined) {
                lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
            } else if (lib$es6$promise$utils$$isFunction(then)) {
                lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
            } else {
                lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
            }
        }
    }
    function lib$es6$promise$$internal$$resolve(promise, value) {
        if (promise === value) {
            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
        } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
            lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
        } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
        }
    }
    function lib$es6$promise$$internal$$publishRejection(promise) {
        if (promise._onerror) {
            promise._onerror(promise._result);
        }
        lib$es6$promise$$internal$$publish(promise);
    }
    function lib$es6$promise$$internal$$fulfill(promise, value) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
            return;
        }
        promise._result = value;
        promise._state = lib$es6$promise$$internal$$FULFILLED;
        if (promise._subscribers.length !== 0) {
            lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
        }
    }
    function lib$es6$promise$$internal$$reject(promise, reason) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
            return;
        }
        promise._state = lib$es6$promise$$internal$$REJECTED;
        promise._result = reason;
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }
    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;
        parent._onerror = null;
        subscribers[length] = child;
        subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;
        if (length === 0 && parent._state) {
            lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
        }
    }
    function lib$es6$promise$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
            return;
        }
        var child, callback, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
            child = subscribers[i];
            callback = subscribers[i + settled];
            if (child) {
                lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
            } else {
                callback(detail);
            }
        }
        promise._subscribers.length = 0;
    }
    function lib$es6$promise$$internal$$ErrorObject() {
        this.error = null;
    }
    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
        try {
            return callback(detail);
        } catch (e) {
            lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
            return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
        }
    }
    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = lib$es6$promise$utils$$isFunction(callback), value, error, succeeded, failed;
        if (hasCallback) {
            value = lib$es6$promise$$internal$$tryCatch(callback, detail);
            if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
                failed = true;
                error = value.error;
                value = null;
            } else {
                succeeded = true;
            }
            if (promise === value) {
                lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
                return;
            }
        } else {
            value = detail;
            succeeded = true;
        }
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        } else if (hasCallback && succeeded) {
            lib$es6$promise$$internal$$resolve(promise, value);
        } else if (failed) {
            lib$es6$promise$$internal$$reject(promise, error);
        } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
            lib$es6$promise$$internal$$fulfill(promise, value);
        } else if (settled === lib$es6$promise$$internal$$REJECTED) {
            lib$es6$promise$$internal$$reject(promise, value);
        }
    }
    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
        try {
            resolver(function resolvePromise(value) {
                lib$es6$promise$$internal$$resolve(promise, value);
            }, function rejectPromise(reason) {
                lib$es6$promise$$internal$$reject(promise, reason);
            });
        } catch (e) {
            lib$es6$promise$$internal$$reject(promise, e);
        }
    }
    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
        var enumerator = this;
        enumerator._instanceConstructor = Constructor;
        enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);
        if (enumerator._validateInput(input)) {
            enumerator._input = input;
            enumerator.length = input.length;
            enumerator._remaining = input.length;
            enumerator._init();
            if (enumerator.length === 0) {
                lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
            } else {
                enumerator.length = enumerator.length || 0;
                enumerator._enumerate();
                if (enumerator._remaining === 0) {
                    lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
                }
            }
        } else {
            lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
        }
    }
    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function (input) {
        return lib$es6$promise$utils$$isArray(input);
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {
        return new Error('Array Methods must be provided an Array');
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._init = function () {
        this._result = new Array(this.length);
    };
    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {
        var enumerator = this;
        var length = enumerator.length;
        var promise = enumerator.promise;
        var input = enumerator._input;
        for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
            enumerator._eachEntry(input[i], i);
        }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {
        var enumerator = this;
        var c = enumerator._instanceConstructor;
        if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
            if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
                entry._onerror = null;
                enumerator._settledAt(entry._state, i, entry._result);
            } else {
                enumerator._willSettleAt(c.resolve(entry), i);
            }
        } else {
            enumerator._remaining--;
            enumerator._result[i] = entry;
        }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {
        var enumerator = this;
        var promise = enumerator.promise;
        if (promise._state === lib$es6$promise$$internal$$PENDING) {
            enumerator._remaining--;
            if (state === lib$es6$promise$$internal$$REJECTED) {
                lib$es6$promise$$internal$$reject(promise, value);
            } else {
                enumerator._result[i] = value;
            }
        }
        if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
        }
    };
    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {
        var enumerator = this;
        lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {
            enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
        }, function (reason) {
            enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
        });
    };
    function lib$es6$promise$promise$all$$all(entries) {
        return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
        /*jshint validthis:true */
        var Constructor = this;
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        if (!lib$es6$promise$utils$$isArray(entries)) {
            lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
            return promise;
        }
        var length = entries.length;
        function onFulfillment(value) {
            lib$es6$promise$$internal$$resolve(promise, value);
        }
        function onRejection(reason) {
            lib$es6$promise$$internal$$reject(promise, reason);
        }
        for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
            lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
        }
        return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
        /*jshint validthis:true */
        var Constructor = this;
        if (object && typeof object === 'object' && object.constructor === Constructor) {
            return object;
        }
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$resolve(promise, object);
        return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
        /*jshint validthis:true */
        var Constructor = this;
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$reject(promise, reason);
        return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
    var lib$es6$promise$promise$$counter = 0;
    function lib$es6$promise$promise$$needsResolver() {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }
    function lib$es6$promise$promise$$needsNew() {
        throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    }
    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
        this._id = lib$es6$promise$promise$$counter++;
        this._state = undefined;
        this._result = undefined;
        this._subscribers = [];
        if (lib$es6$promise$$internal$$noop !== resolver) {
            if (!lib$es6$promise$utils$$isFunction(resolver)) {
                lib$es6$promise$promise$$needsResolver();
            }
            if (!(this instanceof lib$es6$promise$promise$$Promise)) {
                lib$es6$promise$promise$$needsNew();
            }
            lib$es6$promise$$internal$$initializePromise(this, resolver);
        }
    }
    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
    lib$es6$promise$promise$$Promise.prototype = {
        constructor: lib$es6$promise$promise$$Promise,
        /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
        then: function (onFulfillment, onRejection) {
            var parent = this;
            var state = parent._state;
            if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
                return this;
            }
            var child = new this.constructor(lib$es6$promise$$internal$$noop);
            var result = parent._result;
            if (state) {
                var callback = arguments[state - 1];
                lib$es6$promise$asap$$asap(function () {
                    lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
                });
            } else {
                lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
            }
            return child;
        },
        /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
        'catch': function (onRejection) {
            return this.then(null, onRejection);
        }
    };
    function lib$es6$promise$polyfill$$polyfill() {
        var local;
        if (typeof global !== 'undefined') {
            local = global;
        } else if (typeof self !== 'undefined') {
            local = self;
        } else {
            try {
                local = Function('return this')();
            } catch (e) {
                throw new Error('polyfill failed because global object is unavailable in this environment');
            }
        }
        var P = local.Promise;
        if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
            return;
        }
        local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
    var lib$es6$promise$umd$$ES6Promise = {
        'Promise': lib$es6$promise$promise$$default,
        'polyfill': lib$es6$promise$polyfill$$default
    };
    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
        define(function () {
            return lib$es6$promise$umd$$ES6Promise;
        });
    } else if (typeof module !== 'undefined' && module['exports']) {
        module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
        this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }
    lib$es6$promise$polyfill$$default();
}.call(this));},
/* es6-set/implement */ function(require, module, exports) {
'use strict';
if (!require(297    /* ./is-implemented */)()) {
    Object.defineProperty(require(253    /* es5-ext/global */), 'Set', {
        value: require(300    /* ./polyfill */),
        configurable: true,
        enumerable: false,
        writable: true
    });
}},
/* es6-set/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var set, iterator, result;
    if (typeof Set !== 'function')
        return false;
    set = new Set([
        'raz',
        'dwa',
        'trzy'
    ]);
    if (String(set) !== '[object Set]')
        return false;
    if (set.size !== 3)
        return false;
    if (typeof set.add !== 'function')
        return false;
    if (typeof set.clear !== 'function')
        return false;
    if (typeof set.delete !== 'function')
        return false;
    if (typeof set.entries !== 'function')
        return false;
    if (typeof set.forEach !== 'function')
        return false;
    if (typeof set.has !== 'function')
        return false;
    if (typeof set.keys !== 'function')
        return false;
    if (typeof set.values !== 'function')
        return false;
    iterator = set.values();
    result = iterator.next();
    if (result.done !== false)
        return false;
    if (result.value !== 'raz')
        return false;
    return true;
};},
/* es6-set/is-native-implemented */ function(require, module, exports) {
// Exports true if environment provides native `Set` implementation,
// whatever that is.
'use strict';
module.exports = function () {
    if (typeof Set === 'undefined')
        return false;
    return Object.prototype.toString.call(Set.prototype) === '[object Set]';
}();},
/* es6-set/lib/iterator */ function(require, module, exports) {
'use strict';
var setPrototypeOf = require(277    /* es5-ext/object/set-prototype-of */), contains = require(283    /* es5-ext/string/#/contains */), d = require(244    /* d */), Iterator = require(291    /* es6-iterator */), toStringTagSymbol = require(301    /* es6-symbol */).toStringTag, defineProperty = Object.defineProperty, SetIterator;
SetIterator = module.exports = function (set, kind) {
    if (!(this instanceof SetIterator))
        return new SetIterator(set, kind);
    Iterator.call(this, set.__setData__, set);
    if (!kind)
        kind = 'value';
    else if (contains.call(kind, 'key+value'))
        kind = 'key+value';
    else
        kind = 'value';
    defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf)
    setPrototypeOf(SetIterator, Iterator);
SetIterator.prototype = Object.create(Iterator.prototype, {
    constructor: d(SetIterator),
    _resolve: d(function (i) {
        if (this.__kind__ === 'value')
            return this.__list__[i];
        return [
            this.__list__[i],
            this.__list__[i]
        ];
    }),
    toString: d(function () {
        return '[object Set Iterator]';
    })
});
defineProperty(SetIterator.prototype, toStringTagSymbol, d('c', 'Set Iterator'));},
/* es6-set/polyfill */ function(require, module, exports) {
'use strict';
var clear = require(245    /* es5-ext/array/#/clear */), eIndexOf = require(246    /* es5-ext/array/#/e-index-of */), setPrototypeOf = require(277    /* es5-ext/object/set-prototype-of */), callable = require(280    /* es5-ext/object/valid-callable */), d = require(244    /* d */), ee = require(310    /* event-emitter */), Symbol = require(301    /* es6-symbol */), iterator = require(294    /* es6-iterator/valid-iterable */), forOf = require(289    /* es6-iterator/for-of */), Iterator = require(299    /* ./lib/iterator */), isNative = require(298    /* ./is-native-implemented */), call = Function.prototype.call, defineProperty = Object.defineProperty, getPrototypeOf = Object.getPrototypeOf, SetPoly, getValues, NativeSet;
if (isNative)
    NativeSet = Set;
module.exports = SetPoly = function Set() {
    var iterable = arguments[0], self;
    if (!(this instanceof SetPoly))
        throw new TypeError('Constructor requires \'new\'');
    if (isNative && setPrototypeOf)
        self = setPrototypeOf(new NativeSet(), getPrototypeOf(this));
    else
        self = this;
    if (iterable != null)
        iterator(iterable);
    defineProperty(self, '__setData__', d('c', []));
    if (!iterable)
        return self;
    forOf(iterable, function (value) {
        if (eIndexOf.call(this, value) !== -1)
            return;
        this.push(value);
    }, self.__setData__);
    return self;
};
if (isNative) {
    if (setPrototypeOf)
        setPrototypeOf(SetPoly, NativeSet);
    SetPoly.prototype = Object.create(NativeSet.prototype, { constructor: d(SetPoly) });
}
ee(Object.defineProperties(SetPoly.prototype, {
    add: d(function (value) {
        if (this.has(value))
            return this;
        this.emit('_add', this.__setData__.push(value) - 1, value);
        return this;
    }),
    clear: d(function () {
        if (!this.__setData__.length)
            return;
        clear.call(this.__setData__);
        this.emit('_clear');
    }),
    delete: d(function (value) {
        var index = eIndexOf.call(this.__setData__, value);
        if (index === -1)
            return false;
        this.__setData__.splice(index, 1);
        this.emit('_delete', index, value);
        return true;
    }),
    entries: d(function () {
        return new Iterator(this, 'key+value');
    }),
    forEach: d(function (cb) {
        var thisArg = arguments[1], iterator, result, value;
        callable(cb);
        iterator = this.values();
        result = iterator._next();
        while (result !== undefined) {
            value = iterator._resolve(result);
            call.call(cb, thisArg, value, value, this);
            result = iterator._next();
        }
    }),
    has: d(function (value) {
        return eIndexOf.call(this.__setData__, value) !== -1;
    }),
    keys: d(getValues = function () {
        return this.values();
    }),
    size: d.gs(function () {
        return this.__setData__.length;
    }),
    values: d(function () {
        return new Iterator(this);
    }),
    toString: d(function () {
        return '[object Set]';
    })
}));
defineProperty(SetPoly.prototype, Symbol.iterator, d(getValues));
defineProperty(SetPoly.prototype, Symbol.toStringTag, d('c', 'Set'));},
/* es6-symbol/index */ function(require, module, exports) {
'use strict';
module.exports = require(302    /* ./is-implemented */)() ? Symbol : require(304    /* ./polyfill */);},
/* es6-symbol/is-implemented */ function(require, module, exports) {
'use strict';
var validTypes = {
    object: true,
    symbol: true
};
module.exports = function () {
    var symbol;
    if (typeof Symbol !== 'function')
        return false;
    symbol = Symbol('test symbol');
    try {
        String(symbol);
    } catch (e) {
        return false;
    }
    // Return 'true' also for polyfills
    if (!validTypes[typeof Symbol.iterator])
        return false;
    if (!validTypes[typeof Symbol.toPrimitive])
        return false;
    if (!validTypes[typeof Symbol.toStringTag])
        return false;
    return true;
};},
/* es6-symbol/is-symbol */ function(require, module, exports) {
'use strict';
module.exports = function (x) {
    if (!x)
        return false;
    if (typeof x === 'symbol')
        return true;
    if (!x.constructor)
        return false;
    if (x.constructor.name !== 'Symbol')
        return false;
    return x[x.constructor.toStringTag] === 'Symbol';
};},
/* es6-symbol/polyfill */ function(require, module, exports) {
// ES2015 Symbol polyfill for environments that do not (or partially) support it
'use strict';
var d = require(244    /* d */), validateSymbol = require(305    /* ./validate-symbol */), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null), isNativeSafe;
if (typeof Symbol === 'function') {
    NativeSymbol = Symbol;
    try {
        String(NativeSymbol());
        isNativeSafe = true;
    } catch (ignore) {
    }
}
var generateName = function () {
    var created = create(null);
    return function (desc) {
        var postfix = 0, name, ie11BugWorkaround;
        while (created[desc + (postfix || '')])
            ++postfix;
        desc += postfix || '';
        created[desc] = true;
        name = '@@' + desc;
        defineProperty(objPrototype, name, d.gs(null, function (value) {
            // For IE11 issue see:
            // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
            //    ie11-broken-getters-on-dom-objects
            // https://github.com/medikoo/es6-symbol/issues/12
            if (ie11BugWorkaround)
                return;
            ie11BugWorkaround = true;
            defineProperty(this, name, d(value));
            ie11BugWorkaround = false;
        }));
        return name;
    };
}();
// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
    if (this instanceof HiddenSymbol)
        throw new TypeError('Symbol is not a constructor');
    return SymbolPolyfill(description);
};
// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
    var symbol;
    if (this instanceof Symbol)
        throw new TypeError('Symbol is not a constructor');
    if (isNativeSafe)
        return NativeSymbol(description);
    symbol = create(HiddenSymbol.prototype);
    description = description === undefined ? '' : String(description);
    return defineProperties(symbol, {
        __description__: d('', description),
        __name__: d('', generateName(description))
    });
};
defineProperties(SymbolPolyfill, {
    for: d(function (key) {
        if (globalSymbols[key])
            return globalSymbols[key];
        return globalSymbols[key] = SymbolPolyfill(String(key));
    }),
    keyFor: d(function (s) {
        var key;
        validateSymbol(s);
        for (key in globalSymbols)
            if (globalSymbols[key] === s)
                return key;
    }),
    // To ensure proper interoperability with other native functions (e.g. Array.from)
    // fallback to eventual native implementation of given symbol
    hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),
    isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),
    iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),
    match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),
    replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),
    search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),
    species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),
    split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),
    toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),
    toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),
    unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))
});
// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
    constructor: d(SymbolPolyfill),
    toString: d('', function () {
        return this.__name__;
    })
});
// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
    toString: d(function () {
        return 'Symbol (' + validateSymbol(this).__description__ + ')';
    }),
    valueOf: d(function () {
        return validateSymbol(this);
    })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
    var symbol = validateSymbol(this);
    if (typeof symbol === 'symbol')
        return symbol;
    return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));},
/* es6-symbol/validate-symbol */ function(require, module, exports) {
'use strict';
var isSymbol = require(303    /* ./is-symbol */);
module.exports = function (value) {
    if (!isSymbol(value))
        throw new TypeError(value + ' is not a symbol');
    return value;
};},
/* es6-weak-map/implement */ function(require, module, exports) {
'use strict';
if (!require(307    /* ./is-implemented */)()) {
    Object.defineProperty(require(253    /* es5-ext/global */), 'WeakMap', {
        value: require(309    /* ./polyfill */),
        configurable: true,
        enumerable: false,
        writable: true
    });
}},
/* es6-weak-map/is-implemented */ function(require, module, exports) {
'use strict';
module.exports = function () {
    var weakMap, x;
    if (typeof WeakMap !== 'function')
        return false;
    try {
        // WebKit doesn't support arguments and crashes
        weakMap = new WeakMap([
            [
                x = {},
                'one'
            ],
            [
                {},
                'two'
            ],
            [
                {},
                'three'
            ]
        ]);
    } catch (e) {
        return false;
    }
    if (String(weakMap) !== '[object WeakMap]')
        return false;
    if (typeof weakMap.set !== 'function')
        return false;
    if (weakMap.set({}, 1) !== weakMap)
        return false;
    if (typeof weakMap.delete !== 'function')
        return false;
    if (typeof weakMap.has !== 'function')
        return false;
    if (weakMap.get(x) !== 'one')
        return false;
    return true;
};},
/* es6-weak-map/is-native-implemented */ function(require, module, exports) {
// Exports true if environment provides native `WeakMap` implementation, whatever that is.
'use strict';
module.exports = function () {
    if (typeof WeakMap !== 'function')
        return false;
    return Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]';
}();},
/* es6-weak-map/polyfill */ function(require, module, exports) {
'use strict';
var setPrototypeOf = require(277    /* es5-ext/object/set-prototype-of */), object = require(281    /* es5-ext/object/valid-object */), value = require(282    /* es5-ext/object/valid-value */), randomUniq = require(287    /* es5-ext/string/random-uniq */), d = require(244    /* d */), getIterator = require(290    /* es6-iterator/get */), forOf = require(289    /* es6-iterator/for-of */), toStringTagSymbol = require(301    /* es6-symbol */).toStringTag, isNative = require(308    /* ./is-native-implemented */), isArray = Array.isArray, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf, WeakMapPoly;
module.exports = WeakMapPoly = function () {
    var iterable = arguments[0], self;
    if (!(this instanceof WeakMapPoly))
        throw new TypeError('Constructor requires \'new\'');
    if (isNative && setPrototypeOf && WeakMap !== WeakMapPoly) {
        self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
    } else {
        self = this;
    }
    if (iterable != null) {
        if (!isArray(iterable))
            iterable = getIterator(iterable);
    }
    defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
    if (!iterable)
        return self;
    forOf(iterable, function (val) {
        value(val);
        self.set(val[0], val[1]);
    });
    return self;
};
if (isNative) {
    if (setPrototypeOf)
        setPrototypeOf(WeakMapPoly, WeakMap);
    WeakMapPoly.prototype = Object.create(WeakMap.prototype, { constructor: d(WeakMapPoly) });
}
Object.defineProperties(WeakMapPoly.prototype, {
    delete: d(function (key) {
        if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
            delete key[this.__weakMapData__];
            return true;
        }
        return false;
    }),
    get: d(function (key) {
        if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
            return key[this.__weakMapData__];
        }
    }),
    has: d(function (key) {
        return hasOwnProperty.call(object(key), this.__weakMapData__);
    }),
    set: d(function (key, value) {
        defineProperty(object(key), this.__weakMapData__, d('c', value));
        return this;
    }),
    toString: d(function () {
        return '[object WeakMap]';
    })
});
defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));},
/* event-emitter/index */ function(require, module, exports) {
'use strict';
var d = require(244    /* d */), callable = require(280    /* es5-ext/object/valid-callable */), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty = Object.prototype.hasOwnProperty, descriptor = {
        configurable: true,
        enumerable: false,
        writable: true
    }, on, once, off, emit, methods, descriptors, base;
on = function (type, listener) {
    var data;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__')) {
        data = descriptor.value = create(null);
        defineProperty(this, '__ee__', descriptor);
        descriptor.value = null;
    } else {
        data = this.__ee__;
    }
    if (!data[type])
        data[type] = listener;
    else if (typeof data[type] === 'object')
        data[type].push(listener);
    else
        data[type] = [
            data[type],
            listener
        ];
    return this;
};
once = function (type, listener) {
    var once, self;
    callable(listener);
    self = this;
    on.call(this, type, once = function () {
        off.call(self, type, once);
        apply.call(listener, this, arguments);
    });
    once.__eeOnceListener__ = listener;
    return this;
};
off = function (type, listener) {
    var data, listeners, candidate, i;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__'))
        return this;
    data = this.__ee__;
    if (!data[type])
        return this;
    listeners = data[type];
    if (typeof listeners === 'object') {
        for (i = 0; candidate = listeners[i]; ++i) {
            if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                if (listeners.length === 2)
                    data[type] = listeners[i ? 0 : 1];
                else
                    listeners.splice(i, 1);
            }
        }
    } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
            delete data[type];
        }
    }
    return this;
};
emit = function (type) {
    var i, l, listener, listeners, args;
    if (!hasOwnProperty.call(this, '__ee__'))
        return;
    listeners = this.__ee__[type];
    if (!listeners)
        return;
    if (typeof listeners === 'object') {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
            args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
            apply.call(listener, this, args);
        }
    } else {
        switch (arguments.length) {
        case 1:
            call.call(listeners, this);
            break;
        case 2:
            call.call(listeners, this, arguments[1]);
            break;
        case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
        default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
                args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
    }
};
methods = {
    on: on,
    once: once,
    off: off,
    emit: emit
};
descriptors = {
    on: d(on),
    once: d(once),
    off: d(off),
    emit: d(emit)
};
base = defineProperties({}, descriptors);
module.exports = exports = function (o) {
    return o == null ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;},
/* hammerjs/hammer */ function(require, module, exports) {
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
    'use strict';
    var VENDOR_PREFIXES = [
        '',
        'webkit',
        'Moz',
        'MS',
        'ms',
        'o'
    ];
    var TEST_ELEMENT = document.createElement('div');
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');
    /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');
    /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
    function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            assign(childP, properties);
        }
    }
    /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    /**
 * get a unique id
 * @returns {number} uniqueId
 */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = 'ontouchstart' in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        'x',
        'y'
    ];
    var PROPS_CLIENT_XY = [
        'clientX',
        'clientY'
    ];
    /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }
    Input.prototype = {
        /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
        handler: function () {
        },
        /**
     * bind the events
     */
        init: function () {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
     * unbind the events
     */
        destroy: function () {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
    /**
 * Mouse events input
 * @constructor
 * @extends Input
 */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        // mousedown state
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }
            // mouse must be down
            if (!this.pressed) {
                return;
            }
            if (eventType & INPUT_END) {
                this.pressed = false;
            }
            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT    // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }
    /**
 * Pointer events input
 * @constructor
 * @extends Input
 */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');
            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }
            // update the event in the store
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
 * Touch events input
 * @constructor
 * @extends Input
 */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }
            if (!this.started) {
                return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [
            all,
            changed
        ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }
    /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
        /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }
            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }
            this.callback(manager, inputEvent, inputData);
        },
        /**
     * remove the event listeners
     */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }
    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function () {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }
    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation';
    // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
        set: function (value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        /**
     * just re-set the touchAction value
     */
        update: function () {
            this.set(this.manager.options.touchAction);
        },
        /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
        compute: function () {
            var actions = [];
            each(this.manager.recognizers, function (recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },
        /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
        preventDefaults: function (input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                //do not prevent defaults if this is a tap gesture
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }
            if (hasPanX && hasPanY) {
                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                return this.preventSrc(srcEvent);
            }
        },
        /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
        preventSrc: function (srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        [
            'auto',
            'manipulation',
            'pan-y',
            'pan-x',
            'pan-x pan-y',
            'none'
        ].forEach(function (val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }
    /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
     * @virtual
     * @type {Object}
     */
        defaults: {},
        /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
        set: function (options) {
            assign(this.options, options);
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
        recognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
        dropRecognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
        requireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
        dropRequireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },
        /**
     * has require failures boolean
     * @returns {boolean}
     */
        hasRequireFailures: function () {
            return this.requireFail.length > 0;
        },
        /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
        canRecognizeWith: function (otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
        emit: function (input) {
            var self = this;
            var state = this.state;
            function emit(event) {
                self.manager.emit(event, input);
            }
            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
            emit(self.options.event);
            // simple 'eventName' events
            if (input.additionalEvent) {
                // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }
            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },
        /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
        tryEmit: function (input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
     * can we emit?
     * @returns {boolean}
     */
        canEmit: function () {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },
        /**
     * update the recognizer
     * @param {Object} inputData
     */
        recognize: function (inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);
            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [
                    this,
                    inputDataClone
                ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },
        /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
        process: function (inputData) {
        },
        // jshint ignore:line
        /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
        getTouchAction: function () {
        },
        /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
        reset: function () {
        }
    };
    /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof AttrRecognizer
     */
        defaults: {
            /**
         * @type {Number}
         * @default 1
         */
            pointers: 1
        },
        /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
        attrTest: function (input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
        process: function (input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PanRecognizer
     */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function () {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },
        directionTest: function (input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function (input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function (input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function (input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PressRecognizer
     */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251,
            // minimal time of the pointer to be pressed
            threshold: 9    // a minimal movement is ok, but keep it low
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_AUTO];
        },
        process: function (input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function () {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function () {
            clearTimeout(this._timer);
        },
        emit: function (input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }
            if (input && input.eventType & INPUT_END) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof RotateRecognizer
     */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof SwipeRecognizer
     */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function () {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function (input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function (input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
        }
    });
    /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300,
            // max time between the multi-tap taps
            time: 250,
            // max time of the pointer to be down (like finger on the screen)
            threshold: 9,
            // a minimal movement is ok, but keep it low
            posThreshold: 10    // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_MANIPULATION];
        },
        process: function (input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
                return this.failTimeout();
            }
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function () {
            this._timer = setTimeoutContext(function () {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function () {
            clearTimeout(this._timer);
        },
        emit: function () {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
 * @const {string}
 */
    Hammer.VERSION = '2.0.7';
    /**
 * default settings
 * @namespace
 */
    Hammer.defaults = {
        /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
        domEvents: false,
        /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
     * @type {Boolean}
     * @default true
     */
        enable: true,
        /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
        inputTarget: null,
        /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
        inputClass: null,
        /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [
                RotateRecognizer,
                { enable: false }
            ],
            [
                PinchRecognizer,
                { enable: false },
                ['rotate']
            ],
            [
                SwipeRecognizer,
                { direction: DIRECTION_HORIZONTAL }
            ],
            [
                PanRecognizer,
                { direction: DIRECTION_HORIZONTAL },
                ['swipe']
            ],
            [TapRecognizer],
            [
                TapRecognizer,
                {
                    event: 'doubletap',
                    taps: 2
                },
                ['tap']
            ],
            [PressRecognizer]
        ],
        /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
        cssProps: {
            /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
            userSelect: 'none',
            /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
            touchSelect: 'none',
            /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
            touchCallout: 'none',
            /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
            contentZooming: 'none',
            /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
            userDrag: 'none',
            /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
        set: function (options) {
            assign(this.options, options);
            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
        stop: function (force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
        recognize: function (inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }
            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && // 1
                    (!curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) {
                    // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
        get: function (recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },
        /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
        add: function (recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }
            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
        remove: function (recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }
            recognizer = this.get(recognizer);
            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }
            return this;
        },
        /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
        on: function (events, handler) {
            if (events === undefined) {
                return;
            }
            if (handler === undefined) {
                return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
        off: function (events, handler) {
            if (events === undefined) {
                return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },
        /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
        emit: function (event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }
            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }
            data.type = event;
            data.preventDefault = function () {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },
        /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
        destroy: function () {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function (value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }
    /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {};
    // jshint ignore:line
    freeGlobal.Hammer = Hammer;
    if (typeof define === 'function' && define.amd) {
        define(function () {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }
}(window, document, 'Hammer'));},
/* kiwi/build/constraint */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var strength_1 = require(317    /* ./strength */);
/**
 * An enum defining the linear constraint operators.
 */
var Operator;
(function (Operator) {
    Operator[Operator['Le'] = 0] = 'Le';
    Operator[Operator['Ge'] = 1] = 'Ge';
    Operator[Operator['Eq'] = 2] = 'Eq';    // ==
}(Operator = exports.Operator || (exports.Operator = {})));
/**
 * A linear constraint equation.
 *
 * A constraint equation is composed of an expression, an operator,
 * and a strength. The RHS of the equation is implicitly zero.
 *
 * @class
 */
var Constraint = function () {
    /**
     * Construct a new Constraint.
     *
     * @param expression The constraint expression.
     * @param operator The equation operator.
     * @param strength The strength of the constraint.
     */
    function Constraint(expression, operator, strength) {
        if (strength === void 0) {
            strength = strength_1.Strength.required;
        }
        this._id = CnId++;
        this._operator = operator;
        this._expression = expression;
        this._strength = strength_1.Strength.clip(strength);
    }
    /**
     * A static constraint comparison function.
     */
    Constraint.Compare = function (a, b) {
        return a.id - b.id;
    };
    Constraint.prototype.toString = function () {
        var _this = this;
        var op = function () {
            switch (_this._operator) {
            case Operator.Le:
                return '<=';
            case Operator.Ge:
                return '>=';
            case Operator.Eq:
                return '==';
            }
        };
        return this._expression + ' ' + op() + ' 0';
    };
    Object.defineProperty(Constraint.prototype, 'id', {
        /**
         * Returns the unique id number of the constraint.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Constraint.prototype, 'expression', {
        /**
         * Returns the expression of the constraint.
         */
        get: function () {
            return this._expression;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Constraint.prototype, 'op', {
        /**
         * Returns the relational operator of the constraint.
         */
        get: function () {
            return this._operator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Constraint.prototype, 'strength', {
        /**
         * Returns the strength of the constraint.
         */
        get: function () {
            return this._strength;
        },
        enumerable: true,
        configurable: true
    });
    return Constraint;
}();
exports.Constraint = Constraint;
/**
 * The internal constraint id counter.
 */
var CnId = 0;},
/* kiwi/build/expression */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var tsu_1 = require(321    /* ./tsu */);
var variable_1 = require(324    /* ./variable */);
var maptype_1 = require(315    /* ./maptype */);
/**
 * An expression of variable terms and a constant.
 *
 * @class
 */
var Expression = function () {
    function Expression() {
        var parsed = parseArgs(arguments);
        this._terms = parsed.terms;
        this._constant = parsed.constant;
    }
    Expression.prototype.toString = function () {
        var terms = [];
        tsu_1.forEach(this._terms, function (pair) {
            terms.push([
                pair.first,
                pair.second
            ]);
        });
        var first = true;
        var s = '';
        for (var _i = 0, terms_1 = terms; _i < terms_1.length; _i++) {
            var _a = terms_1[_i], v = _a[0], c_1 = _a[1];
            if (first) {
                first = false;
                if (c_1 == 1)
                    s += '' + v;
                else if (c_1 == -1)
                    s += '-' + v;
                else
                    s += c_1 + '*' + v;
            } else {
                if (c_1 == 1)
                    s += ' + ' + v;
                else if (c_1 == -1)
                    s += ' - ' + v;
                else if (c_1 >= 0)
                    s += ' + ' + c_1 + v;
                else
                    s += ' - ' + -c_1 + v;
            }
        }
        var c = this.constant;
        if (c < 0)
            s += ' - ' + -c;
        else if (c > 0)
            s += ' + ' + c;
        return s;
    };
    Object.defineProperty(Expression.prototype, 'terms', {
        /**
         * Returns the mapping of terms in the expression.
         *
         * This *must* be treated as const.
         */
        get: function () {
            return this._terms;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Expression.prototype, 'constant', {
        /**
         * Returns the constant of the expression.
         */
        get: function () {
            return this._constant;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Expression.prototype, 'value', {
        /**
         * Returns the computed value of the expression.
         */
        get: function () {
            var result = this._constant;
            tsu_1.forEach(this._terms, function (pair) {
                result += pair.first.value * pair.second;
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return Expression;
}();
exports.Expression = Expression;
/**
 * An internal argument parsing function.
 */
function parseArgs(args) {
    var constant = 0;
    var factory = function () {
        return 0;
    };
    var terms = maptype_1.createMap(variable_1.Variable.Compare);
    for (var i = 0, n = args.length; i < n; ++i) {
        var item = args[i];
        if (typeof item === 'number') {
            constant += item;
        } else if (item instanceof variable_1.Variable) {
            terms.setDefault(item, factory).second += 1;
        } else if (item instanceof Array) {
            if (item.length !== 2) {
                throw new Error('array must have length 2');
            }
            var value = item[0];
            var variable = item[1];
            if (typeof value !== 'number') {
                throw new Error('array item 0 must be a number');
            }
            if (!(variable instanceof variable_1.Variable)) {
                throw new Error('array item 1 must be a variable');
            }
            terms.setDefault(variable, factory).second += value;
        } else {
            throw new Error('invalid Expression argument: ' + JSON.stringify(item));
        }
    }
    return {
        terms: terms,
        constant: constant
    };
}},
/* kiwi/build/index */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m)
        if (!exports.hasOwnProperty(p))
            exports[p] = m[p];
}
Object.defineProperty(exports, '__esModule', { value: true });
__export(require(324    /* ./variable */));
__export(require(313    /* ./expression */));
__export(require(312    /* ./constraint */));
__export(require(317    /* ./strength */));
__export(require(316    /* ./solver */));},
/* kiwi/build/maptype */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var tsu_1 = require(321    /* ./tsu */);
function createMap(compare) {
    return new tsu_1.AssociativeArray(compare);
}
exports.createMap = createMap;},
/* kiwi/build/solver */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var variable_1 = require(324    /* ./variable */);
var expression_1 = require(313    /* ./expression */);
var constraint_1 = require(312    /* ./constraint */);
var strength_1 = require(317    /* ./strength */);
var maptype_1 = require(315    /* ./maptype */);
var tsu_1 = require(321    /* ./tsu */);
/**
 * The constraint solver class.
 *
 * @class
 */
var Solver = function () {
    /**
     * Construct a new Solver.
     */
    function Solver() {
        this._cnMap = createCnMap();
        this._rowMap = createRowMap();
        this._varMap = createVarMap();
        this._editMap = createEditMap();
        this._infeasibleRows = [];
        this._objective = new Row();
        this._artificial = null;
        this._idTick = 0;
    }
    /**
     * Add a constraint to the solver.
     */
    Solver.prototype.addConstraint = function (constraint) {
        var cnPair = this._cnMap.find(constraint);
        if (cnPair !== undefined) {
            throw new Error('duplicate constraint');
        }
        // Creating a row causes symbols to be reserved for the variables
        // in the constraint. If this method exits with an exception,
        // then its possible those variables will linger in the var map.
        // Since its likely that those variables will be used in other
        // constraints and since exceptional conditions are uncommon,
        // i'm not too worried about aggressive cleanup of the var map.
        var data = this._createRow(constraint);
        var row = data.row;
        var tag = data.tag;
        var subject = this._chooseSubject(row, tag);
        // If chooseSubject couldnt find a valid entering symbol, one
        // last option is available if the entire row is composed of
        // dummy variables. If the constant of the row is zero, then
        // this represents redundant constraints and the new dummy
        // marker can enter the basis. If the constant is non-zero,
        // then it represents an unsatisfiable constraint.
        if (subject.type() === SymbolType.Invalid && row.allDummies()) {
            if (!nearZero(row.constant())) {
                var names = [];
                for (var _i = 0, _a = constraint.expression.terms._array; _i < _a.length; _i++) {
                    var item = _a[_i];
                    names.push(item.first.name);
                }
                var op = [
                    'LE',
                    'GE',
                    'EQ'
                ][constraint.op];
                throw new Error('unsatisfiable constraint [' + names.join(',') + '] operator: ' + op);
            } else {
                subject = tag.marker;
            }
        }
        // If an entering symbol still isn't found, then the row must
        // be added using an artificial variable. If that fails, then
        // the row represents an unsatisfiable constraint.
        if (subject.type() === SymbolType.Invalid) {
            if (!this._addWithArtificialVariable(row)) {
                throw new Error('unsatisfiable constraint');
            }
        } else {
            row.solveFor(subject);
            this._substitute(subject, row);
            this._rowMap.insert(subject, row);
        }
        this._cnMap.insert(constraint, tag);
        // Optimizing after each constraint is added performs less
        // aggregate work due to a smaller average system size. It
        // also ensures the solver remains in a consistent state.
        this._optimize(this._objective);
    };
    /**
     * Remove a constraint from the solver.
     */
    Solver.prototype.removeConstraint = function (constraint, silent) {
        if (silent === void 0) {
            silent = false;
        }
        var cnPair = this._cnMap.erase(constraint);
        if (cnPair === undefined) {
            if (silent)
                return;
            else
                throw new Error('unknown constraint');
        }
        // Remove the error effects from the objective function
        // *before* pivoting, or substitutions into the objective
        // will lead to incorrect solver results.
        this._removeConstraintEffects(constraint, cnPair.second);
        // If the marker is basic, simply drop the row. Otherwise,
        // pivot the marker into the basis and then drop the row.
        var marker = cnPair.second.marker;
        var rowPair = this._rowMap.erase(marker);
        if (rowPair === undefined) {
            var leaving = this._getMarkerLeavingSymbol(marker);
            if (leaving.type() === SymbolType.Invalid) {
                throw new Error('failed to find leaving row');
            }
            rowPair = this._rowMap.erase(leaving);
            rowPair.second.solveForEx(leaving, marker);
            this._substitute(marker, rowPair.second);
        }
        // Optimizing after each constraint is removed ensures that the
        // solver remains consistent. It makes the solver api easier to
        // use at a small tradeoff for speed.
        this._optimize(this._objective);
    };
    /**
     * Test whether the solver contains the constraint.
     */
    Solver.prototype.hasConstraint = function (constraint) {
        return this._cnMap.contains(constraint);
    };
    /**
     * Add an edit variable to the solver.
     */
    Solver.prototype.addEditVariable = function (variable, strength) {
        var editPair = this._editMap.find(variable);
        if (editPair !== undefined) {
            throw new Error('duplicate edit variable: ' + variable.name);
        }
        strength = strength_1.Strength.clip(strength);
        if (strength === strength_1.Strength.required) {
            throw new Error('bad required strength');
        }
        var expr = new expression_1.Expression(variable);
        var cn = new constraint_1.Constraint(expr, constraint_1.Operator.Eq, strength);
        this.addConstraint(cn);
        var tag = this._cnMap.find(cn).second;
        var info = {
            tag: tag,
            constraint: cn,
            constant: 0
        };
        this._editMap.insert(variable, info);
    };
    /**
     * Remove an edit variable from the solver.
     */
    Solver.prototype.removeEditVariable = function (variable, silent) {
        if (silent === void 0) {
            silent = false;
        }
        var editPair = this._editMap.erase(variable);
        if (editPair === undefined) {
            if (silent)
                return;
            else
                throw new Error('unknown edit variable: ' + variable.name);
        }
        this.removeConstraint(editPair.second.constraint, silent);
    };
    /**
     * Test whether the solver contains the edit variable.
     */
    Solver.prototype.hasEditVariable = function (variable) {
        return this._editMap.contains(variable);
    };
    /**
     * Suggest the value of an edit variable.
     */
    Solver.prototype.suggestValue = function (variable, value) {
        var editPair = this._editMap.find(variable);
        if (editPair === undefined) {
            throw new Error('unknown edit variable: ' + variable.name);
        }
        var rows = this._rowMap;
        var info = editPair.second;
        var delta = value - info.constant;
        info.constant = value;
        // Check first if the positive error variable is basic.
        var marker = info.tag.marker;
        var rowPair = rows.find(marker);
        if (rowPair !== undefined) {
            if (rowPair.second.add(-delta) < 0) {
                this._infeasibleRows.push(marker);
            }
            this._dualOptimize();
            return;
        }
        // Check next if the negative error variable is basic.
        var other = info.tag.other;
        rowPair = rows.find(other);
        if (rowPair !== undefined) {
            if (rowPair.second.add(delta) < 0) {
                this._infeasibleRows.push(other);
            }
            this._dualOptimize();
            return;
        }
        // Otherwise update each row where the error variables exist.
        for (var i = 0, n = rows.size(); i < n; ++i) {
            var rowPair_1 = rows.itemAt(i);
            var row = rowPair_1.second;
            var coeff = row.coefficientFor(marker);
            if (coeff !== 0 && row.add(delta * coeff) < 0 && rowPair_1.first.type() !== SymbolType.External) {
                this._infeasibleRows.push(rowPair_1.first);
            }
        }
        this._dualOptimize();
    };
    /**
     * Update the values of the variables.
     */
    Solver.prototype.updateVariables = function () {
        var vars = this._varMap;
        var rows = this._rowMap;
        for (var i = 0, n = vars.size(); i < n; ++i) {
            var pair = vars.itemAt(i);
            var rowPair = rows.find(pair.second);
            var c = 0;
            if (rowPair !== undefined) {
                c = rowPair.second.constant();
                // Normalize -0 to 0. Note that c === -0 is the same as c === 0, so we set c to zero
                // for both kinds of zeros. One would preferably use Object.is(c, -0), but that's not
                // widely supported yet.
                if (c === -0)
                    c = 0;
            }
            pair.first.setValue(c);
        }
    };
    Solver.prototype.getConstraints = function () {
        var constraints = [];
        tsu_1.forEach(this._cnMap, function (pair) {
            constraints.push(pair.first);
        });
        return constraints;
    };
    Object.defineProperty(Solver.prototype, 'numConstraints', {
        get: function () {
            return this._cnMap.size();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Solver.prototype, 'numEditVariables', {
        get: function () {
            return this._editMap.size();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the symbol for the given variable.
     *
     * If a symbol does not exist for the variable, one will be created.
     */
    Solver.prototype._getVarSymbol = function (variable) {
        var _this = this;
        var factory = function () {
            return _this._makeSymbol(SymbolType.External);
        };
        return this._varMap.setDefault(variable, factory).second;
    };
    /**
     * Create a new Row object for the given constraint.
     *
     * The terms in the constraint will be converted to cells in the row.
     * Any term in the constraint with a coefficient of zero is ignored.
     * This method uses the `_getVarSymbol` method to get the symbol for
     * the variables added to the row. If the symbol for a given cell
     * variable is basic, the cell variable will be substituted with the
     * basic row.
     *
     * The necessary slack and error variables will be added to the row.
     * If the constant for the row is negative, the sign for the row
     * will be inverted so the constant becomes positive.
     *
     * Returns the created Row and the tag for tracking the constraint.
     */
    Solver.prototype._createRow = function (constraint) {
        var expr = constraint.expression;
        var row = new Row(expr.constant);
        // Substitute the current basic variables into the row.
        var terms = expr.terms;
        for (var i = 0, n = terms.size(); i < n; ++i) {
            var termPair = terms.itemAt(i);
            if (!nearZero(termPair.second)) {
                var symbol = this._getVarSymbol(termPair.first);
                var basicPair = this._rowMap.find(symbol);
                if (basicPair !== undefined) {
                    row.insertRow(basicPair.second, termPair.second);
                } else {
                    row.insertSymbol(symbol, termPair.second);
                }
            }
        }
        // Add the necessary slack, error, and dummy variables.
        var objective = this._objective;
        var strength = constraint.strength;
        var tag = {
            marker: INVALID_SYMBOL,
            other: INVALID_SYMBOL
        };
        switch (constraint.op) {
        case constraint_1.Operator.Le:
        case constraint_1.Operator.Ge: {
                var coeff = constraint.op === constraint_1.Operator.Le ? 1 : -1;
                var slack = this._makeSymbol(SymbolType.Slack);
                tag.marker = slack;
                row.insertSymbol(slack, coeff);
                if (strength < strength_1.Strength.required) {
                    var error = this._makeSymbol(SymbolType.Error);
                    tag.other = error;
                    row.insertSymbol(error, -coeff);
                    objective.insertSymbol(error, strength);
                }
                break;
            }
        case constraint_1.Operator.Eq: {
                if (strength < strength_1.Strength.required) {
                    var errplus = this._makeSymbol(SymbolType.Error);
                    var errminus = this._makeSymbol(SymbolType.Error);
                    tag.marker = errplus;
                    tag.other = errminus;
                    row.insertSymbol(errplus, -1);
                    // v = eplus - eminus
                    row.insertSymbol(errminus, 1);
                    // v - eplus + eminus = 0
                    objective.insertSymbol(errplus, strength);
                    objective.insertSymbol(errminus, strength);
                } else {
                    var dummy = this._makeSymbol(SymbolType.Dummy);
                    tag.marker = dummy;
                    row.insertSymbol(dummy);
                }
                break;
            }
        }
        // Ensure the row has a positive constant.
        if (row.constant() < 0) {
            row.reverseSign();
        }
        return {
            row: row,
            tag: tag
        };
    };
    /**
     * Choose the subject for solving for the row.
     *
     * This method will choose the best subject for using as the solve
     * target for the row. An invalid symbol will be returned if there
     * is no valid target.
     *
     * The symbols are chosen according to the following precedence:
     *
     * 1) The first symbol representing an external variable.
     * 2) A negative slack or error tag variable.
     *
     * If a subject cannot be found, an invalid symbol will be returned.
     */
    Solver.prototype._chooseSubject = function (row, tag) {
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            if (pair.first.type() === SymbolType.External) {
                return pair.first;
            }
        }
        var type = tag.marker.type();
        if (type === SymbolType.Slack || type === SymbolType.Error) {
            if (row.coefficientFor(tag.marker) < 0) {
                return tag.marker;
            }
        }
        type = tag.other.type();
        if (type === SymbolType.Slack || type === SymbolType.Error) {
            if (row.coefficientFor(tag.other) < 0) {
                return tag.other;
            }
        }
        return INVALID_SYMBOL;
    };
    /**
     * Add the row to the tableau using an artificial variable.
     *
     * This will return false if the constraint cannot be satisfied.
     */
    Solver.prototype._addWithArtificialVariable = function (row) {
        // Create and add the artificial variable to the tableau.
        var art = this._makeSymbol(SymbolType.Slack);
        this._rowMap.insert(art, row.copy());
        this._artificial = row.copy();
        // Optimize the artificial objective. This is successful
        // only if the artificial objective is optimized to zero.
        this._optimize(this._artificial);
        var success = nearZero(this._artificial.constant());
        this._artificial = null;
        // If the artificial variable is basic, pivot the row so that
        // it becomes non-basic. If the row is constant, exit early.
        var pair = this._rowMap.erase(art);
        if (pair !== undefined) {
            var basicRow = pair.second;
            if (basicRow.isConstant()) {
                return success;
            }
            var entering = this._anyPivotableSymbol(basicRow);
            if (entering.type() === SymbolType.Invalid) {
                return false;    // unsatisfiable (will this ever happen?)
            }
            basicRow.solveForEx(art, entering);
            this._substitute(entering, basicRow);
            this._rowMap.insert(entering, basicRow);
        }
        // Remove the artificial variable from the tableau.
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
            rows.itemAt(i).second.removeSymbol(art);
        }
        this._objective.removeSymbol(art);
        return success;
    };
    /**
     * Substitute the parametric symbol with the given row.
     *
     * This method will substitute all instances of the parametric symbol
     * in the tableau and the objective function with the given row.
     */
    Solver.prototype._substitute = function (symbol, row) {
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
            var pair = rows.itemAt(i);
            pair.second.substitute(symbol, row);
            if (pair.second.constant() < 0 && pair.first.type() !== SymbolType.External) {
                this._infeasibleRows.push(pair.first);
            }
        }
        this._objective.substitute(symbol, row);
        if (this._artificial) {
            this._artificial.substitute(symbol, row);
        }
    };
    /**
     * Optimize the system for the given objective function.
     *
     * This method performs iterations of Phase 2 of the simplex method
     * until the objective function reaches a minimum.
     */
    Solver.prototype._optimize = function (objective) {
        while (true) {
            var entering = this._getEnteringSymbol(objective);
            if (entering.type() === SymbolType.Invalid) {
                return;
            }
            var leaving = this._getLeavingSymbol(entering);
            if (leaving.type() === SymbolType.Invalid) {
                throw new Error('the objective is unbounded');
            }
            // pivot the entering symbol into the basis
            var row = this._rowMap.erase(leaving).second;
            row.solveForEx(leaving, entering);
            this._substitute(entering, row);
            this._rowMap.insert(entering, row);
        }
    };
    /**
     * Optimize the system using the dual of the simplex method.
     *
     * The current state of the system should be such that the objective
     * function is optimal, but not feasible. This method will perform
     * an iteration of the dual simplex method to make the solution both
     * optimal and feasible.
     */
    Solver.prototype._dualOptimize = function () {
        var rows = this._rowMap;
        var infeasible = this._infeasibleRows;
        while (infeasible.length !== 0) {
            var leaving = infeasible.pop();
            var pair = rows.find(leaving);
            if (pair !== undefined && pair.second.constant() < 0) {
                var entering = this._getDualEnteringSymbol(pair.second);
                if (entering.type() === SymbolType.Invalid) {
                    throw new Error('dual optimize failed');
                }
                // pivot the entering symbol into the basis
                var row = pair.second;
                rows.erase(leaving);
                row.solveForEx(leaving, entering);
                this._substitute(entering, row);
                rows.insert(entering, row);
            }
        }
    };
    /**
     * Compute the entering variable for a pivot operation.
     *
     * This method will return first symbol in the objective function which
     * is non-dummy and has a coefficient less than zero. If no symbol meets
     * the criteria, it means the objective function is at a minimum, and an
     * invalid symbol is returned.
     */
    Solver.prototype._getEnteringSymbol = function (objective) {
        var cells = objective.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            var symbol = pair.first;
            if (pair.second < 0 && symbol.type() !== SymbolType.Dummy) {
                return symbol;
            }
        }
        return INVALID_SYMBOL;
    };
    /**
     * Compute the entering symbol for the dual optimize operation.
     *
     * This method will return the symbol in the row which has a positive
     * coefficient and yields the minimum ratio for its respective symbol
     * in the objective function. The provided row *must* be infeasible.
     * If no symbol is found which meats the criteria, an invalid symbol
     * is returned.
     */
    Solver.prototype._getDualEnteringSymbol = function (row) {
        var ratio = Number.MAX_VALUE;
        var entering = INVALID_SYMBOL;
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            var symbol = pair.first;
            var c = pair.second;
            if (c > 0 && symbol.type() !== SymbolType.Dummy) {
                var coeff = this._objective.coefficientFor(symbol);
                var r = coeff / c;
                if (r < ratio) {
                    ratio = r;
                    entering = symbol;
                }
            }
        }
        return entering;
    };
    /**
     * Compute the symbol for pivot exit row.
     *
     * This method will return the symbol for the exit row in the row
     * map. If no appropriate exit symbol is found, an invalid symbol
     * will be returned. This indicates that the objective function is
     * unbounded.
     */
    Solver.prototype._getLeavingSymbol = function (entering) {
        var ratio = Number.MAX_VALUE;
        var found = INVALID_SYMBOL;
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
            var pair = rows.itemAt(i);
            var symbol = pair.first;
            if (symbol.type() !== SymbolType.External) {
                var row = pair.second;
                var temp = row.coefficientFor(entering);
                if (temp < 0) {
                    var temp_ratio = -row.constant() / temp;
                    if (temp_ratio < ratio) {
                        ratio = temp_ratio;
                        found = symbol;
                    }
                }
            }
        }
        return found;
    };
    /**
     * Compute the leaving symbol for a marker variable.
     *
     * This method will return a symbol corresponding to a basic row
     * which holds the given marker variable. The row will be chosen
     * according to the following precedence:
     *
     * 1) The row with a restricted basic varible and a negative coefficient
     *    for the marker with the smallest ratio of -constant / coefficient.
     *
     * 2) The row with a restricted basic variable and the smallest ratio
     *    of constant / coefficient.
     *
     * 3) The last unrestricted row which contains the marker.
     *
     * If the marker does not exist in any row, an invalid symbol will be
     * returned. This indicates an internal solver error since the marker
     * *should* exist somewhere in the tableau.
     */
    Solver.prototype._getMarkerLeavingSymbol = function (marker) {
        var dmax = Number.MAX_VALUE;
        var r1 = dmax;
        var r2 = dmax;
        var invalid = INVALID_SYMBOL;
        var first = invalid;
        var second = invalid;
        var third = invalid;
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
            var pair = rows.itemAt(i);
            var row = pair.second;
            var c = row.coefficientFor(marker);
            if (c === 0) {
                continue;
            }
            var symbol = pair.first;
            if (symbol.type() === SymbolType.External) {
                third = symbol;
            } else if (c < 0) {
                var r = -row.constant() / c;
                if (r < r1) {
                    r1 = r;
                    first = symbol;
                }
            } else {
                var r = row.constant() / c;
                if (r < r2) {
                    r2 = r;
                    second = symbol;
                }
            }
        }
        if (first !== invalid) {
            return first;
        }
        if (second !== invalid) {
            return second;
        }
        return third;
    };
    /**
     * Remove the effects of a constraint on the objective function.
     */
    Solver.prototype._removeConstraintEffects = function (cn, tag) {
        if (tag.marker.type() === SymbolType.Error) {
            this._removeMarkerEffects(tag.marker, cn.strength);
        }
        if (tag.other.type() === SymbolType.Error) {
            this._removeMarkerEffects(tag.other, cn.strength);
        }
    };
    /**
     * Remove the effects of an error marker on the objective function.
     */
    Solver.prototype._removeMarkerEffects = function (marker, strength) {
        var pair = this._rowMap.find(marker);
        if (pair !== undefined) {
            this._objective.insertRow(pair.second, -strength);
        } else {
            this._objective.insertSymbol(marker, -strength);
        }
    };
    /**
     * Get the first Slack or Error symbol in the row.
     *
     * If no such symbol is present, an invalid symbol will be returned.
     */
    Solver.prototype._anyPivotableSymbol = function (row) {
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            var type = pair.first.type();
            if (type === SymbolType.Slack || type === SymbolType.Error) {
                return pair.first;
            }
        }
        return INVALID_SYMBOL;
    };
    /**
     * Returns a new Symbol of the given type.
     */
    Solver.prototype._makeSymbol = function (type) {
        return new Symbol(type, this._idTick++);
    };
    return Solver;
}();
exports.Solver = Solver;
/**
 * Test whether a value is approximately zero.
 */
function nearZero(value) {
    var eps = 1e-8;
    return value < 0 ? -value < eps : value < eps;
}
/**
 * An internal function for creating a constraint map.
 */
function createCnMap() {
    return maptype_1.createMap(constraint_1.Constraint.Compare);
}
/**
 * An internal function for creating a row map.
 */
function createRowMap() {
    return maptype_1.createMap(Symbol.Compare);
}
/**
 * An internal function for creating a variable map.
 */
function createVarMap() {
    return maptype_1.createMap(variable_1.Variable.Compare);
}
/**
 * An internal function for creating an edit map.
 */
function createEditMap() {
    return maptype_1.createMap(variable_1.Variable.Compare);
}
/**
 * An enum defining the available symbol types.
 */
var SymbolType;
(function (SymbolType) {
    SymbolType[SymbolType['Invalid'] = 0] = 'Invalid';
    SymbolType[SymbolType['External'] = 1] = 'External';
    SymbolType[SymbolType['Slack'] = 2] = 'Slack';
    SymbolType[SymbolType['Error'] = 3] = 'Error';
    SymbolType[SymbolType['Dummy'] = 4] = 'Dummy';
}(SymbolType || (SymbolType = {})));
/**
 * An internal class representing a symbol in the solver.
 */
var Symbol = function () {
    /**
     * Construct a new Symbol
     *
     * @param [type] The type of the symbol.
     * @param [id] The unique id number of the symbol.
     */
    function Symbol(type, id) {
        this._id = id;
        this._type = type;
    }
    /**
     * The static Symbol comparison function.
     */
    Symbol.Compare = function (a, b) {
        return a.id() - b.id();
    };
    /**
     * Returns the unique id number of the symbol.
     */
    Symbol.prototype.id = function () {
        return this._id;
    };
    /**
     * Returns the type of the symbol.
     */
    Symbol.prototype.type = function () {
        return this._type;
    };
    return Symbol;
}();
/**
 * A static invalid symbol
 */
var INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);
/**
 * An internal row class used by the solver.
 */
var Row = function () {
    /**
     * Construct a new Row.
     */
    function Row(constant) {
        if (constant === void 0) {
            constant = 0;
        }
        this._cellMap = maptype_1.createMap(Symbol.Compare);
        this._constant = constant;
    }
    /**
     * Returns the mapping of symbols to coefficients.
     */
    Row.prototype.cells = function () {
        return this._cellMap;
    };
    /**
     * Returns the constant for the row.
     */
    Row.prototype.constant = function () {
        return this._constant;
    };
    /**
     * Returns true if the row is a constant value.
     */
    Row.prototype.isConstant = function () {
        return this._cellMap.empty();
    };
    /**
     * Returns true if the Row has all dummy symbols.
     */
    Row.prototype.allDummies = function () {
        var cells = this._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            if (pair.first.type() !== SymbolType.Dummy) {
                return false;
            }
        }
        return true;
    };
    /**
     * Create a copy of the row.
     */
    Row.prototype.copy = function () {
        var theCopy = new Row(this._constant);
        theCopy._cellMap = this._cellMap.copy();
        return theCopy;
    };
    /**
     * Add a constant value to the row constant.
     *
     * Returns the new value of the constant.
     */
    Row.prototype.add = function (value) {
        return this._constant += value;
    };
    /**
     * Insert the symbol into the row with the given coefficient.
     *
     * If the symbol already exists in the row, the coefficient
     * will be added to the existing coefficient. If the resulting
     * coefficient is zero, the symbol will be removed from the row.
     */
    Row.prototype.insertSymbol = function (symbol, coefficient) {
        if (coefficient === void 0) {
            coefficient = 1;
        }
        var pair = this._cellMap.setDefault(symbol, function () {
            return 0;
        });
        if (nearZero(pair.second += coefficient)) {
            this._cellMap.erase(symbol);
        }
    };
    /**
     * Insert a row into this row with a given coefficient.
     *
     * The constant and the cells of the other row will be
     * multiplied by the coefficient and added to this row. Any
     * cell with a resulting coefficient of zero will be removed
     * from the row.
     */
    Row.prototype.insertRow = function (other, coefficient) {
        if (coefficient === void 0) {
            coefficient = 1;
        }
        this._constant += other._constant * coefficient;
        var cells = other._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            this.insertSymbol(pair.first, pair.second * coefficient);
        }
    };
    /**
     * Remove a symbol from the row.
     */
    Row.prototype.removeSymbol = function (symbol) {
        this._cellMap.erase(symbol);
    };
    /**
     * Reverse the sign of the constant and cells in the row.
     */
    Row.prototype.reverseSign = function () {
        this._constant = -this._constant;
        var cells = this._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
            var pair = cells.itemAt(i);
            pair.second = -pair.second;
        }
    };
    /**
     * Solve the row for the given symbol.
     *
     * This method assumes the row is of the form
     * a * x + b * y + c = 0 and (assuming solve for x) will modify
     * the row to represent the right hand side of
     * x = -b/a * y - c / a. The target symbol will be removed from
     * the row, and the constant and other cells will be multiplied
     * by the negative inverse of the target coefficient.
     *
     * The given symbol *must* exist in the row.
     */
    Row.prototype.solveFor = function (symbol) {
        var cells = this._cellMap;
        var pair = cells.erase(symbol);
        var coeff = -1 / pair.second;
        this._constant *= coeff;
        for (var i = 0, n = cells.size(); i < n; ++i) {
            cells.itemAt(i).second *= coeff;
        }
    };
    /**
     * Solve the row for the given symbols.
     *
     * This method assumes the row is of the form
     * x = b * y + c and will solve the row such that
     * y = x / b - c / b. The rhs symbol will be removed from the
     * row, the lhs added, and the result divided by the negative
     * inverse of the rhs coefficient.
     *
     * The lhs symbol *must not* exist in the row, and the rhs
     * symbol must* exist in the row.
     */
    Row.prototype.solveForEx = function (lhs, rhs) {
        this.insertSymbol(lhs, -1);
        this.solveFor(rhs);
    };
    /**
     * Returns the coefficient for the given symbol.
     */
    Row.prototype.coefficientFor = function (symbol) {
        var pair = this._cellMap.find(symbol);
        return pair !== undefined ? pair.second : 0;
    };
    /**
     * Substitute a symbol with the data from another row.
     *
     * Given a row of the form a * x + b and a substitution of the
     * form x = 3 * y + c the row will be updated to reflect the
     * expression 3 * a * y + a * c + b.
     *
     * If the symbol does not exist in the row, this is a no-op.
     */
    Row.prototype.substitute = function (symbol, row) {
        var pair = this._cellMap.erase(symbol);
        if (pair !== undefined) {
            this.insertRow(row, pair.second);
        }
    };
    return Row;
}();},
/* kiwi/build/strength */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var Strength;
(function (Strength) {
    /**
     * Create a new symbolic strength.
     */
    function create(a, b, c, w) {
        if (w === void 0) {
            w = 1;
        }
        var result = 0;
        result += Math.max(0, Math.min(1000, a * w)) * 1000000;
        result += Math.max(0, Math.min(1000, b * w)) * 1000;
        result += Math.max(0, Math.min(1000, c * w));
        return result;
    }
    Strength.create = create;
    /**
     * The 'required' symbolic strength.
     */
    Strength.required = create(1000, 1000, 1000);
    /**
     * The 'strong' symbolic strength.
     */
    Strength.strong = create(1, 0, 0);
    /**
     * The 'medium' symbolic strength.
     */
    Strength.medium = create(0, 1, 0);
    /**
     * The 'weak' symbolic strength.
     */
    Strength.weak = create(0, 0, 1);
    /**
     * Clip a symbolic strength to the allowed min and max.
     */
    function clip(value) {
        return Math.max(0, Math.min(Strength.required, value));
    }
    Strength.clip = clip;
}(Strength = exports.Strength || (exports.Strength = {})));},
/* kiwi/build/tsu/algorithm */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var iterator_1 = require(322    /* ./iterator */);
/**
* Perform a lower bound search on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The index of the first element in the array which
*          compares greater than or equal to the given value.
*/
function lowerBound(array, value, compare) {
    var begin = 0;
    var n = array.length;
    var half;
    var middle;
    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (compare(array[middle], value) < 0) {
            begin = middle + 1;
            n -= half + 1;
        } else {
            n = half;
        }
    }
    return begin;
}
exports.lowerBound = lowerBound;
/**
* Perform a binary search on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The index of the found item, or -1.
*/
function binarySearch(array, value, compare) {
    var index = lowerBound(array, value, compare);
    if (index === array.length) {
        return -1;
    }
    var item = array[index];
    if (compare(item, value) !== 0) {
        return -1;
    }
    return index;
}
exports.binarySearch = binarySearch;
/**
* Perform a binary find on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The found item in the array, or undefined.
*/
function binaryFind(array, value, compare) {
    var index = lowerBound(array, value, compare);
    if (index === array.length) {
        return undefined;
    }
    var item = array[index];
    if (compare(item, value) !== 0) {
        return undefined;
    }
    return item;
}
exports.binaryFind = binaryFind;
function asSet(items, compare) {
    var array = iterator_1.asArray(items);
    var n = array.length;
    if (n <= 1) {
        return array;
    }
    array.sort(compare);
    var result = [array[0]];
    for (var i = 1, j = 0; i < n; ++i) {
        var item = array[i];
        if (compare(result[j], item) !== 0) {
            result.push(item);
            ++j;
        }
    }
    return result;
}
exports.asSet = asSet;
/**
* Test whether a two sorted arrays sets are disjoint.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns true if the sets are disjoint, false otherwise.
*/
function setIsDisjoint(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    while (i < len1 && j < len2) {
        var v = compare(first[i], second[j]);
        if (v < 0) {
            ++i;
        } else if (v > 0) {
            ++j;
        } else {
            return false;
        }
    }
    return true;
}
exports.setIsDisjoint = setIsDisjoint;
/**
* Test whether one sorted array set is the subset of another.
*
* @param first The potential subset.
* @param second The potential superset.
* @param compare The value comparison function.
* @returns true if the first set is a subset of the second.
*/
function setIsSubset(first, second, compare) {
    var len1 = first.length;
    var len2 = second.length;
    if (len1 > len2) {
        return false;
    }
    var i = 0, j = 0;
    while (i < len1 && j < len2) {
        var v = compare(first[i], second[j]);
        if (v < 0) {
            return false;
        } else if (v > 0) {
            ++j;
        } else {
            ++i;
            ++j;
        }
    }
    if (i < len1) {
        return false;
    }
    return true;
}
exports.setIsSubset = setIsSubset;
/**
* Create the set union of two sorted set arrays.
var j = 0;
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set union of the two arrays.
*/
function setUnion(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    var merged = [];
    while (i < len1 && j < len2) {
        var a = first[i];
        var b = second[j];
        var v = compare(a, b);
        if (v < 0) {
            merged.push(a);
            ++i;
        } else if (v > 0) {
            merged.push(b);
            ++j;
        } else {
            merged.push(a);
            ++i;
            ++j;
        }
    }
    while (i < len1) {
        merged.push(first[i]);
        ++i;
    }
    while (j < len2) {
        merged.push(second[j]);
        ++j;
    }
    return merged;
}
exports.setUnion = setUnion;
/**
* Create a set intersection of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set intersection of the two arrays.
*/
function setIntersection(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    var merged = [];
    while (i < len1 && j < len2) {
        var a = first[i];
        var b = second[j];
        var v = compare(a, b);
        if (v < 0) {
            ++i;
        } else if (v > 0) {
            ++j;
        } else {
            merged.push(a);
            ++i;
            ++j;
        }
    }
    return merged;
}
exports.setIntersection = setIntersection;
/**
* Create a set difference of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set difference of the two arrays.
*/
function setDifference(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    var merged = [];
    while (i < len1 && j < len2) {
        var a = first[i];
        var b = second[j];
        var v = compare(a, b);
        if (v < 0) {
            merged.push(a);
            ++i;
        } else if (v > 0) {
            ++j;
        } else {
            ++i;
            ++j;
        }
    }
    while (i < len1) {
        merged.push(first[i]);
        ++i;
    }
    return merged;
}
exports.setDifference = setDifference;
/**
* Create a set symmetric difference of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set symmetric difference of the two arrays.
*/
function setSymmetricDifference(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    var merged = [];
    while (i < len1 && j < len2) {
        var a = first[i];
        var b = second[j];
        var v = compare(a, b);
        if (v < 0) {
            merged.push(a);
            ++i;
        } else if (v > 0) {
            merged.push(b);
            ++j;
        } else {
            ++i;
            ++j;
        }
    }
    while (i < len1) {
        merged.push(first[i]);
        ++i;
    }
    while (j < len2) {
        merged.push(second[j]);
        ++j;
    }
    return merged;
}
exports.setSymmetricDifference = setSymmetricDifference;},
/* kiwi/build/tsu/array_base */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
var iterator_1 = require(322    /* ./iterator */);
/**
* A base class for implementing array-based data structures.
*
* @class
*/
var ArrayBase = function () {
    function ArrayBase() {
        /*
        * The internal data array.
        *
        * @protected
        */
        this._array = [];
    }
    /**
    * Returns the number of items in the array.
    */
    ArrayBase.prototype.size = function () {
        return this._array.length;
    };
    /**
    * Returns true if the array is empty.
    */
    ArrayBase.prototype.empty = function () {
        return this._array.length === 0;
    };
    /**
    * Returns the item at the given array index.
    *
    * @param index The integer index of the desired item.
    */
    ArrayBase.prototype.itemAt = function (index) {
        return this._array[index];
    };
    /**
    * Removes and returns the item at the given index.
    *
    * @param index The integer index of the desired item.
    */
    ArrayBase.prototype.takeAt = function (index) {
        return this._array.splice(index, 1)[0];
    };
    /**
    * Clear the internal contents of array.
    */
    ArrayBase.prototype.clear = function () {
        this._array = [];
    };
    /**
    * Swap this array's contents with another array.
    *
    * @param other The array base to use for the swap.
    */
    ArrayBase.prototype.swap = function (other) {
        var array = this._array;
        this._array = other._array;
        other._array = array;
    };
    /**
    * Returns an iterator over the array of items.
    */
    ArrayBase.prototype.__iter__ = function () {
        return iterator_1.iter(this._array);
    };
    /**
    * Returns a reverse iterator over the array of items.
    */
    ArrayBase.prototype.__reversed__ = function () {
        return iterator_1.reversed(this._array);
    };
    return ArrayBase;
}();
exports.ArrayBase = ArrayBase;},
/* kiwi/build/tsu/associative_array */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, '__esModule', { value: true });
var pair_1 = require(323    /* ./pair */);
var array_base_1 = require(319    /* ./array_base */);
var algorithm_1 = require(318    /* ./algorithm */);
var iterator_1 = require(322    /* ./iterator */);
/**
* A mapping container build on a sorted array.
*
* @class
*/
var AssociativeArray = function (_super) {
    __extends(AssociativeArray, _super);
    /**
    * Construct a new AssociativeArray.
    *
    * @param compare The key comparison function.
    */
    function AssociativeArray(compare) {
        var _this = _super.call(this) || this;
        _this._compare = compare;
        _this._wrapped = wrapCompare(compare);
        return _this;
    }
    /**
    * Returns the key comparison function used by this array.
    */
    AssociativeArray.prototype.comparitor = function () {
        return this._compare;
    };
    /**
    * Return the array index of the given key, or -1.
    *
    * @param key The key to locate in the array.
    */
    AssociativeArray.prototype.indexOf = function (key) {
        return algorithm_1.binarySearch(this._array, key, this._wrapped);
    };
    /**
    * Returns true if the key is in the array, false otherwise.
    *
    * @param key The key to locate in the array.
    */
    AssociativeArray.prototype.contains = function (key) {
        return algorithm_1.binarySearch(this._array, key, this._wrapped) >= 0;
    };
    /**
    * Returns the pair associated with the given key, or undefined.
    *
    * @param key The key to locate in the array.
    */
    AssociativeArray.prototype.find = function (key) {
        return algorithm_1.binaryFind(this._array, key, this._wrapped);
    };
    /**
    * Returns the pair associated with the key if it exists.
    *
    * If the key does not exist, a new pair will be created and
    * inserted using the value created by the given factory.
    *
    * @param key The key to locate in the array.
    * @param factory The function which creates the default value.
    */
    AssociativeArray.prototype.setDefault = function (key, factory) {
        var array = this._array;
        var index = algorithm_1.lowerBound(array, key, this._wrapped);
        if (index === array.length) {
            var pair = new pair_1.Pair(key, factory());
            array.push(pair);
            return pair;
        }
        var currPair = array[index];
        if (this._compare(currPair.first, key) !== 0) {
            var pair = new pair_1.Pair(key, factory());
            array.splice(index, 0, pair);
            return pair;
        }
        return currPair;
    };
    /**
    * Insert the pair into the array and return the pair.
    *
    * This will overwrite any existing entry in the array.
    *
    * @param key The key portion of the pair.
    * @param value The value portion of the pair.
    */
    AssociativeArray.prototype.insert = function (key, value) {
        var array = this._array;
        var index = algorithm_1.lowerBound(array, key, this._wrapped);
        if (index === array.length) {
            var pair = new pair_1.Pair(key, value);
            array.push(pair);
            return pair;
        }
        var currPair = array[index];
        if (this._compare(currPair.first, key) !== 0) {
            var pair = new pair_1.Pair(key, value);
            array.splice(index, 0, pair);
            return pair;
        }
        currPair.second = value;
        return currPair;
    };
    AssociativeArray.prototype.update = function (object) {
        var _this = this;
        if (object instanceof AssociativeArray) {
            this._array = merge(this._array, object._array, this._compare);
        } else {
            iterator_1.forEach(object, function (pair) {
                _this.insert(pair.first, pair.second);
            });
        }
    };
    /**
    * Removes and returns the pair for the given key, or undefined.
    *
    * @param key The key to remove from the map.
    */
    AssociativeArray.prototype.erase = function (key) {
        var array = this._array;
        var index = algorithm_1.binarySearch(array, key, this._wrapped);
        if (index < 0) {
            return undefined;
        }
        return array.splice(index, 1)[0];
    };
    /**
    * Create a copy of this associative array.
    */
    AssociativeArray.prototype.copy = function () {
        var theCopy = new AssociativeArray(this._compare);
        var copyArray = theCopy._array;
        var thisArray = this._array;
        for (var i = 0, n = thisArray.length; i < n; ++i) {
            copyArray.push(thisArray[i].copy());
        }
        return theCopy;
    };
    return AssociativeArray;
}(array_base_1.ArrayBase);
exports.AssociativeArray = AssociativeArray;
/**
* An internal which wraps a comparison key function.
*/
function wrapCompare(cmp) {
    return function (pair, value) {
        return cmp(pair.first, value);
    };
}
/**
* An internal function which merges two ordered pair arrays.
*/
function merge(first, second, compare) {
    var i = 0, j = 0;
    var len1 = first.length;
    var len2 = second.length;
    var merged = [];
    while (i < len1 && j < len2) {
        var a = first[i];
        var b = second[j];
        var v = compare(a.first, b.first);
        if (v < 0) {
            merged.push(a.copy());
            ++i;
        } else if (v > 0) {
            merged.push(b.copy());
            ++j;
        } else {
            merged.push(b.copy());
            ++i;
            ++j;
        }
    }
    while (i < len1) {
        merged.push(first[i].copy());
        ++i;
    }
    while (j < len2) {
        merged.push(second[j].copy());
        ++j;
    }
    return merged;
}},
/* kiwi/build/tsu/index */ function(require, module, exports) {
'use strict';
function __export(m) {
    for (var p in m)
        if (!exports.hasOwnProperty(p))
            exports[p] = m[p];
}
Object.defineProperty(exports, '__esModule', { value: true });
__export(require(318    /* ./algorithm */));
__export(require(319    /* ./array_base */));
__export(require(320    /* ./associative_array */));
__export(require(322    /* ./iterator */));
__export(require(323    /* ./pair */));},
/* kiwi/build/tsu/iterator */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
/**
* An iterator for an array of items.
*/
var ArrayIterator = function () {
    /*
    * Construct a new ArrayIterator.
    *
    * @param array The array of items to iterate.
    * @param [index] The index at which to start iteration.
    */
    function ArrayIterator(array, index) {
        if (typeof index === 'undefined') {
            index = 0;
        }
        this._array = array;
        this._index = Math.max(0, Math.min(index, array.length));
    }
    /**
    * Returns the next item from the iterator or undefined.
    */
    ArrayIterator.prototype.__next__ = function () {
        return this._array[this._index++];
    };
    /**
    * Returns this same iterator.
    */
    ArrayIterator.prototype.__iter__ = function () {
        return this;
    };
    return ArrayIterator;
}();
exports.ArrayIterator = ArrayIterator;
/**
* A reverse iterator for an array of items.
*/
var ReverseArrayIterator = function () {
    /**
    * Construct a new ReverseArrayIterator.
    *
    * @param array The array of items to iterate.
    * @param [index] The index at which to start iteration.
    */
    function ReverseArrayIterator(array, index) {
        if (typeof index === 'undefined') {
            index = array.length;
        }
        this._array = array;
        this._index = Math.max(0, Math.min(index, array.length));
    }
    /**
    * Returns the next item from the iterator or undefined.
    */
    ReverseArrayIterator.prototype.__next__ = function () {
        return this._array[--this._index];
    };
    /**
    * Returns this same iterator.
    */
    ReverseArrayIterator.prototype.__iter__ = function () {
        return this;
    };
    return ReverseArrayIterator;
}();
exports.ReverseArrayIterator = ReverseArrayIterator;
function iter(object) {
    if (object instanceof Array) {
        return new ArrayIterator(object);
    }
    return object.__iter__();
}
exports.iter = iter;
function reversed(object) {
    if (object instanceof Array) {
        return new ReverseArrayIterator(object);
    }
    return object.__reversed__();
}
exports.reversed = reversed;
/**
* Returns the next value from an iterator, or undefined.
*/
function next(iterator) {
    return iterator.__next__();
}
exports.next = next;
function asArray(object) {
    if (object instanceof Array) {
        return object.slice();
    }
    var value;
    var array = [];
    var it = object.__iter__();
    while ((value = it.__next__()) !== undefined) {
        array.push(value);
    }
    return array;
}
exports.asArray = asArray;
function forEach(object, callback) {
    if (object instanceof Array) {
        for (var i = 0, n = object.length; i < n; ++i) {
            if (callback(object[i]) === false) {
                return;
            }
        }
    } else {
        var value;
        var it = object.__iter__();
        while ((value = it.__next__()) !== undefined) {
            if (callback(value) === false) {
                return;
            }
        }
    }
}
exports.forEach = forEach;
function map(object, callback) {
    var result = [];
    if (object instanceof Array) {
        for (var i = 0, n = object.length; i < n; ++i) {
            result.push(callback(object[i]));
        }
    } else {
        var value;
        var it = object.__iter__();
        while ((value = it.__next__()) !== undefined) {
            result.push(callback(value));
        }
    }
    return result;
}
exports.map = map;
function filter(object, callback) {
    var value;
    var result = [];
    if (object instanceof Array) {
        for (var i = 0, n = object.length; i < n; ++i) {
            value = object[i];
            if (callback(value)) {
                result.push(value);
            }
        }
    } else {
        var it = object.__iter__();
        while ((value = it.__next__()) !== undefined) {
            if (callback(value)) {
                result.push(value);
            }
        }
    }
    return result;
}
exports.filter = filter;},
/* kiwi/build/tsu/pair */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
/**
* A class which defines a generic pair object.
*/
var Pair = function () {
    /**
    * Construct a new Pair object.
    *
    * @param first The first item of the pair.
    * @param second The second item of the pair.
    */
    function Pair(first, second) {
        this.first = first;
        this.second = second;
    }
    /**
    * Create a copy of the pair.
    */
    Pair.prototype.copy = function () {
        return new Pair(this.first, this.second);
    };
    return Pair;
}();
exports.Pair = Pair;},
/* kiwi/build/variable */ function(require, module, exports) {
'use strict';
/*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
Object.defineProperty(exports, '__esModule', { value: true });
/**
 * The primary user constraint variable.
 *
 * @class
 */
var Variable = function () {
    /**
     * Construct a new Variable
     *
     * @param [name] The name to associated with the variable.
     */
    function Variable(name) {
        if (name === void 0) {
            name = '';
        }
        this._value = 0;
        this._context = null;
        this._id = VarId++;
        this._name = name;
    }
    /**
     * A static variable comparison function.
     */
    Variable.Compare = function (a, b) {
        return a.id - b.id;
    };
    Variable.prototype.toString = function () {
        return this._name;
    };
    Object.defineProperty(Variable.prototype, 'id', {
        /**
         * Returns the unique id number of the variable.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Variable.prototype, 'name', {
        /**
         * Returns the name of the variable.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the name of the variable.
     */
    Variable.prototype.setName = function (name) {
        this._name = name;
    };
    Object.defineProperty(Variable.prototype, 'context', {
        /**
         * Returns the user context object of the variable.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the user context object of the variable.
     */
    Variable.prototype.setContext = function (context) {
        this._context = context;
    };
    Object.defineProperty(Variable.prototype, 'value', {
        /**
         * Returns the value of the variable.
         */
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the value of the variable.
     */
    Variable.prototype.setValue = function (value) {
        this._value = value;
    };
    return Variable;
}();
exports.Variable = Variable;
/**
 * The internal variable id counter.
 */
var VarId = 0;},
/* numbro/numbro */ function(require, module, exports) {
/*!
 * numbro.js
 * version : 1.6.2
 * author : Företagsplatsen AB
 * license : MIT
 * http://www.foretagsplatsen.se
 */
/************************************
        Constants
    ************************************/
var numbro, VERSION = '1.6.2',
    // internal storage for culture config files
    cultures = {},
    // Todo: Remove in 2.0.0
    languages = cultures, currentCulture = 'en-US', zeroFormat = null, defaultFormat = '0,0', defaultCurrencyFormat = '0$',
    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports,
    // default culture
    enUS = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$',
            position: 'prefix'
        },
        defaults: { currencyFormat: ',0000 a' },
        formats: {
            fourDigits: '0000 a',
            fullWithTwoDecimals: '$ ,0.00',
            fullWithTwoDecimalsNoCurrency: ',0.00'
        }
    };
/************************************
        Constructors
    ************************************/
// Numbro prototype object
function Numbro(number) {
    this._value = number;
}
function zeroes(count) {
    var i, ret = '';
    for (i = 0; i < count; i++) {
        ret += '0';
    }
    return ret;
}
/**
     * Implementation of toFixed() for numbers with exponent > 21
     *
     *
     */
function toFixedLarge(value, precision) {
    var mantissa, beforeDec, afterDec, exponent, str;
    str = value.toString();
    mantissa = str.split('e')[0];
    exponent = str.split('e')[1];
    beforeDec = mantissa.split('.')[0];
    afterDec = mantissa.split('.')[1] || '';
    str = beforeDec + afterDec + zeroes(exponent - afterDec.length);
    if (precision > 0) {
        str += '.' + zeroes(precision);
    }
    return str;
}
/**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
function toFixed(value, precision, roundingFunction, optionals) {
    var power = Math.pow(10, precision), optionalsRegExp, output;
    if (value.toFixed(0).search('e') > -1) {
        // Above 1e21, toFixed returns scientific notation, which
        // is useless and unexpected
        output = toFixedLarge(value, precision);
    } else {
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);
    }
    if (optionals) {
        optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
        output = output.replace(optionalsRegExp, '');
    }
    return output;
}
/************************************
        Formatting
    ************************************/
// determine what type of formatting we need to do
function formatNumbro(value, format, roundingFunction) {
    var output;
    // TODO: do something with `language`
    // figure out what kind of format we are dealing with
    if (format.indexOf('$') > -1) {
        // currency!!!!!
        output = formatCurrency(value, format, roundingFunction);
    } else if (format.indexOf('%') > -1) {
        // percentage
        output = formatPercentage(value, format, roundingFunction);
    } else if (format.indexOf(':') > -1) {
        // time
        output = formatTime(value);
    } else {
        // plain ol' numbers or bytes
        output = formatNumber(value, format, roundingFunction);
    }
    // return string
    return output;
}
function formatCurrency(value, originalFormat, roundingFunction) {
    var format = originalFormat, symbolIndex = format.indexOf('$'), openParenIndex = format.indexOf('('), plusSignIndex = format.indexOf('+'), minusSignIndex = format.indexOf('-'), space = '', decimalSeparator = '', spliceIndex, output;
    if (format.indexOf('$') === -1) {
        // Use defaults instead of the format provided
        if (cultures[currentCulture].currency.position === 'infix') {
            decimalSeparator = cultures[currentCulture].currency.symbol;
            if (cultures[currentCulture].currency.spaceSeparated) {
                decimalSeparator = ' ' + decimalSeparator + ' ';
            }
        } else if (cultures[currentCulture].currency.spaceSeparated) {
            space = ' ';
        }
    } else {
        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }
    }
    // Format The Number
    output = formatNumber(value, format, roundingFunction, decimalSeparator);
    if (originalFormat.indexOf('$') === -1) {
        // Use defaults instead of the format provided
        switch (cultures[currentCulture].currency.position) {
        case 'postfix':
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + cultures[currentCulture].currency.symbol;
            }
            break;
        case 'infix':
            break;
        case 'prefix':
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;
                output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
                output = output.join('');
            } else {
                output = cultures[currentCulture].currency.symbol + space + output;
            }
            break;
        default:
            throw Error('Currency position should be among ["prefix", "infix", "postfix"]');
        }
    } else {
        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(", "+" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
                output = output.join('');
            } else {
                output = cultures[currentCulture].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + cultures[currentCulture].currency.symbol;
            }
        }
    }
    return output;
}
function formatPercentage(value, format, roundingFunction) {
    var space = '', output;
    value = value * 100;
    // check for space before %
    if (format.indexOf(' %') > -1) {
        space = ' ';
        format = format.replace(' %', '');
    } else {
        format = format.replace('%', '');
    }
    output = formatNumber(value, format, roundingFunction);
    if (output.indexOf(')') > -1) {
        output = output.split('');
        output.splice(-1, 0, space + '%');
        output = output.join('');
    } else {
        output = output + space + '%';
    }
    return output;
}
function formatTime(value) {
    var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
    return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
}
function formatNumber(value, format, roundingFunction, sep) {
    var negP = false, signed = false, optDec = false, abbr = '', i, abbrK = false,
        // force abbreviation to thousands
        abbrM = false,
        // force abbreviation to millions
        abbrB = false,
        // force abbreviation to billions
        abbrT = false,
        // force abbreviation to trillions
        abbrForce = false,
        // force abbreviation
        bytes = '', ord = '', abs = Math.abs(value), binarySuffixes = [
            'B',
            'KiB',
            'MiB',
            'GiB',
            'TiB',
            'PiB',
            'EiB',
            'ZiB',
            'YiB'
        ], decimalSuffixes = [
            'B',
            'KB',
            'MB',
            'GB',
            'TB',
            'PB',
            'EB',
            'ZB',
            'YB'
        ], min, max, power, totalLength, length, minimumPrecision, pow, w, intPrecision, precision, prefix, postfix, thousands, d = '', forcedNeg = false, neg = false, indexOpenP, size, indexMinus, paren = '', minlen;
    // check if number is zero and a custom zero format has been set
    if (value === 0 && zeroFormat !== null) {
        return zeroFormat;
    }
    if (!isFinite(value)) {
        return '' + value;
    }
    if (format.indexOf('{') === 0) {
        var end = format.indexOf('}');
        if (end === -1) {
            throw Error('Format should also contain a "}"');
        }
        prefix = format.slice(1, end);
        format = format.slice(end + 1);
    } else {
        prefix = '';
    }
    if (format.indexOf('}') === format.length - 1) {
        var start = format.indexOf('{');
        if (start === -1) {
            throw Error('Format should also contain a "{"');
        }
        postfix = format.slice(start + 1, -1);
        format = format.slice(0, start + 1);
    } else {
        postfix = '';
    }
    // check for min length
    var info;
    if (format.indexOf('.') === -1) {
        info = format.match(/([0-9]+).*/);
    } else {
        info = format.match(/([0-9]+)\..*/);
    }
    minlen = info === null ? -1 : info[1].length;
    // see if we should use parentheses for negative number or if we should prefix with a sign
    // if both are present we default to parentheses
    if (format.indexOf('-') !== -1) {
        forcedNeg = true;
    }
    if (format.indexOf('(') > -1) {
        negP = true;
        format = format.slice(1, -1);
    } else if (format.indexOf('+') > -1) {
        signed = true;
        format = format.replace(/\+/g, '');
    }
    // see if abbreviation is wanted
    if (format.indexOf('a') > -1) {
        intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];
        intPrecision = parseInt(intPrecision[0], 10);
        // check if abbreviation is specified
        abbrK = format.indexOf('aK') >= 0;
        abbrM = format.indexOf('aM') >= 0;
        abbrB = format.indexOf('aB') >= 0;
        abbrT = format.indexOf('aT') >= 0;
        abbrForce = abbrK || abbrM || abbrB || abbrT;
        // check for space before abbreviation
        if (format.indexOf(' a') > -1) {
            abbr = ' ';
            format = format.replace(' a', '');
        } else {
            format = format.replace('a', '');
        }
        totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;
        minimumPrecision = totalLength % 3;
        minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;
        if (intPrecision && abs !== 0) {
            length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;
            pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);
            abs = abs / Math.pow(10, pow);
            if (format.indexOf('.') === -1 && intPrecision > 3) {
                format += '[.]';
                size = length === 0 ? 0 : 3 * ~~(length / 3) - length;
                size = size < 0 ? size + 3 : size;
                for (i = 0; i < size; i++) {
                    format += '0';
                }
            }
        }
        if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {
            if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                // trillion
                abbr = abbr + cultures[currentCulture].abbreviations.trillion;
                value = value / Math.pow(10, 12);
            } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                // billion
                abbr = abbr + cultures[currentCulture].abbreviations.billion;
                value = value / Math.pow(10, 9);
            } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                // million
                abbr = abbr + cultures[currentCulture].abbreviations.million;
                value = value / Math.pow(10, 6);
            } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                // thousand
                abbr = abbr + cultures[currentCulture].abbreviations.thousand;
                value = value / Math.pow(10, 3);
            }
        }
    }
    // see if we are formatting binary bytes
    if (format.indexOf('b') > -1) {
        // check for space before
        if (format.indexOf(' b') > -1) {
            bytes = ' ';
            format = format.replace(' b', '');
        } else {
            format = format.replace('b', '');
        }
        for (power = 0; power <= binarySuffixes.length; power++) {
            min = Math.pow(1024, power);
            max = Math.pow(1024, power + 1);
            if (value >= min && value < max) {
                bytes = bytes + binarySuffixes[power];
                if (min > 0) {
                    value = value / min;
                }
                break;
            }
        }
    }
    // see if we are formatting decimal bytes
    if (format.indexOf('d') > -1) {
        // check for space before
        if (format.indexOf(' d') > -1) {
            bytes = ' ';
            format = format.replace(' d', '');
        } else {
            format = format.replace('d', '');
        }
        for (power = 0; power <= decimalSuffixes.length; power++) {
            min = Math.pow(1000, power);
            max = Math.pow(1000, power + 1);
            if (value >= min && value < max) {
                bytes = bytes + decimalSuffixes[power];
                if (min > 0) {
                    value = value / min;
                }
                break;
            }
        }
    }
    // see if ordinal is wanted
    if (format.indexOf('o') > -1) {
        // check for space before
        if (format.indexOf(' o') > -1) {
            ord = ' ';
            format = format.replace(' o', '');
        } else {
            format = format.replace('o', '');
        }
        if (cultures[currentCulture].ordinal) {
            ord = ord + cultures[currentCulture].ordinal(value);
        }
    }
    if (format.indexOf('[.]') > -1) {
        optDec = true;
        format = format.replace('[.]', '.');
    }
    w = value.toString().split('.')[0];
    precision = format.split('.')[1];
    thousands = format.indexOf(',');
    if (precision) {
        if (precision.indexOf('*') !== -1) {
            d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);
        } else {
            if (precision.indexOf('[') > -1) {
                precision = precision.replace(']', '');
                precision = precision.split('[');
                d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            } else {
                d = toFixed(value, precision.length, roundingFunction);
            }
        }
        w = d.split('.')[0];
        if (d.split('.')[1].length) {
            var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;
            d = p + d.split('.')[1];
        } else {
            d = '';
        }
        if (optDec && Number(d.slice(1)) === 0) {
            d = '';
        }
    } else {
        w = toFixed(value, null, roundingFunction);
    }
    // format number
    if (w.indexOf('-') > -1) {
        w = w.slice(1);
        neg = true;
    }
    if (w.length < minlen) {
        w = new Array(minlen - w.length + 1).join('0') + w;
    }
    if (thousands > -1) {
        w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + cultures[currentCulture].delimiters.thousands);
    }
    if (format.indexOf('.') === 0) {
        w = '';
    }
    indexOpenP = format.indexOf('(');
    indexMinus = format.indexOf('-');
    if (indexOpenP < indexMinus) {
        paren = (negP && neg ? '(' : '') + (forcedNeg && neg || !negP && neg ? '-' : '');
    } else {
        paren = (forcedNeg && neg || !negP && neg ? '-' : '') + (negP && neg ? '(' : '');
    }
    return prefix + paren + (!neg && signed && value !== 0 ? '+' : '') + w + d + (ord ? ord : '') + (abbr && !sep ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '') + postfix;
}
/************************************
        Top Level Functions
    ************************************/
numbro = function (input) {
    if (numbro.isNumbro(input)) {
        input = input.value();
    } else if (input === 0 || typeof input === 'undefined') {
        input = 0;
    } else if (!Number(input)) {
        input = numbro.fn.unformat(input);
    }
    return new Numbro(Number(input));
};
// version number
numbro.version = VERSION;
// compare numbro object
numbro.isNumbro = function (obj) {
    return obj instanceof Numbro;
};
/**
     * This function allow the user to set a new language with a fallback if
     * the language does not exist. If no fallback language is provided,
     * it fallbacks to english.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `setCulture` should be used instead.
     */
numbro.setLanguage = function (newLanguage, fallbackLanguage) {
    console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');
    var key = newLanguage, prefix = newLanguage.split('-')[0], matchingLanguage = null;
    if (!languages[key]) {
        Object.keys(languages).forEach(function (language) {
            if (!matchingLanguage && language.split('-')[0] === prefix) {
                matchingLanguage = language;
            }
        });
        key = matchingLanguage || fallbackLanguage || 'en-US';
    }
    chooseCulture(key);
};
/**
     * This function allow the user to set a new culture with a fallback if
     * the culture does not exist. If no fallback culture is provided,
     * it fallbacks to "en-US".
     */
numbro.setCulture = function (newCulture, fallbackCulture) {
    var key = newCulture, suffix = newCulture.split('-')[1], matchingCulture = null;
    if (!cultures[key]) {
        if (suffix) {
            Object.keys(cultures).forEach(function (language) {
                if (!matchingCulture && language.split('-')[1] === suffix) {
                    matchingCulture = language;
                }
            });
        }
        key = matchingCulture || fallbackCulture || 'en-US';
    }
    chooseCulture(key);
};
/**
     * This function will load languages and then set the global language.  If
     * no arguments are passed in, it will simply return the current global
     * language key.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `culture` should be used instead.
     */
numbro.language = function (key, values) {
    console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');
    if (!key) {
        return currentCulture;
    }
    if (key && !values) {
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        chooseCulture(key);
    }
    if (values || !languages[key]) {
        setCulture(key, values);
    }
    return numbro;
};
/**
     * This function will load cultures and then set the global culture.  If
     * no arguments are passed in, it will simply return the current global
     * culture code.
     */
numbro.culture = function (code, values) {
    if (!code) {
        return currentCulture;
    }
    if (code && !values) {
        if (!cultures[code]) {
            throw new Error('Unknown culture : ' + code);
        }
        chooseCulture(code);
    }
    if (values || !cultures[code]) {
        setCulture(code, values);
    }
    return numbro;
};
/**
     * This function provides access to the loaded language data.  If
     * no arguments are passed in, it will simply return the current
     * global language object.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `culture` should be used instead.
     */
numbro.languageData = function (key) {
    console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');
    if (!key) {
        return languages[currentCulture];
    }
    if (!languages[key]) {
        throw new Error('Unknown language : ' + key);
    }
    return languages[key];
};
/**
     * This function provides access to the loaded culture data.  If
     * no arguments are passed in, it will simply return the current
     * global culture object.
     */
numbro.cultureData = function (code) {
    if (!code) {
        return cultures[currentCulture];
    }
    if (!cultures[code]) {
        throw new Error('Unknown culture : ' + code);
    }
    return cultures[code];
};
numbro.culture('en-US', enUS);
/**
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `cultures` should be used instead.
     */
numbro.languages = function () {
    console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');
    return languages;
};
numbro.cultures = function () {
    return cultures;
};
numbro.zeroFormat = function (format) {
    zeroFormat = typeof format === 'string' ? format : null;
};
numbro.defaultFormat = function (format) {
    defaultFormat = typeof format === 'string' ? format : '0.0';
};
numbro.defaultCurrencyFormat = function (format) {
    defaultCurrencyFormat = typeof format === 'string' ? format : '0$';
};
numbro.validate = function (val, culture) {
    var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp;
    //coerce val to string
    if (typeof val !== 'string') {
        val += '';
        if (console.warn) {
            console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);
        }
    }
    //trim whitespaces from either sides
    val = val.trim();
    //if val is just digits return true
    if (!!val.match(/^\d+$/)) {
        return true;
    }
    //if val is empty return false
    if (val === '') {
        return false;
    }
    //get the decimal and thousands separator from numbro.cultureData
    try {
        //check if the culture is understood by numbro. if not, default it to current culture
        cultureData = numbro.cultureData(culture);
    } catch (e) {
        cultureData = numbro.cultureData(numbro.culture());
    }
    //setup the delimiters and currency symbol based on culture
    _currSymbol = cultureData.currency.symbol;
    _abbrObj = cultureData.abbreviations;
    _decimalSep = cultureData.delimiters.decimal;
    if (cultureData.delimiters.thousands === '.') {
        _thousandSep = '\\.';
    } else {
        _thousandSep = cultureData.delimiters.thousands;
    }
    // validating currency symbol
    temp = val.match(/^[^\d]+/);
    if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
            return false;
        }
    }
    //validating abbreviation symbol
    temp = val.match(/[^\d]+$/);
    if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
            return false;
        }
    }
    _thousandRegEx = new RegExp(_thousandSep + '{2}');
    if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length > 2) {
            return false;
        } else {
            if (_valArray.length < 2) {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            } else {
                if (_valArray[0].length === 1) {
                    return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                } else {
                    return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                }
            }
        }
    }
    return false;
};
/************************************
        Helpers
    ************************************/
function setCulture(code, values) {
    cultures[code] = values;
}
function chooseCulture(code) {
    currentCulture = code;
    var defaults = cultures[code].defaults;
    if (defaults && defaults.format) {
        numbro.defaultFormat(defaults.format);
    }
    if (defaults && defaults.currencyFormat) {
        numbro.defaultCurrencyFormat(defaults.currencyFormat);
    }
}
function format(input, formatString, language, roundingFunction) {
    if (language != null && language !== numbro.culture()) {
        numbro.setCulture(language);
    }
    return formatNumbro(Number(input), formatString != null ? formatString : defaultFormat, roundingFunction == null ? Math.round : roundingFunction);
}
module.exports = { 'format': format };},
/* proj4/lib/Proj */ function(require, module, exports) {
var parseCode = require(346    /* ./parseCode */);
var extend = require(344    /* ./extend */);
var projections = require(348    /* ./projections */);
var deriveConstants = require(343    /* ./deriveConstants */);
var Datum = require(334    /* ./constants/Datum */);
var datum = require(339    /* ./datum */);
function Projection(srsCode, callback) {
    if (!(this instanceof Projection)) {
        return new Projection(srsCode);
    }
    callback = callback || function (error) {
        if (error) {
            throw error;
        }
    };
    var json = parseCode(srsCode);
    if (typeof json !== 'object') {
        callback(srsCode);
        return;
    }
    var ourProj = Projection.projections.get(json.projName);
    if (!ourProj) {
        callback(srsCode);
        return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
        var datumDef = Datum[json.datumCode];
        if (datumDef) {
            json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
            json.ellps = datumDef.ellipse;
            json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
        }
    }
    json.k0 = json.k0 || 1;
    json.axis = json.axis || 'enu';
    var sphere = deriveConstants.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = deriveConstants.eccentricity(sphere.a, sphere.b, sphere.rf, json.R_A);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere.a, sphere.b, ecc.es, ecc.ep2);
    extend(this, json);
    // transfer everything over from the projection because we don't know what we'll need
    extend(this, ourProj);
    // transfer all the methods from the projection
    // copy the 4 things over we calulated in deriveConstants.sphere
    this.a = sphere.a;
    this.b = sphere.b;
    this.rf = sphere.rf;
    this.sphere = sphere.sphere;
    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;
    // add in the datum object
    this.datum = datumObj;
    // init the projection
    this.init();
    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);
}
Projection.projections = projections;
Projection.projections.start();
module.exports = Projection;},
/* proj4/lib/adjust_axis */ function(require, module, exports) {
module.exports = function (crs, denorm, point) {
    var xin = point.x, yin = point.y, zin = point.z || 0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
        if (denorm && i === 2 && point.z === undefined) {
            continue;
        }
        if (i === 0) {
            v = xin;
            t = 'x';
        } else if (i === 1) {
            v = yin;
            t = 'y';
        } else {
            v = zin;
            t = 'z';
        }
        switch (crs.axis[i]) {
        case 'e':
            out[t] = v;
            break;
        case 'w':
            out[t] = -v;
            break;
        case 'n':
            out[t] = v;
            break;
        case 's':
            out[t] = -v;
            break;
        case 'u':
            if (point[t] !== undefined) {
                out.z = v;
            }
            break;
        case 'd':
            if (point[t] !== undefined) {
                out.z = -v;
            }
            break;
        default:
            //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
            return null;
        }
    }
    return out;
};},
/* proj4/lib/common/adjust_lon */ function(require, module, exports) {
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;
var sign = require(331    /* ./sign */);
module.exports = function (x) {
    return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
};},
/* proj4/lib/common/msfnz */ function(require, module, exports) {
module.exports = function (eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / Math.sqrt(1 - con * con);
};},
/* proj4/lib/common/phi2z */ function(require, module, exports) {
var HALF_PI = Math.PI / 2;
module.exports = function (eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 1e-10) {
            return phi;
        }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
};},
/* proj4/lib/common/sign */ function(require, module, exports) {
module.exports = function (x) {
    return x < 0 ? -1 : 1;
};},
/* proj4/lib/common/toPoint */ function(require, module, exports) {
module.exports = function (array) {
    var out = {
        x: array[0],
        y: array[1]
    };
    if (array.length > 2) {
        out.z = array[2];
    }
    if (array.length > 3) {
        out.m = array[3];
    }
    return out;
};},
/* proj4/lib/common/tsfnz */ function(require, module, exports) {
var HALF_PI = Math.PI / 2;
module.exports = function (eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow((1 - con) / (1 + con), com);
    return Math.tan(0.5 * (HALF_PI - phi)) / con;
};},
/* proj4/lib/constants/Datum */ function(require, module, exports) {
exports.wgs84 = {
    towgs84: '0,0,0',
    ellipse: 'WGS84',
    datumName: 'WGS84'
};
exports.ch1903 = {
    towgs84: '674.374,15.056,405.346',
    ellipse: 'bessel',
    datumName: 'swiss'
};
exports.ggrs87 = {
    towgs84: '-199.87,74.79,246.62',
    ellipse: 'GRS80',
    datumName: 'Greek_Geodetic_Reference_System_1987'
};
exports.nad83 = {
    towgs84: '0,0,0',
    ellipse: 'GRS80',
    datumName: 'North_American_Datum_1983'
};
exports.nad27 = {
    nadgrids: '@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat',
    ellipse: 'clrk66',
    datumName: 'North_American_Datum_1927'
};
exports.potsdam = {
    towgs84: '606.0,23.0,413.0',
    ellipse: 'bessel',
    datumName: 'Potsdam Rauenberg 1950 DHDN'
};
exports.carthage = {
    towgs84: '-263.0,6.0,431.0',
    ellipse: 'clark80',
    datumName: 'Carthage 1934 Tunisia'
};
exports.hermannskogel = {
    towgs84: '653.0,-212.0,449.0',
    ellipse: 'bessel',
    datumName: 'Hermannskogel'
};
exports.ire65 = {
    towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
    ellipse: 'mod_airy',
    datumName: 'Ireland 1965'
};
exports.rassadiran = {
    towgs84: '-133.63,-157.5,-158.62',
    ellipse: 'intl',
    datumName: 'Rassadiran'
};
exports.nzgd49 = {
    towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993',
    ellipse: 'intl',
    datumName: 'New Zealand Geodetic Datum 1949'
};
exports.osgb36 = {
    towgs84: '446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894',
    ellipse: 'airy',
    datumName: 'Airy 1830'
};
exports.s_jtsk = {
    towgs84: '589,76,480',
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
};
exports.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
};
exports.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
};
exports.rnb72 = {
    towgs84: '106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1',
    ellipse: 'intl',
    datumName: 'Reseau National Belge 1972'
};},
/* proj4/lib/constants/Ellipsoid */ function(require, module, exports) {
exports.MERIT = {
    a: 6378137,
    rf: 298.257,
    ellipseName: 'MERIT 1983'
};
exports.SGS85 = {
    a: 6378136,
    rf: 298.257,
    ellipseName: 'Soviet Geodetic System 85'
};
exports.GRS80 = {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: 'GRS 1980(IUGG, 1980)'
};
exports.IAU76 = {
    a: 6378140,
    rf: 298.257,
    ellipseName: 'IAU 1976'
};
exports.airy = {
    a: 6377563.396,
    b: 6356256.91,
    ellipseName: 'Airy 1830'
};
exports.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: 'Appl. Physics. 1965'
};
exports.NWL9D = {
    a: 6378145,
    rf: 298.25,
    ellipseName: 'Naval Weapons Lab., 1965'
};
exports.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: 'Modified Airy'
};
exports.andrae = {
    a: 6377104.43,
    rf: 300,
    ellipseName: 'Andrae 1876 (Den., Iclnd.)'
};
exports.aust_SA = {
    a: 6378160,
    rf: 298.25,
    ellipseName: 'Australian Natl & S. Amer. 1969'
};
exports.GRS67 = {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: 'GRS 67(IUGG 1967)'
};
exports.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: 'Bessel 1841'
};
exports.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: 'Bessel 1841 (Namibia)'
};
exports.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: 'Clarke 1866'
};
exports.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: 'Clarke 1880 mod.'
};
exports.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: 'Clarke 1858'
};
exports.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: 'Comm. des Poids et Mesures 1799'
};
exports.delmbr = {
    a: 6376428,
    rf: 311.5,
    ellipseName: 'Delambre 1810 (Belgium)'
};
exports.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: 'Engelis 1985'
};
exports.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: 'Everest 1830'
};
exports.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: 'Everest 1948'
};
exports.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: 'Everest 1956'
};
exports.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: 'Everest 1969'
};
exports.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: 'Everest (Sabah & Sarawak)'
};
exports.fschr60 = {
    a: 6378166,
    rf: 298.3,
    ellipseName: 'Fischer (Mercury Datum) 1960'
};
exports.fschr60m = {
    a: 6378155,
    rf: 298.3,
    ellipseName: 'Fischer 1960'
};
exports.fschr68 = {
    a: 6378150,
    rf: 298.3,
    ellipseName: 'Fischer 1968'
};
exports.helmert = {
    a: 6378200,
    rf: 298.3,
    ellipseName: 'Helmert 1906'
};
exports.hough = {
    a: 6378270,
    rf: 297,
    ellipseName: 'Hough'
};
exports.intl = {
    a: 6378388,
    rf: 297,
    ellipseName: 'International 1909 (Hayford)'
};
exports.kaula = {
    a: 6378163,
    rf: 298.24,
    ellipseName: 'Kaula 1961'
};
exports.lerch = {
    a: 6378139,
    rf: 298.257,
    ellipseName: 'Lerch 1979'
};
exports.mprts = {
    a: 6397300,
    rf: 191,
    ellipseName: 'Maupertius 1738'
};
exports.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: 'New International 1967'
};
exports.plessis = {
    a: 6376523,
    rf: 6355863,
    ellipseName: 'Plessis 1817 (France)'
};
exports.krass = {
    a: 6378245,
    rf: 298.3,
    ellipseName: 'Krassovsky, 1942'
};
exports.SEasia = {
    a: 6378155,
    b: 6356773.3205,
    ellipseName: 'Southeast Asia'
};
exports.walbeck = {
    a: 6376896,
    b: 6355834.8467,
    ellipseName: 'Walbeck'
};
exports.WGS60 = {
    a: 6378165,
    rf: 298.3,
    ellipseName: 'WGS 60'
};
exports.WGS66 = {
    a: 6378145,
    rf: 298.25,
    ellipseName: 'WGS 66'
};
exports.WGS7 = {
    a: 6378135,
    rf: 298.26,
    ellipseName: 'WGS 72'
};
exports.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: 'WGS 84'
};
exports.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: 'Normal Sphere (r=6370997)'
};},
/* proj4/lib/constants/PrimeMeridian */ function(require, module, exports) {
exports.greenwich = 0;
//"0dE",
exports.lisbon = -9.131906111111;
//"9d07'54.862\"W",
exports.paris = 2.337229166667;
//"2d20'14.025\"E",
exports.bogota = -74.080916666667;
//"74d04'51.3\"W",
exports.madrid = -3.687938888889;
//"3d41'16.58\"W",
exports.rome = 12.452333333333;
//"12d27'8.4\"E",
exports.bern = 7.439583333333;
//"7d26'22.5\"E",
exports.jakarta = 106.807719444444;
//"106d48'27.79\"E",
exports.ferro = -17.666666666667;
//"17d40'W",
exports.brussels = 4.367975;
//"4d22'4.71\"E",
exports.stockholm = 18.058277777778;
//"18d3'29.8\"E",
exports.athens = 23.7163375;
//"23d42'58.815\"E",
exports.oslo = 10.722916666667;    //"10d43'22.5\"E"
},
/* proj4/lib/constants/units */ function(require, module, exports) {
exports.ft = { to_meter: 0.3048 };
exports['us-ft'] = { to_meter: 1200 / 3937 };},
/* proj4/lib/core */ function(require, module, exports) {
var proj = require(326    /* ./Proj */);
var transform = require(351    /* ./transform */);
var wgs84 = proj('WGS84');
function transformer(from, to, coords) {
    var transformedArray;
    if (Array.isArray(coords)) {
        transformedArray = transform(from, to, coords);
        if (coords.length === 3) {
            return [
                transformedArray.x,
                transformedArray.y,
                transformedArray.z
            ];
        } else {
            return [
                transformedArray.x,
                transformedArray.y
            ];
        }
    } else {
        return transform(from, to, coords);
    }
}
function checkProj(item) {
    if (item instanceof proj) {
        return item;
    }
    if (item.oProj) {
        return item.oProj;
    }
    return proj(item);
}
function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
        coord = toProj;
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
        return transformer(fromProj, toProj, coord);
    } else {
        obj = {
            forward: function (coords) {
                return transformer(fromProj, toProj, coords);
            },
            inverse: function (coords) {
                return transformer(toProj, fromProj, coords);
            }
        };
        if (single) {
            obj.oProj = toProj;
        }
        return obj;
    }
}
module.exports = proj4;},
/* proj4/lib/datum */ function(require, module, exports) {
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4;
// WGS84 or equivalent
var PJD_NODATUM = 5;
// WGS84 or equivalent
var SEC_TO_RAD = 0.00000484813681109536;
function datum(datumCode, datum_params, a, b, es, ep2) {
    var out = {};
    out.datum_type = PJD_WGS84;
    //default setting
    if (datumCode && datumCode === 'none') {
        out.datum_type = PJD_NODATUM;
    }
    if (datum_params) {
        out.datum_params = datum_params.map(parseFloat);
        if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
            out.datum_type = PJD_3PARAM;
        }
        if (out.datum_params.length > 3) {
            if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
                out.datum_type = PJD_7PARAM;
                out.datum_params[3] *= SEC_TO_RAD;
                out.datum_params[4] *= SEC_TO_RAD;
                out.datum_params[5] *= SEC_TO_RAD;
                out.datum_params[6] = out.datum_params[6] / 1000000 + 1;
            }
        }
    }
    out.a = a;
    //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
}
module.exports = datum;},
/* proj4/lib/datumUtils */ function(require, module, exports) {
'use strict';
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var HALF_PI = Math.PI / 2;
exports.compareDatums = function (source, dest) {
    if (source.datum_type !== dest.datum_type) {
        return false;    // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(this.es - dest.es) > 5e-11) {
        // the tolerence for es is to ensure that GRS80 and WGS84
        // are considered identical
        return false;
    } else if (source.datum_type === PJD_3PARAM) {
        return this.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
    } else if (source.datum_type === PJD_7PARAM) {
        return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
    } else {
        return true;    // datums are equal
    }
};
// cs_compare_datums()
/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
exports.geodeticToGeocentric = function (p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0;
    //Z value not always supplied
    var Rn;
    /*  Earth radius at location  */
    var Sin_Lat;
    /*  Math.sin(Latitude)  */
    var Sin2_Lat;
    /*  Square of Math.sin(Latitude)  */
    var Cos_Lat;
    /*  Math.cos(Latitude)  */
    /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
        Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
        Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI || Latitude > HALF_PI) {
        /* Latitude out of range */
        //..reportError('geocent:lat out of range:' + Latitude);
        return null;
    }
    if (Longitude > Math.PI) {
        Longitude -= 2 * Math.PI;
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / Math.sqrt(1 - es * Sin2_Lat);
    return {
        x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
        y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
        z: (Rn * (1 - es) + Height) * Sin_Lat
    };
};
// cs_geodetic_to_geocentric()
exports.geocentricToGeodetic = function (p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = genau * genau;
    var maxiter = 30;
    var P;
    /* distance between semi-minor axis and location */
    var RR;
    /* distance between center and location */
    var CT;
    /* sin of geocentric latitude */
    var ST;
    /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN;
    /* Earth radius at location */
    var CPHI0;
    /* cos of start or old geodetic latitude in iterations */
    var SPHI0;
    /* sin of start or old geodetic latitude in iterations */
    var CPHI;
    /* cos of searched geodetic latitude */
    var SPHI;
    /* sin of searched geodetic latitude */
    var SDPHI;
    /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter;
    /* # of continous iteration, max. 30 is always enough (s.a.) */
    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0;
    //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);
    /*      special cases for latitude and longitude */
    if (P / a < genau) {
        /*  special case, if P=0. (X=0., Y=0.) */
        Longitude = 0;
        /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
        if (RR / a < genau) {
            Latitude = HALF_PI;
            Height = -b;
            return {
                x: p.x,
                y: p.y,
                z: p.z
            };
        }
    } else {
        /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
        Longitude = Math.atan2(Y, X);
    }
    /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
    CT = Z / RR;
    ST = P / RR;
    RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
    CPHI0 = ST * (1 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;
    /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
        iter++;
        RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
        /*  ellipsoidal (geodetic) height */
        Height = P * CPHI0 + Z * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
        RK = es * RN / (RN + Height);
        RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
        CPHI = ST * (1 - RK) * RX;
        SPHI = CT * RX;
        SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
        CPHI0 = CPHI;
        SPHI0 = SPHI;
    } while (SDPHI * SDPHI > genau2 && iter < maxiter);
    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
        x: Longitude,
        y: Latitude,
        z: Height
    };
};
// cs_geocentric_to_geodetic()
/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)
/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
exports.geocentricToWgs84 = function (p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
            x: p.x + datum_params[0],
            y: p.y + datum_params[1],
            z: p.z + datum_params[2]
        };
    } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
            x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
            y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
            z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
        };
    }
};
// cs_geocentric_to_wgs84
/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
exports.geocentricFromWgs84 = function (p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
        //if( x[io] === HUGE_VAL )
        //    continue;
        return {
            x: p.x - datum_params[0],
            y: p.y - datum_params[1],
            z: p.z - datum_params[2]
        };
    } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        var x_tmp = (p.x - Dx_BF) / M_BF;
        var y_tmp = (p.y - Dy_BF) / M_BF;
        var z_tmp = (p.z - Dz_BF) / M_BF;
        //if( x[io] === HUGE_VAL )
        //    continue;
        return {
            x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
            y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
            z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
        };
    }    //cs_geocentric_from_wgs84()
};},
/* proj4/lib/datum_transform */ function(require, module, exports) {
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_NODATUM = 5;
// WGS84 or equivalent
var datum = require(340    /* ./datumUtils */);
function checkParams(type) {
    return type === PJD_3PARAM || type === PJD_7PARAM;
}
module.exports = function (source, dest, point) {
    // Short cut if the datums are identical.
    if (datum.compareDatums(source, dest)) {
        return point;    // in this case, zero is sucess,
                         // whereas cs_compare_datums returns 1 to indicate TRUE
                         // confusing, should fix this
    }
    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
        return point;
    }
    // If this datum requires grid shifts, then apply it to geodetic coordinates.
    // Do we need to go through geocentric coordinates?
    if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
        return point;
    }
    // Convert to geocentric coordinates.
    point = datum.geodeticToGeocentric(point, source.es, source.a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
        point = datum.geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
        point = datum.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    return datum.geocentricToGeodetic(point, dest.es, dest.a, dest.b);
};},
/* proj4/lib/defs */ function(require, module, exports) {
var globals = require(345    /* ./global */);
var parseProj = require(347    /* ./projString */);
var wkt = require(352    /* ./wkt */);
function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
        var def = arguments[1];
        if (typeof def === 'string') {
            if (def.charAt(0) === '+') {
                defs[name] = parseProj(arguments[1]);
            } else {
                defs[name] = wkt(arguments[1]);
            }
        } else {
            defs[name] = def;
        }
    } else if (arguments.length === 1) {
        if (Array.isArray(name)) {
            return name.map(function (v) {
                if (Array.isArray(v)) {
                    defs.apply(that, v);
                } else {
                    defs(v);
                }
            });
        } else if (typeof name === 'string') {
            if (name in defs) {
                return defs[name];
            }
        } else if ('EPSG' in name) {
            defs['EPSG:' + name.EPSG] = name;
        } else if ('ESRI' in name) {
            defs['ESRI:' + name.ESRI] = name;
        } else if ('IAU2000' in name) {
            defs['IAU2000:' + name.IAU2000] = name;
        } else {
            console.log(name);
        }
        return;
    }
}
globals(defs);
module.exports = defs;},
/* proj4/lib/deriveConstants */ function(require, module, exports) {
// ellipoid pj_set_ell.c
var SIXTH = 0.16666666666666666;
/* 1/6 */
var RA4 = 0.04722222222222222;
/* 17/360 */
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var Ellipsoid = require(335    /* ./constants/Ellipsoid */);
exports.eccentricity = function (a, b, rf, R_A) {
    var a2 = a * a;
    // used in geocentric
    var b2 = b * b;
    // used in geocentric
    var es = (a2 - b2) / a2;
    // e ^ 2
    var e = 0;
    if (R_A) {
        a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
        a2 = a * a;
        es = 0;
    } else {
        e = Math.sqrt(es);    // eccentricity
    }
    var ep2 = (a2 - b2) / b2;
    // used in geocentric
    return {
        es: es,
        e: e,
        ep2: ep2
    };
};
exports.sphere = function (a, b, rf, ellps, sphere) {
    if (!a) {
        // do we have an ellipsoid?
        var ellipse = Ellipsoid[ellps];
        if (!ellipse) {
            ellipse = Ellipsoid.WGS84;
        }
        a = ellipse.a;
        b = ellipse.b;
        rf = ellipse.rf;
    }
    if (rf && !b) {
        b = (1 - 1 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
        sphere = true;
        b = a;
    }
    return {
        a: a,
        b: b,
        rf: rf,
        sphere: sphere
    };
};},
/* proj4/lib/extend */ function(require, module, exports) {
module.exports = function (destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
        return destination;
    }
    for (property in source) {
        value = source[property];
        if (value !== undefined) {
            destination[property] = value;
        }
    }
    return destination;
};},
/* proj4/lib/global */ function(require, module, exports) {
module.exports = function (defs) {
    defs('EPSG:4326', '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees');
    defs('EPSG:4269', '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees');
    defs('EPSG:3857', '+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs');
    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857'];
    // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
};},
/* proj4/lib/parseCode */ function(require, module, exports) {
var defs = require(342    /* ./defs */);
var wkt = require(352    /* ./wkt */);
var projStr = require(347    /* ./projString */);
function testObj(code) {
    return typeof code === 'string';
}
function testDef(code) {
    return code in defs;
}
var codeWords = [
    'GEOGCS',
    'GEOCCS',
    'PROJCS',
    'LOCAL_CS'
];
function testWKT(code) {
    return codeWords.some(function (word) {
        return code.indexOf(word) > -1;
    });
}
function testProj(code) {
    return code[0] === '+';
}
function parse(code) {
    if (testObj(code)) {
        //check to see if this is a WKT string
        if (testDef(code)) {
            return defs[code];
        }
        if (testWKT(code)) {
            return wkt(code);
        }
        if (testProj(code)) {
            return projStr(code);
        }
    } else {
        return code;
    }
}
module.exports = parse;},
/* proj4/lib/projString */ function(require, module, exports) {
var D2R = 0.017453292519943295;
var PrimeMeridian = require(336    /* ./constants/PrimeMeridian */);
var units = require(337    /* ./constants/units */);
module.exports = function (defData) {
    var self = {};
    var paramObj = defData.split('+').map(function (v) {
        return v.trim();
    }).filter(function (a) {
        return a;
    }).reduce(function (p, a) {
        var split = a.split('=');
        split.push(true);
        p[split[0].toLowerCase()] = split[1];
        return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
        proj: 'projName',
        datum: 'datumCode',
        rf: function (v) {
            self.rf = parseFloat(v);
        },
        lat_0: function (v) {
            self.lat0 = v * D2R;
        },
        lat_1: function (v) {
            self.lat1 = v * D2R;
        },
        lat_2: function (v) {
            self.lat2 = v * D2R;
        },
        lat_ts: function (v) {
            self.lat_ts = v * D2R;
        },
        lon_0: function (v) {
            self.long0 = v * D2R;
        },
        lon_1: function (v) {
            self.long1 = v * D2R;
        },
        lon_2: function (v) {
            self.long2 = v * D2R;
        },
        alpha: function (v) {
            self.alpha = parseFloat(v) * D2R;
        },
        lonc: function (v) {
            self.longc = v * D2R;
        },
        x_0: function (v) {
            self.x0 = parseFloat(v);
        },
        y_0: function (v) {
            self.y0 = parseFloat(v);
        },
        k_0: function (v) {
            self.k0 = parseFloat(v);
        },
        k: function (v) {
            self.k0 = parseFloat(v);
        },
        a: function (v) {
            self.a = parseFloat(v);
        },
        b: function (v) {
            self.b = parseFloat(v);
        },
        r_a: function () {
            self.R_A = true;
        },
        zone: function (v) {
            self.zone = parseInt(v, 10);
        },
        south: function () {
            self.utmSouth = true;
        },
        towgs84: function (v) {
            self.datum_params = v.split(',').map(function (a) {
                return parseFloat(a);
            });
        },
        to_meter: function (v) {
            self.to_meter = parseFloat(v);
        },
        units: function (v) {
            self.units = v;
            if (units[v]) {
                self.to_meter = units[v].to_meter;
            }
        },
        from_greenwich: function (v) {
            self.from_greenwich = v * D2R;
        },
        pm: function (v) {
            self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
        },
        nadgrids: function (v) {
            if (v === '@null') {
                self.datumCode = 'none';
            } else {
                self.nadgrids = v;
            }
        },
        axis: function (v) {
            var legalAxis = 'ewnsud';
            if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                self.axis = v;
            }
        }
    };
    for (paramName in paramObj) {
        paramVal = paramObj[paramName];
        if (paramName in params) {
            paramOutname = params[paramName];
            if (typeof paramOutname === 'function') {
                paramOutname(paramVal);
            } else {
                self[paramOutname] = paramVal;
            }
        } else {
            self[paramName] = paramVal;
        }
    }
    if (typeof self.datumCode === 'string' && self.datumCode !== 'WGS84') {
        self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
};},
/* proj4/lib/projections */ function(require, module, exports) {
var projs = [
    require(350    /* ./projections/merc */),
    require(349    /* ./projections/longlat */)
];
var names = {};
var projStore = [];
function add(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
        console.log(i);
        return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function (n) {
        names[n.toLowerCase()] = len;
    });
    return this;
}
exports.add = add;
exports.get = function (name) {
    if (!name) {
        return false;
    }
    var n = name.toLowerCase();
    if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
        return projStore[names[n]];
    }
};
exports.start = function () {
    projs.forEach(add);
};},
/* proj4/lib/projections/longlat */ function(require, module, exports) {
exports.init = function () {
};
function identity(pt) {
    return pt;
}
exports.forward = identity;
exports.inverse = identity;
exports.names = [
    'longlat',
    'identity'
];},
/* proj4/lib/projections/merc */ function(require, module, exports) {
var msfnz = require(329    /* ../common/msfnz */);
var HALF_PI = Math.PI / 2;
var EPSLN = 1e-10;
var R2D = 57.29577951308232;
var adjust_lon = require(328    /* ../common/adjust_lon */);
var FORTPI = Math.PI / 4;
var tsfnz = require(333    /* ../common/tsfnz */);
var phi2z = require(330    /* ../common/phi2z */);
exports.init = function () {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if (!('x0' in this)) {
        this.x0 = 0;
    }
    if (!('y0' in this)) {
        this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
        if (this.sphere) {
            this.k0 = Math.cos(this.lat_ts);
        } else {
            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
        }
    } else {
        if (!this.k0) {
            if (this.k) {
                this.k0 = this.k;
            } else {
                this.k0 = 1;
            }
        }
    }
};
/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/
exports.forward = function (p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
        return null;
    }
    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
        return null;
    } else {
        if (this.sphere) {
            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
            y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
        } else {
            var sinphi = Math.sin(lat);
            var ts = tsfnz(this.e, lat, sinphi);
            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
            y = this.y0 - this.a * this.k0 * Math.log(ts);
        }
        p.x = x;
        p.y = y;
        return p;
    }
};
/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
exports.inverse = function (p) {
    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;
    if (this.sphere) {
        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    } else {
        var ts = Math.exp(-y / (this.a * this.k0));
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
            return null;
        }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));
    p.x = lon;
    p.y = lat;
    return p;
};
exports.names = [
    'Mercator',
    'Popular Visualisation Pseudo Mercator',
    'Mercator_1SP',
    'Mercator_Auxiliary_Sphere',
    'merc'
];},
/* proj4/lib/transform */ function(require, module, exports) {
var D2R = 0.017453292519943295;
var R2D = 57.29577951308232;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var datum_transform = require(341    /* ./datum_transform */);
var adjust_axis = require(327    /* ./adjust_axis */);
var proj = require(326    /* ./Proj */);
var toPoint = require(332    /* ./common/toPoint */);
function checkNotWGS(source, dest) {
    return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';
}
module.exports = function transform(source, dest, point) {
    var wgs84;
    if (Array.isArray(point)) {
        point = toPoint(point);
    }
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
        wgs84 = new proj('WGS84');
        point = transform(source, wgs84, point);
        source = wgs84;
    }
    // DGR, 2010/11/12
    if (source.axis !== 'enu') {
        point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
        point = {
            x: point.x * D2R,
            y: point.y * D2R
        };
    } else {
        if (source.to_meter) {
            point = {
                x: point.x * source.to_meter,
                y: point.y * source.to_meter
            };
        }
        point = source.inverse(point);    // Convert Cartesian to longlat
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
        point.x += source.from_greenwich;
    }
    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);
    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
        point = {
            x: point.x - dest.grom_greenwich,
            y: point.y
        };
    }
    if (dest.projName === 'longlat') {
        // convert radians to decimal degrees
        point = {
            x: point.x * R2D,
            y: point.y * R2D
        };
    } else {
        // else project
        point = dest.forward(point);
        if (dest.to_meter) {
            point = {
                x: point.x / dest.to_meter,
                y: point.y / dest.to_meter
            };
        }
    }
    // DGR, 2010/11/12
    if (dest.axis !== 'enu') {
        return adjust_axis(dest, true, point);
    }
    return point;
};},
/* proj4/lib/wkt */ function(require, module, exports) {
var D2R = 0.017453292519943295;
var extend = require(344    /* ./extend */);
function mapit(obj, key, v) {
    obj[key] = v.map(function (aa) {
        var o = {};
        sExpr(aa, o);
        return o;
    }).reduce(function (a, b) {
        return extend(a, b);
    }, {});
}
function sExpr(v, obj) {
    var key;
    if (!Array.isArray(v)) {
        obj[v] = true;
        return;
    } else {
        key = v.shift();
        if (key === 'PARAMETER') {
            key = v.shift();
        }
        if (v.length === 1) {
            if (Array.isArray(v[0])) {
                obj[key] = {};
                sExpr(v[0], obj[key]);
            } else {
                obj[key] = v[0];
            }
        } else if (!v.length) {
            obj[key] = true;
        } else if (key === 'TOWGS84') {
            obj[key] = v;
        } else {
            obj[key] = {};
            if ([
                    'UNIT',
                    'PRIMEM',
                    'VERT_DATUM'
                ].indexOf(key) > -1) {
                obj[key] = {
                    name: v[0].toLowerCase(),
                    convert: v[1]
                };
                if (v.length === 3) {
                    obj[key].auth = v[2];
                }
            } else if (key === 'SPHEROID') {
                obj[key] = {
                    name: v[0],
                    a: v[1],
                    rf: v[2]
                };
                if (v.length === 4) {
                    obj[key].auth = v[3];
                }
            } else if ([
                    'GEOGCS',
                    'GEOCCS',
                    'DATUM',
                    'VERT_CS',
                    'COMPD_CS',
                    'LOCAL_CS',
                    'FITTED_CS',
                    'LOCAL_DATUM'
                ].indexOf(key) > -1) {
                v[0] = [
                    'name',
                    v[0]
                ];
                mapit(obj, key, v);
            } else if (v.every(function (aa) {
                    return Array.isArray(aa);
                })) {
                mapit(obj, key, v);
            } else {
                sExpr(v, obj[key]);
            }
        }
    }
}
function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && inName in obj) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
            obj[outName] = params[2](obj[outName]);
        }
    }
}
function d2r(input) {
    return input * D2R;
}
function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
    } else {
        if (typeof wkt.PROJECTION === 'object') {
            wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
            wkt.projName = wkt.PROJECTION;
        }
    }
    if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
            wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
            if (wkt.type === 'GEOGCS') {
                if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                    wkt.to_meter = parseFloat(wkt.UNIT.convert, 10) * wkt.DATUM.SPHEROID.a;
                }
            } else {
                wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
            }
        }
    }
    if (wkt.GEOGCS) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (wkt.GEOGCS.DATUM) {
            wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
        } else {
            wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
            wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
            wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984') {
            if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
                wkt.sphere = true;
            }
            wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode.slice(-6) === '_ferro') {
            wkt.datumCode = wkt.datumCode.slice(0, -6);
        }
        if (wkt.datumCode.slice(-8) === '_jakarta') {
            wkt.datumCode = wkt.datumCode.slice(0, -8);
        }
        if (~wkt.datumCode.indexOf('belge')) {
            wkt.datumCode = 'rnb72';
        }
        if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
            wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
            if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
                wkt.ellps = 'intl';
            }
            wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
            wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
            wkt.datumCode = 'osgb36';
        }
    }
    if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
    }
    function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return parseFloat(input, 10) * ratio;
    }
    var renamer = function (a) {
        return rename(wkt, a);
    };
    var list = [
        [
            'standard_parallel_1',
            'Standard_Parallel_1'
        ],
        [
            'standard_parallel_2',
            'Standard_Parallel_2'
        ],
        [
            'false_easting',
            'False_Easting'
        ],
        [
            'false_northing',
            'False_Northing'
        ],
        [
            'central_meridian',
            'Central_Meridian'
        ],
        [
            'latitude_of_origin',
            'Latitude_Of_Origin'
        ],
        [
            'latitude_of_origin',
            'Central_Parallel'
        ],
        [
            'scale_factor',
            'Scale_Factor'
        ],
        [
            'k0',
            'scale_factor'
        ],
        [
            'latitude_of_center',
            'Latitude_of_center'
        ],
        [
            'lat0',
            'latitude_of_center',
            d2r
        ],
        [
            'longitude_of_center',
            'Longitude_Of_Center'
        ],
        [
            'longc',
            'longitude_of_center',
            d2r
        ],
        [
            'x0',
            'false_easting',
            toMeter
        ],
        [
            'y0',
            'false_northing',
            toMeter
        ],
        [
            'long0',
            'central_meridian',
            d2r
        ],
        [
            'lat0',
            'latitude_of_origin',
            d2r
        ],
        [
            'lat0',
            'standard_parallel_1',
            d2r
        ],
        [
            'lat1',
            'standard_parallel_1',
            d2r
        ],
        [
            'lat2',
            'standard_parallel_2',
            d2r
        ],
        [
            'alpha',
            'azimuth',
            d2r
        ],
        [
            'srsCode',
            'name'
        ]
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
        wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
    }
}
module.exports = function (wkt, self) {
    var lisp = JSON.parse((',' + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, ''));
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift([
        'name',
        name
    ]);
    lisp.unshift([
        'type',
        type
    ]);
    lisp.unshift('output');
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj.output);
    return extend(self, obj.output);
};},
/* quickselect/index */ function(require, module, exports) {
'use strict';
module.exports = partialSort;
// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]
function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || arr.length - 1;
    compare = compare || defaultCompare;
    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }
        var t = arr[k];
        var i = left;
        var j = right;
        swap(arr, left, k);
        if (compare(arr[right], t) > 0)
            swap(arr, left, right);
        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0)
                i++;
            while (compare(arr[j], t) > 0)
                j--;
        }
        if (compare(arr[left], t) === 0)
            swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }
        if (j <= k)
            left = j + 1;
        if (k <= j)
            right = j - 1;
    }
}
function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}},
/* rbush/index */ function(require, module, exports) {
'use strict';
module.exports = rbush;
var quickselect = require(353    /* quickselect */);
function rbush(maxEntries, format) {
    if (!(this instanceof rbush))
        return new rbush(maxEntries, format);
    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    if (format) {
        this._initFormat(format);
    }
    this.clear();
}
rbush.prototype = {
    all: function () {
        return this._all(this.data, []);
    },
    search: function (bbox) {
        var node = this.data, result = [], toBBox = this.toBBox;
        if (!intersects(bbox, node))
            return result;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                    if (node.leaf)
                        result.push(child);
                    else if (contains(bbox, childBBox))
                        this._all(child, result);
                    else
                        nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }
        return result;
    },
    collides: function (bbox) {
        var node = this.data, toBBox = this.toBBox;
        if (!intersects(bbox, node))
            return false;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox))
                        return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }
        return false;
    },
    load: function (data) {
        if (!(data && data.length))
            return this;
        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }
        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;
        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);
        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }
            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
    },
    insert: function (item) {
        if (item)
            this._insert(item, this.data.height - 1);
        return this;
    },
    clear: function () {
        this.data = createNode([]);
        return this;
    },
    remove: function (item, equalsFn) {
        if (!item)
            return this;
        var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
        // depth-first iterative tree traversal
        while (node || path.length) {
            if (!node) {
                // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }
            if (node.leaf) {
                // check current node
                index = findItem(item, node.children, equalsFn);
                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }
            if (!goingUp && !node.leaf && contains(node, bbox)) {
                // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];
            } else if (parent) {
                // go right
                i++;
                node = parent.children[i];
                goingUp = false;
            } else
                node = null;    // nothing found
        }
        return this;
    },
    toBBox: function (item) {
        return item;
    },
    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,
    toJSON: function () {
        return this.data;
    },
    fromJSON: function (data) {
        this.data = data;
        return this;
    },
    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf)
                result.push.apply(result, node.children);
            else
                nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
        }
        return result;
    },
    _build: function (items, left, right, height) {
        var N = right - left + 1, M = this._maxEntries, node;
        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }
        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));
            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        // split the items into M mostly square tiles
        var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
        multiSelect(items, left, right, N1, this.compareMinX);
        for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
                right3 = Math.min(j + N2 - 1, right2);
                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }
        calcBBox(node, this.toBBox);
        return node;
    },
    _chooseSubtree: function (bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
        while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
                break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;
                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;
                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }
            node = targetNode || node.children[0];
        }
        return node;
    },
    _insert: function (item, level, isNode) {
        var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        // put the item into the node
        node.children.push(item);
        extend(node, bbox);
        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else
                break;
        }
        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },
    // split overflowed node into two
    _split: function (insertPath, level) {
        var node = insertPath[level], M = node.children.length, m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level)
            insertPath[level - 1].children.push(newNode);
        else
            this._splitRoot(node, newNode);
    },
    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([
            node,
            newNode
        ]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },
    _chooseSplitIndex: function (node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;
        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);
            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;
                minArea = area < minArea ? area : minArea;
            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }
        return index;
    },
    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin)
            node.children.sort(compareMinX);
    },
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }
        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }
        return margin;
    },
    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },
    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                } else
                    this.clear();
            } else
                calcBBox(path[i], this.toBBox);
        }
    },
    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = [
            'return a',
            ' - b',
            ';'
        ];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
    }
};
function findItem(item, items, equalsFn) {
    if (!equalsFn)
        return items.indexOf(item);
    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i]))
            return i;
    }
    return -1;
}
// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}
// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode)
        destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;
    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }
    return destNode;
}
function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}
function compareNodeMinX(a, b) {
    return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
    return a.minY - b.minY;
}
function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}
// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function multiSelect(arr, left, right, n, compare) {
    var stack = [
            left,
            right
        ], mid;
    while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n)
            continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
    }
}},
/* sprintf-js/src/sprintf */ function(require, module, exports) {
/* global window, exports, define */
!function () {
    'use strict';
    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    };
    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i];
            } else if (Array.isArray(parse_tree[i])) {
                match = parse_tree[i];
                // convenience purposes only
                if (match[2]) {
                    // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                        }
                        arg = arg[match[2][k]];
                    }
                } else if (match[1]) {
                    // positional argument (explicit)
                    arg = argv[match[1]];
                } else {
                    // positional argument (implicit)
                    arg = argv[cursor++];
                }
                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {
                    arg = arg();
                }
                if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
                }
                if (re.number.test(match[8])) {
                    is_positive = arg >= 0;
                }
                switch (match[8]) {
                case 'b':
                    arg = parseInt(arg, 10).toString(2);
                    break;
                case 'c':
                    arg = String.fromCharCode(parseInt(arg, 10));
                    break;
                case 'd':
                case 'i':
                    arg = parseInt(arg, 10);
                    break;
                case 'j':
                    arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                    break;
                case 'e':
                    arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
                    break;
                case 'f':
                    arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                    break;
                case 'g':
                    arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg);
                    break;
                case 'o':
                    arg = (parseInt(arg, 10) >>> 0).toString(8);
                    break;
                case 's':
                    arg = String(arg);
                    arg = match[7] ? arg.substring(0, match[7]) : arg;
                    break;
                case 't':
                    arg = String(!!arg);
                    arg = match[7] ? arg.substring(0, match[7]) : arg;
                    break;
                case 'T':
                    arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                    arg = match[7] ? arg.substring(0, match[7]) : arg;
                    break;
                case 'u':
                    arg = parseInt(arg, 10) >>> 0;
                    break;
                case 'v':
                    arg = arg.valueOf();
                    arg = match[7] ? arg.substring(0, match[7]) : arg;
                    break;
                case 'x':
                    arg = (parseInt(arg, 10) >>> 0).toString(16);
                    break;
                case 'X':
                    arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                    break;
                }
                if (re.json.test(match[8])) {
                    output += arg;
                } else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? '+' : '-';
                        arg = arg.toString().replace(re.sign, '');
                    } else {
                        sign = '';
                    }
                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - (sign + arg).length;
                    pad = match[6] ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
                    output += match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
                }
            }
        }
        return output;
    }
    var sprintf_cache = Object.create(null);
    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%');
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [], replacement_field = match[2], field_match = [];
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key');
                            }
                        }
                    } else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key');
                    }
                    match[2] = field_list;
                } else {
                    arg_names |= 2;
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                }
                parse_tree.push(match);
            } else {
                throw new SyntaxError('[sprintf] unexpected placeholder');
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
    }
    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== 'undefined') {
        exports['sprintf'] = sprintf;
        exports['vsprintf'] = vsprintf;
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf;
        window['vsprintf'] = vsprintf;
        if (typeof define === 'function' && define['amd']) {
            define(function () {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                };
            });
        }
    }    /* eslint-enable quote-props */
}();},
/* timezone/index */ function(require, module, exports) {
!function (definition) {
    if (typeof module == 'object' && module.exports)
        module.exports = definition();
    else if (typeof define == 'function')
        define(definition);
    else
        this.tz = definition();
}(function () {
    /*
  function die () {
    console.log.apply(console, __slice.call(arguments, 0));
    return process.exit(1);
  }

  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }
*/
    function actualize(entry, rule, year) {
        var actualized, date = rule.day[1];
        do {
            actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));
        } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0]);
        actualized = {
            clock: rule.clock,
            sort: actualized.getTime(),
            rule: rule,
            save: rule.save * 60000,
            offset: entry.offset
        };
        actualized[actualized.clock] = actualized.sort + rule.time * 60000;
        if (actualized.posix) {
            actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);
        } else {
            actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);
        }
        return actualized;
    }
    function find(request, clock, time) {
        var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules, j, year = new Date(time).getUTCFullYear(), off = 1;
        for (i = 1, I = zone.length; i < I; i++)
            if (zone[i][clock] <= time)
                break;
        entry = zone[i];
        if (entry.rules) {
            rules = request[entry.rules];
            for (j = year + 1; j >= year - off; --j)
                for (i = 0, I = rules.length; i < I; i++)
                    if (rules[i].from <= j && j <= rules[i].to)
                        actualized.push(actualize(entry, rules[i], j));
                    else if (rules[i].to < j && off == 1)
                        off = j - rules[i].to;
            actualized.sort(function (a, b) {
                return a.sort - b.sort;
            });
            for (i = 0, I = actualized.length; i < I; i++) {
                if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock])
                    found = actualized[i];
            }
        }
        if (found) {
            if (abbrev = /^(.*)\/(.*)$/.exec(entry.format)) {
                found.abbrev = abbrev[found.save ? 2 : 1];
            } else {
                found.abbrev = entry.format.replace(/%s/, found.rule.letter);
            }
        }
        return found || entry;
    }
    function convertToWallclock(request, posix) {
        if (request.zone == 'UTC')
            return posix;
        request.entry = find(request, 'posix', posix);
        return posix + request.entry.offset + request.entry.save;
    }
    function convertToPOSIX(request, wallclock) {
        if (request.zone == 'UTC')
            return wallclock;
        var entry, diff;
        request.entry = entry = find(request, 'wallclock', wallclock);
        diff = wallclock - entry.wallclock;
        return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;
    }
    function adjust(request, posix, match) {
        var increment = +(match[1] + 1)    // conversion necessary for week day addition
, offset = match[2] * increment, index = UNITS.indexOf(match[3].toLowerCase()), date;
        if (index > 9) {
            posix += offset * TIME[index - 10];
        } else {
            date = new Date(convertToWallclock(request, posix));
            if (index < 7) {
                while (offset) {
                    date.setUTCDate(date.getUTCDate() + increment);
                    if (date.getUTCDay() == index)
                        offset -= increment;
                }
            } else if (index == 7) {
                date.setUTCFullYear(date.getUTCFullYear() + offset);
            } else if (index == 8) {
                date.setUTCMonth(date.getUTCMonth() + offset);
            } else {
                date.setUTCDate(date.getUTCDate() + offset);
            }
            if ((posix = convertToPOSIX(request, date.getTime())) == null) {
                posix = convertToPOSIX(request, date.getTime() + 86400000 * increment) - 86400000 * increment;
            }
        }
        return posix;
    }
    function convert(vargs) {
        if (!vargs.length)
            return '1.0.6';
        var request = Object.create(this), adjustments = [], i, I, $, argument, date;
        for (i = 0; i < vargs.length; i++) {
            // leave the for loop alone, it works.
            argument = vargs[i];
            // https://twitter.com/bigeasy/status/215112186572439552
            if (Array.isArray(argument)) {
                if (!i && !isNaN(argument[1])) {
                    date = argument;
                } else {
                    argument.splice.apply(vargs, [
                        i--,
                        1
                    ].concat(argument));
                }
            } else if (isNaN(argument)) {
                $ = typeof argument;
                if ($ == 'string') {
                    if (~argument.indexOf('%')) {
                        request.format = argument;
                    } else if (!i && argument == '*') {
                        date = argument;
                    } else if (!i && ($ = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
                        date = [];
                        date.push.apply(date, $.slice(1, 8));
                        if ($[9]) {
                            date.push($[10] + 1);
                            date.push.apply(date, $[11].split(/:/));
                        } else if ($[8]) {
                            date.push(1);
                        }
                    } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
                        request.locale = argument;
                    } else if ($ = UNIT_RE.exec(argument)) {
                        adjustments.push($);
                    } else {
                        request.zone = argument;
                    }
                } else if ($ == 'function') {
                    if ($ = argument.call(request))
                        return $;
                } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
                    request[argument.name] = argument;
                } else if (argument.zones) {
                    for ($ in argument.zones)
                        request[$] = argument.zones[$];
                    for ($ in argument.rules)
                        request[$] = argument.rules[$];
                }
            } else if (!i) {
                date = argument;
            }
        }
        if (!request[request.locale])
            delete request.locale;
        if (!request[request.zone])
            delete request.zone;
        if (date != null) {
            if (date == '*') {
                date = request.clock();
            } else if (Array.isArray(date)) {
                I = !date[7];
                for (i = 0; i < 11; i++)
                    date[i] = +(date[i] || 0);
                // conversion necessary for decrement
                --date[1];
                // Grr..
                date = Date.UTC.apply(Date.UTC, date.slice(0, 8)) + -date[7] * (date[8] * 3600000 + date[9] * 60000 + date[10] * 1000);
            } else {
                date = Math.floor(date);
            }
            if (!isNaN(date)) {
                if (I)
                    date = convertToPOSIX(request, date);
                if (date == null)
                    return date;
                for (i = 0, I = adjustments.length; i < I; i++) {
                    date = adjust(request, date, adjustments[i]);
                }
                if (!request.format)
                    return date;
                $ = new Date(convertToWallclock(request, date));
                return request.format.replace(/%([-0_^]?)(:{0,3})(\d*)(.)/g, function (value, flag, colons, padding, specifier) {
                    var f, fill = '0', pad;
                    if (f = request[specifier]) {
                        value = String(f.call(request, $, date, flag, colons.length));
                        if ((flag || f.style) == '_')
                            fill = ' ';
                        pad = flag == '-' ? 0 : f.pad || 0;
                        while (value.length < pad)
                            value = fill + value;
                        pad = flag == '-' ? 0 : padding || f.pad;
                        while (value.length < pad)
                            value = fill + value;
                        if (specifier == 'N' && pad < value.length)
                            value = value.slice(0, pad);
                        if (flag == '^')
                            value = value.toUpperCase();
                    }
                    return value;
                });
            }
        }
        return function () {
            return request.convert(arguments);
        };
    }
    var context = {
        clock: function () {
            return +new Date();
        },
        zone: 'UTC',
        entry: {
            abbrev: 'UTC',
            offset: 0,
            save: 0
        },
        UTC: 1,
        z: function (date, posix, flag, delimiters) {
            var offset = this.entry.offset + this.entry.save, seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;
            for (i = 0; i < 3; i++) {
                parts.push(('0' + Math.floor(seconds / part)).slice(-2));
                seconds %= part;
                part /= 60;
            }
            if (flag == '^' && !offset)
                return 'Z';
            if (flag == '^')
                delimiters = 3;
            if (delimiters == 3) {
                z = parts.join(':');
                z = z.replace(/:00$/, '');
                if (flag != '^')
                    z = z.replace(/:00$/, '');
            } else if (delimiters) {
                z = parts.slice(0, delimiters + 1).join(':');
                if (flag == '^')
                    z = z.replace(/:00$/, '');
            } else {
                z = parts.slice(0, 2).join('');
            }
            z = (offset < 0 ? '-' : '+') + z;
            z = z.replace(/([-+])(0)/, {
                '_': ' $1',
                '-': '$1'
            }[flag] || '$1$2');
            return z;
        },
        '%': function (date) {
            return '%';
        },
        n: function (date) {
            return '\n';
        },
        t: function (date) {
            return '\t';
        },
        U: function (date) {
            return weekOfYear(date, 0);
        },
        W: function (date) {
            return weekOfYear(date, 1);
        },
        V: function (date) {
            return isoWeek(date)[0];
        },
        G: function (date) {
            return isoWeek(date)[1];
        },
        g: function (date) {
            return isoWeek(date)[1] % 100;
        },
        j: function (date) {
            return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 86400000) + 1;
        },
        s: function (date) {
            return Math.floor(date.getTime() / 1000);
        },
        C: function (date) {
            return Math.floor(date.getUTCFullYear() / 100);
        },
        N: function (date) {
            return date.getTime() % 1000 * 1000000;
        },
        m: function (date) {
            return date.getUTCMonth() + 1;
        },
        Y: function (date) {
            return date.getUTCFullYear();
        },
        y: function (date) {
            return date.getUTCFullYear() % 100;
        },
        H: function (date) {
            return date.getUTCHours();
        },
        M: function (date) {
            return date.getUTCMinutes();
        },
        S: function (date) {
            return date.getUTCSeconds();
        },
        e: function (date) {
            return date.getUTCDate();
        },
        d: function (date) {
            return date.getUTCDate();
        },
        u: function (date) {
            return date.getUTCDay() || 7;
        },
        w: function (date) {
            return date.getUTCDay();
        },
        l: function (date) {
            return date.getUTCHours() % 12 || 12;
        },
        I: function (date) {
            return date.getUTCHours() % 12 || 12;
        },
        k: function (date) {
            return date.getUTCHours();
        },
        Z: function (date) {
            return this.entry.abbrev;
        },
        a: function (date) {
            return this[this.locale].day.abbrev[date.getUTCDay()];
        },
        A: function (date) {
            return this[this.locale].day.full[date.getUTCDay()];
        },
        h: function (date) {
            return this[this.locale].month.abbrev[date.getUTCMonth()];
        },
        b: function (date) {
            return this[this.locale].month.abbrev[date.getUTCMonth()];
        },
        B: function (date) {
            return this[this.locale].month.full[date.getUTCMonth()];
        },
        P: function (date) {
            return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase();
        },
        p: function (date) {
            return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)];
        },
        R: function (date, posix) {
            return this.convert([
                posix,
                '%H:%M'
            ]);
        },
        T: function (date, posix) {
            return this.convert([
                posix,
                '%H:%M:%S'
            ]);
        },
        D: function (date, posix) {
            return this.convert([
                posix,
                '%m/%d/%y'
            ]);
        },
        F: function (date, posix) {
            return this.convert([
                posix,
                '%Y-%m-%d'
            ]);
        },
        x: function (date, posix) {
            return this.convert([
                posix,
                this[this.locale].date
            ]);
        },
        r: function (date, posix) {
            return this.convert([
                posix,
                this[this.locale].time12 || '%I:%M:%S'
            ]);
        },
        X: function (date, posix) {
            return this.convert([
                posix,
                this[this.locale].time24
            ]);
        },
        c: function (date, posix) {
            return this.convert([
                posix,
                this[this.locale].dateTime
            ]);
        },
        convert: convert,
        locale: 'en_US',
        en_US: {
            date: '%m/%d/%Y',
            time24: '%I:%M:%S %p',
            time12: '%I:%M:%S %p',
            dateTime: '%a %d %b %Y %I:%M:%S %p %Z',
            meridiem: [
                'AM',
                'PM'
            ],
            month: {
                abbrev: 'Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec'.split('|'),
                full: 'January|February|March|April|May|June|July|August|September|October|November|December'.split('|')
            },
            day: {
                abbrev: 'Sun|Mon|Tue|Wed|Thu|Fri|Sat'.split('|'),
                full: 'Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday'.split('|')
            }
        }
    };
    var UNITS = 'Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond', UNIT_RE = new RegExp('^\\s*([+-])(\\d+)\\s+(' + UNITS + ')s?\\s*$', 'i'), TIME = [
            3600000,
            60000,
            1000,
            1
        ];
    UNITS = UNITS.toLowerCase().split('|');
    'delmHMSUWVgCIky'.replace(/./g, function (e) {
        context[e].pad = 2;
    });
    context.N.pad = 9;
    context.j.pad = 3;
    context.k.style = '_';
    context.l.style = '_';
    context.e.style = '_';
    function weekOfYear(date, startOfWeek) {
        var diff, nyd, weekStart;
        nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
        diff = Math.floor((date.getTime() - nyd.getTime()) / 86400000);
        if (nyd.getUTCDay() == startOfWeek) {
            weekStart = 0;
        } else {
            weekStart = 7 - nyd.getUTCDay() + startOfWeek;
            if (weekStart == 8) {
                weekStart = 1;
            }
        }
        return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
    }
    function isoWeek(date) {
        var nyd, nyy, week;
        nyy = date.getUTCFullYear();
        nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
        week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
        if (!week) {
            nyy = date.getUTCFullYear() - 1;
            nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
            week = nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29 ? 53 : 52;
            return [
                week,
                date.getUTCFullYear() - 1
            ];
        } else if (week == 53 && !(nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29)) {
            return [
                1,
                date.getUTCFullYear() + 1
            ];
        } else {
            return [
                week,
                date.getUTCFullYear()
            ];
        }
    }
    return function () {
        return context.convert(arguments);
    };
});},
/* tslib/tslib */ function(require, module, exports) {
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
(function (factory) {
    var root = typeof global === 'object' ? global : typeof self === 'object' ? self : typeof this === 'object' ? this : {};
    if (typeof define === 'function' && define.amd) {
        define('tslib', ['exports'], function (exports) {
            factory(createExporter(root, createExporter(exports)));
        });
    } else if (typeof module === 'object' && typeof module.exports === 'object') {
        factory(createExporter(root, createExporter(module.exports)));
    } else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        return function (id, v) {
            return exports[id] = previous ? previous(id, v) : v;
        };
    }
}(function (exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
    };
    __extends = function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    __rest = function (s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === 'function')
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
                if (e.indexOf(p[i]) < 0)
                    t[p[i]] = s[p[i]];
        return t;
    };
    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function (paramIndex, decorator) {
        return function (target, key) {
            decorator(target, key, paramIndex);
        };
    };
    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
            return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator['throw'](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : new P(function (resolve) {
                    resolve(result.value);
                }).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    __generator = function (thisArg, body) {
        var _ = {
                label: 0,
                sent: function () {
                    if (t[0] & 1)
                        throw t[1];
                    return t[1];
                },
                trys: [],
                ops: []
            }, f, y, t, g;
        return g = {
            next: verb(0),
            'throw': verb(1),
            'return': verb(2)
        }, typeof Symbol === 'function' && (g[Symbol.iterator] = function () {
            return this;
        }), g;
        function verb(n) {
            return function (v) {
                return step([
                    n,
                    v
                ]);
            };
        }
        function step(op) {
            if (f)
                throw new TypeError('Generator is already executing.');
            while (_)
                try {
                    if (f = 1, y && (t = y[op[0] & 2 ? 'return' : op[0] ? 'throw' : 'next']) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [
                            0,
                            t.value
                        ];
                    switch (op[0]) {
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2])
                            _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) {
                    op = [
                        6,
                        e
                    ];
                    y = 0;
                } finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return {
                value: op[0] ? op[1] : void 0,
                done: true
            };
        }
    };
    __exportStar = function (m, exports) {
        for (var p in m)
            if (!exports.hasOwnProperty(p))
                exports[p] = m[p];
    };
    __values = function (o) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
    };
    __read = function (o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        } catch (error) {
            e = { error: error };
        } finally {
            try {
                if (r && !r.done && (m = i['return']))
                    m.call(i);
            } finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    };
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError('Symbol.asyncIterator is not defined.');
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
            return this;
        }, i;
        function verb(n) {
            if (g[n])
                i[n] = function (v) {
                    return new Promise(function (a, b) {
                        q.push([
                            n,
                            v,
                            a,
                            b
                        ]) > 1 || resume(n, v);
                    });
                };
        }
        function resume(n, v) {
            try {
                step(g[n](v));
            } catch (e) {
                settle(q[0][3], e);
            }
        }
        function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
            resume('next', value);
        }
        function reject(value) {
            resume('throw', value);
        }
        function settle(f, v) {
            if (f(v), q.shift(), q.length)
                resume(q[0][0], q[0][1]);
        }
    };
    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb('next'), verb('throw', function (e) {
            throw e;
        }), verb('return'), i[Symbol.iterator] = function () {
            return this;
        }, i;
        function verb(n, f) {
            if (o[n])
                i[n] = function (v) {
                    return (p = !p) ? {
                        value: __await(o[n](v)),
                        done: n === 'return'
                    } : f ? f(v) : v;
                };
        }
    };
    __asyncValues = function (o) {
        if (!Symbol.asyncIterator)
            throw new TypeError('Symbol.asyncIterator is not defined.');
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === 'function' ? __values(o) : o[Symbol.iterator]();
    };
    exporter('__extends', __extends);
    exporter('__assign', __assign);
    exporter('__rest', __rest);
    exporter('__decorate', __decorate);
    exporter('__param', __param);
    exporter('__metadata', __metadata);
    exporter('__awaiter', __awaiter);
    exporter('__generator', __generator);
    exporter('__exportStar', __exportStar);
    exporter('__values', __values);
    exporter('__read', __read);
    exporter('__spread', __spread);
    exporter('__await', __await);
    exporter('__asyncGenerator', __asyncGenerator);
    exporter('__asyncDelegator', __asyncDelegator);
    exporter('__asyncValues', __asyncValues);
}));}
], {"base":0,"client":1,"core/bokeh_events":2,"core/build_views":3,"core/dom":4,"core/dom_view":5,"core/enums":6,"core/has_props":7,"core/hittest":8,"core/layout/layout_canvas":9,"core/layout/side_panel":10,"core/layout/solver":11,"core/logging":12,"core/properties":13,"core/property_mixins":14,"core/selection_manager":15,"core/selector":16,"core/settings":17,"core/signaling":18,"core/ui_events":19,"core/util/array":20,"core/util/bbox":21,"core/util/callback":22,"core/util/canvas":23,"core/util/color":24,"core/util/data_structures":25,"core/util/eq":26,"core/util/math":27,"core/util/object":28,"core/util/proj4":29,"core/util/projections":30,"core/util/refs":31,"core/util/selection":32,"core/util/serialization":33,"core/util/spatial":34,"core/util/string":35,"core/util/svg_colors":36,"core/util/templating":37,"core/util/text":38,"core/util/throttle":39,"core/util/types":40,"core/util/wheel":41,"core/util/zoom":42,"core/view":43,"core/visuals":44,"document":45,"embed":46,"main":47,"model":48,"models/annotations/annotation":49,"models/annotations/arrow":50,"models/annotations/arrow_head":51,"models/annotations/band":52,"models/annotations/box_annotation":53,"models/annotations/color_bar":54,"models/annotations/index":55,"models/annotations/label":56,"models/annotations/label_set":57,"models/annotations/legend":58,"models/annotations/legend_item":59,"models/annotations/poly_annotation":60,"models/annotations/span":61,"models/annotations/text_annotation":62,"models/annotations/title":63,"models/annotations/tooltip":64,"models/annotations/whisker":65,"models/axes/axis":66,"models/axes/categorical_axis":67,"models/axes/continuous_axis":68,"models/axes/datetime_axis":69,"models/axes/index":70,"models/axes/linear_axis":71,"models/axes/log_axis":72,"models/callbacks/customjs":73,"models/callbacks/index":74,"models/callbacks/open_url":75,"models/canvas/canvas":76,"models/canvas/cartesian_frame":77,"models/canvas/index":78,"models/expressions/expression":79,"models/expressions/index":80,"models/expressions/stack":81,"models/filters/boolean_filter":82,"models/filters/customjs_filter":83,"models/filters/filter":84,"models/filters/group_filter":85,"models/filters/index":86,"models/filters/index_filter":87,"models/formatters/basic_tick_formatter":88,"models/formatters/categorical_tick_formatter":89,"models/formatters/datetime_tick_formatter":90,"models/formatters/func_tick_formatter":91,"models/formatters/index":92,"models/formatters/log_tick_formatter":93,"models/formatters/mercator_tick_formatter":94,"models/formatters/numeral_tick_formatter":95,"models/formatters/printf_tick_formatter":96,"models/formatters/tick_formatter":97,"models/glyphs/annular_wedge":98,"models/glyphs/annulus":99,"models/glyphs/arc":100,"models/glyphs/bezier":101,"models/glyphs/circle":102,"models/glyphs/ellipse":103,"models/glyphs/glyph":104,"models/glyphs/hbar":105,"models/glyphs/image":106,"models/glyphs/image_rgba":107,"models/glyphs/image_url":108,"models/glyphs/index":109,"models/glyphs/line":110,"models/glyphs/multi_line":111,"models/glyphs/oval":112,"models/glyphs/patch":113,"models/glyphs/patches":114,"models/glyphs/quad":115,"models/glyphs/quadratic":116,"models/glyphs/ray":117,"models/glyphs/rect":118,"models/glyphs/segment":119,"models/glyphs/text":120,"models/glyphs/vbar":121,"models/glyphs/wedge":122,"models/glyphs/xy_glyph":123,"models/graphs/graph_hit_test_policy":124,"models/graphs/index":125,"models/graphs/layout_provider":126,"models/graphs/static_layout_provider":127,"models/grids/grid":128,"models/grids/index":129,"models/index":130,"models/layouts/box":131,"models/layouts/column":132,"models/layouts/index":133,"models/layouts/layout_dom":134,"models/layouts/row":135,"models/layouts/spacer":136,"models/layouts/widget_box":137,"models/mappers/categorical_color_mapper":138,"models/mappers/color_mapper":139,"models/mappers/index":140,"models/mappers/linear_color_mapper":141,"models/mappers/log_color_mapper":142,"models/markers/index":143,"models/markers/marker":144,"models/plots/gmap_plot":145,"models/plots/gmap_plot_canvas":146,"models/plots/index":147,"models/plots/plot":148,"models/plots/plot_canvas":149,"models/ranges/data_range":150,"models/ranges/data_range1d":151,"models/ranges/factor_range":152,"models/ranges/index":153,"models/ranges/range":154,"models/ranges/range1d":155,"models/renderers/glyph_renderer":156,"models/renderers/graph_renderer":157,"models/renderers/guide_renderer":158,"models/renderers/index":159,"models/renderers/renderer":160,"models/scales/categorical_scale":161,"models/scales/index":162,"models/scales/linear_scale":163,"models/scales/log_scale":164,"models/scales/scale":165,"models/sources/ajax_data_source":166,"models/sources/cds_view":167,"models/sources/column_data_source":168,"models/sources/columnar_data_source":169,"models/sources/data_source":170,"models/sources/geojson_data_source":171,"models/sources/index":172,"models/sources/remote_data_source":173,"models/tickers/adaptive_ticker":174,"models/tickers/basic_ticker":175,"models/tickers/categorical_ticker":176,"models/tickers/composite_ticker":177,"models/tickers/continuous_ticker":178,"models/tickers/datetime_ticker":179,"models/tickers/days_ticker":180,"models/tickers/fixed_ticker":181,"models/tickers/index":182,"models/tickers/log_ticker":183,"models/tickers/mercator_ticker":184,"models/tickers/months_ticker":185,"models/tickers/single_interval_ticker":186,"models/tickers/ticker":187,"models/tickers/util":188,"models/tickers/years_ticker":189,"models/tiles/bbox_tile_source":190,"models/tiles/dynamic_image_renderer":191,"models/tiles/image_pool":192,"models/tiles/image_source":193,"models/tiles/index":194,"models/tiles/mercator_tile_source":195,"models/tiles/quadkey_tile_source":196,"models/tiles/tile_renderer":197,"models/tiles/tile_source":198,"models/tiles/tile_utils":199,"models/tiles/tms_tile_source":200,"models/tiles/wmts_tile_source":201,"models/tools/actions/action_tool":202,"models/tools/actions/help_tool":203,"models/tools/actions/redo_tool":204,"models/tools/actions/reset_tool":205,"models/tools/actions/save_tool":206,"models/tools/actions/undo_tool":207,"models/tools/actions/zoom_in_tool":208,"models/tools/actions/zoom_out_tool":209,"models/tools/button_tool":210,"models/tools/gestures/box_select_tool":211,"models/tools/gestures/box_zoom_tool":212,"models/tools/gestures/gesture_tool":213,"models/tools/gestures/lasso_select_tool":214,"models/tools/gestures/pan_tool":215,"models/tools/gestures/poly_select_tool":216,"models/tools/gestures/select_tool":217,"models/tools/gestures/tap_tool":218,"models/tools/gestures/wheel_pan_tool":219,"models/tools/gestures/wheel_zoom_tool":220,"models/tools/index":221,"models/tools/inspectors/crosshair_tool":222,"models/tools/inspectors/hover_tool":223,"models/tools/inspectors/inspect_tool":224,"models/tools/on_off_button":225,"models/tools/tool":226,"models/tools/tool_proxy":227,"models/tools/toolbar":228,"models/tools/toolbar_base":229,"models/tools/toolbar_box":230,"models/transforms/customjs_transform":231,"models/transforms/dodge":232,"models/transforms/index":233,"models/transforms/interpolator":234,"models/transforms/jitter":235,"models/transforms/linear_interpolator":236,"models/transforms/step_interpolator":237,"models/transforms/transform":238,"polyfill":239,"safely":240,"version":241}, 47);
})

//# sourceMappingURL=bokeh.js.map
