/* Copyright 2020 Tecnativa - Alexandre D. DÃ­az
 * License AGPL-3.0 or later (https://www.gnu.org/licenses/agpl). */

odoo.define("web_pwa_cache.PWA.managers.Sync", function(require) {
    "use strict";

    const SWManager = require("web_pwa_cache.PWA.managers.Manager");
    const rpc = require("web_pwa_cache.PWA.core.base.rpc");
    const BroadcastMixin = require("web_pwa_cache.BroadcastMixin");

    /**
     * This class is used to manage sync operations
     */
    const SWSyncManager = SWManager.extend(BroadcastMixin, {
        /**
         * @override
         */
        init: function(parent) {
            this.init_broadcast("pwa-sw-messages", "pwa-page-messages");
            this._super.apply(this, arguments);
            this._db = this.options.db || parent._db;
        },

        /**
         * @returns {Promise}
         */
        getSyncRecords: function() {
            return new Promise(async resolve => {
                try {
                    const model_info_sync = await this._db.getModelInfo("sync", true);
                    const records = await this._db.search_read(model_info_sync, []);
                    return resolve(records);
                } catch (err) {
                    // Do nothing
                }

                return resolve([]);
            });
        },

        /**
         * @param {Number} key
         * @param {Object} data
         * @returns {Promise}
         */
        updateSyncRecord: function(id, data) {
            return new Promise(async (resolve, reject) => {
                try {
                    const model_info_sync = await this._db.getModelInfo("sync", true);

                    await this._db.writeOrCreate(model_info_sync, [
                        _.extend({}, data, {id: id}),
                    ]);
                } catch (err) {
                    return reject(err);
                }

                return resolve();
            });
        },

        /**
         * @param {Array[Number]} keys
         * @returns {Promise}
         */
        removeSyncRecords: function(ids) {
            return new Promise(async (resolve, reject) => {
                try {
                    const model_info_sync = await this._db.getModelInfo("sync", true);
                    await this._db.unlink(model_info_sync, ids);
                } catch (err) {
                    return reject(err);
                }

                return resolve();
            });
        },

        _updateIds: function(records, old_id, new_id) {
            // Update sync records
            const tasks = [];
            for (const record of records) {
                // Update values
                const record_values = record.args[0];
                for (const field_name in record_values) {
                    const field_value = record_values[field_name];
                    if (field_value instanceof Array) {
                        for (const index in field_value) {
                            if (field_value[index] === old_id) {
                                field_value[index] = new_id;
                            }
                        }
                        record_values[field_name] = field_value;
                    } else if (field_value === old_id) {
                        record_values[field_name] = field_value;
                    }
                }
                record.args[0] = record_values;
                // Update linked info
                for (const model in record.linked) {
                    const changes = record.linked[model];
                    for (const index in changes) {
                        const change = changes[index];
                        if (change.id === old_id) {
                            change.id = new_id;
                        }
                        if (change.change === old_id) {
                            change.change = new_id;
                        }

                        record.linked[model][index] = change;
                    }
                }
                tasks.push(this.updateSyncRecord(record.id, record));
            }
            return Promise.all(tasks);
        },

        /**
         * Send transactions to synchronize to Odoo
         * If one fails, all the process will be aborted.
         *
         * @private
         * @returns {Promise}
         */
        run: function() {
            return new Promise(async (resolve, reject) => {
                try {
                    const sync_keys_done = [];
                    const records = await this.getSyncRecords();
                    if (records.length) {
                        this.sendRecordsToPages(true);
                    }
                    for (const record of records) {
                        let s_args = record.args;
                        // Remove generated client ids to be generated by server side
                        if (record.method === "create") {
                            const [response_s] = await rpc.callJSonRpc(
                                record.model,
                                "default_get",
                                s_args,
                                record.kwargs
                            );
                            const defaults = (await response_s.json()).result;
                            s_args = _.map(record.args, item => {
                                const values = _.omit(item, ["id", "display_name"]);
                                if (values.name) {
                                    values.name = values.name.replace(
                                        /\(?Offline Record #\d+\)?/,
                                        ""
                                    );
                                }
                                for (const key in values) {
                                    if (!values[key] && key in defaults) {
                                        values[key] = defaults[key];
                                    }
                                }
                                return values;
                            });
                        }
                        let response = false;
                        try {
                            [response] = await rpc.callJSonRpc(
                                record.model,
                                record.method,
                                s_args,
                                record.kwargs
                            );
                        } catch (err) {
                            console.log(
                                "[ServiceWorker] Error: can't synchronize the current record. Aborting!"
                            );
                            await this.updateSyncRecord(record.id, {failed: true});
                            break;
                        }
                        // Propagate the new id to the rest of the records
                        if (record.method === "create") {
                            const response_clone = response.clone();
                            const data = await response_clone.json();
                            const new_ids =
                                typeof data.result === "number"
                                    ? [data.result]
                                    : data.result;
                            for (const index_b in new_ids) {
                                const new_id = new_ids[index_b];
                                const old_id = record.args[index_b].id;
                                // UpdateIds can not found the key... so is normal get fails here
                                try {
                                    await this._updateIds(records, old_id, new_id);
                                } catch (err) {
                                    // Do nothing
                                }
                                // Update linked records
                                const linked_models = Object.keys(record.linked);
                                for (const model of linked_models) {
                                    const changes = record.linked[model];
                                    for (const change of changes) {
                                        // Update normal records
                                        const model_record = await this._db.browse(
                                            model,
                                            change.id
                                        );
                                        if (_.isEmpty(model_record)) {
                                            continue;
                                        }
                                        let field = model_record[change.field];
                                        if (typeof field === "object") {
                                            field = _.map(field, item => {
                                                if (item === change.change) {
                                                    return new_id;
                                                }
                                                return item;
                                            });
                                        } else {
                                            field = new_id;
                                        }
                                        model_record[change.field] = field;
                                        await this._db.unlink(model, [change.id]);
                                        await this._db.create(model, model_record);

                                        // Update sync records
                                        for (const srecord of records) {
                                            if (srecord.model !== model) {
                                                continue;
                                            }
                                            // If (srecord.id)
                                            for (const record_sync of srecord.args) {
                                                let values_rec_sync =
                                                    record_sync[change.field];
                                                if (
                                                    typeof values_rec_sync === "object"
                                                ) {
                                                    values_rec_sync = _.map(
                                                        values_rec_sync,
                                                        item => {
                                                            if (
                                                                item === change.change
                                                            ) {
                                                                return new_id;
                                                            }
                                                            return item;
                                                        }
                                                    );
                                                } else {
                                                    values_rec_sync = new_id;
                                                }
                                                record_sync[
                                                    change.field
                                                ] = values_rec_sync;
                                            }
                                        }
                                    }
                                }

                                const old_record = await this._db.browse(
                                    record.model,
                                    old_id
                                );
                                old_record.id = new_id;
                                await this._db.unlink(record.model, [old_id]);
                                await this._db.create(record.model, old_record);
                            }
                        }
                        await this.removeSyncRecords([record.id]);
                        sync_keys_done.push(record.id);
                        this._sendRecordOKToPages(record.id);
                    }
                } catch (err) {
                    return reject(err);
                }

                this.sendCountToPages();
                this._sendRecordsCompletedToPages();
                return resolve();
            });
        },

        /**
         * Send transactions to synchronize to the client pages
         * This will open a dialog to display the transactions.
         *
         * @param {Boolean} forced_sync
         * @returns {Promise}
         */
        sendRecordsToPages: function(forced_sync = false) {
            return this.getSyncRecords().then(records => {
                this.postBroadcastMessage({
                    type: "PWA_SYNC_RECORDS",
                    records: records,
                    forced_sync: forced_sync,
                });
            });
        },

        /**
         * This will update the counter of transactions to synchronize on the
         * client pages.
         *
         * @returns {Promise}
         */
        sendCountToPages: function() {
            return this.getSyncRecords().then(records => {
                this.postBroadcastMessage({
                    type: "PWA_SYNC_RECORDS_COUNT",
                    count: records.length,
                });
            });
        },

        /**
         * Send correct sync process to the client pages
         *
         * @private
         * @param {Number} index
         */
        _sendRecordOKToPages: function(index) {
            this.postBroadcastMessage({
                type: "PWA_SYNC_RECORD_OK",
                index: index,
            });
        },

        /**
         * Send completed sync. tasks
         *
         * @private
         */
        _sendRecordsCompletedToPages: function() {
            this.postBroadcastMessage({
                type: "PWA_SYNC_RECORDS_COMPLETED",
            });
        },

        _onReceiveBroadcastMessage: function(evt) {
            const res = BroadcastMixin._onReceiveBroadcastMessage.call(this, evt);
            if (!res || !this.isActivated()) {
                return;
            }
            switch (evt.data.type) {
                // Received to send pwa sync. records to the user page.
                case "GET_PWA_SYNC_RECORDS":
                    this.sendRecordsToPages();
                    break;

                // Received to start the sync. process
                case "START_SYNCHRONIZATION":
                    this.run().then(
                        () => this.getParent()._doPrefetchDataPost(),
                        err => {
                            console.log(
                                "[ServiceWorker] Error: can't complete the synchronization process."
                            );
                            console.log(err);
                        }
                    );
                    break;
            }
        },
    });

    return SWSyncManager;
});
